The
Hugs
Graphics
Library
(V
ersion
2.0)
Alastair
Reid
Departmen
t
of
Computer
Science
Univ
ersit
y
of
Utah
reid@cs.utah.edu
June
26,
2000
1
In
tro
duction
The
Hugs
Graphics
Lib
ra
ry
is
designed
to
giv
e
the
programmer
access
to
most
in
teresting
parts
of
the
Win32
Graphics
Device
In
terface
and
X11
library
without
exp
osing
the
programmer
to
the
pain
and
anguish
usually
asso
ciated
with
using
these
in
terfaces.
T
o
giv
e
y
ou
a
taste
of
what
the
library
lo
oks
lik
e,
here
is
the
obligatory
\Hello
W
orld"
program:
>
module
Hello
where
>
>
import
GraphicsUtils
>
>
helloWorld
::
IO
()
>
helloWorld
=
runGraphics
(do
>
w
<-
openWindow
"Hello
World
Window"
(300,
300)
>
drawInWindow
w
(text
(100,
100)
"Hello")
>
drawInWindow
w
(text
(100,
200)
"World")
>
getKey
w
>
closeWindow
w
>
)
Here's
what
eac
h
function
do
es:

runGraphics
::
IO
()
->
IO
()
get
Hugs
ready
to
do
graphics,
runs
an
action
(here,
the
action
is
a
sequence
of
5
subactions)
and
cleans
ev
erything
up
at
the
end.
1

openWindow
::
Title
->
Point
->
IO
Window
op
ens
a
windo
w
sp
ecifying
the
windo
w
title
\Hello
W
orld
Windo
w"
and
the
size
of
the
windo
w
(300
pixels

300
pixels).

drawInWindow
::
Window
->
Graphic
->
IO
()
dra
ws
a
Graphic
on
a
Window.
1
The
description
of
runGraphics
is
rather
v
ague
b
ecause
of
our
promise
to
protect
y
ou
from
the
full
horror
of
Win32/X11
programming.
If
y
ou
really
w
an
t
to
kno
w,
w
e
highly
recommend
Charles
P
etzold's
b
o
ok
\Programming
Windo
ws"
[2]
whic
h
do
es
an
excellen
t
job
with
a
diÃ†cult
sub
ject
or
Adrian
Ny
e's
\Xlib
Programming
Man
ual"
[1]
whic
h
is
almost
adequate.
1


text
::
Point
->
String
->
Graphic
creates
a
Graphic
consisting
of
a
String
at
a
giv
en
screen
lo
cation.

getKey
::
Window
->
IO
Char
w
aits
for
the
user
to
press
(and
release)
a
k
ey
.
This
is
necessary
to
prev
en
t
the
windo
w
from
closing
b
efore
y
ou
ha
v
e
a
c
hance
to
read
what's
on
the
screen.

closeWindow
::
Window
->
IO
()
closes
the
windo
w.
The
rest
of
this
do
cumen
t
is
organized
as
follo
ws:
Section
2
describ
es
the
Graphic
t
yp
e
(a
declarativ
e
w
a
y
of
dra
wing
pictures);
Section
3
describ
es
Windows;
Section
4
describ
es
Events;
Section
5
describ
es
the
Concurren
t
Hask
ell
primitiv
es
whic
h
y
ou
need
to
create
complex
in
terfaces;
and
Section
6
describ
es
the
Draw
monad
(a
more
imp
erativ
e
side
to
the
Graphic
t
yp
e).
2
Graphics
In
section
1,
w
e
used
these
t
w
o
functions
to
dra
w
to
a
windo
w
>
drawInWindow
::
Window
->
Graphic
->
IO
()
>
text
::
Point
->
String
->
Graphic
This
section
describ
es
other
w
a
ys
of
creating
graphics
that
can
b
e
dra
wn
to
the
screen.
2.1
A
tomic
Graphics
Here's
a
list
of
the
atomic
op
erations
>
emptyGraphic
::
Graphic
>
ellipse
::
Point
->
Point
->
Graphic
>
shearEllipse
::
Point
->
Point
->
Point
->
Graphic
>
arc
::
Point
->
Point
->
Angle
->
Angle
->
Graphic
>
line
::
Point
->
Point
->
Graphic
>
polyline
::
[Point]
->
Graphic
>
polygon
::
[Point]
->
Graphic
>
polyBezier
::
[Point]
->
Graphic
>
text
::
Point
->
String
->
Graphic
emptyGraphic
is
a
blank
Graphic.
ellipse
is
a
lled
ellipse
whic
h
ts
inside
a
rectangle
dened
b
y
t
w
o
Points
on
the
windo
w.
shearEllipse
is
a
lled
ellipse
inside
a
parallelogram
dened
b
y
three
Points
on
the
windo
w.
arc
is
an
unlled
elliptical
arc
whic
h
ts
inside
a
rectangle
dened
b
y
t
w
o
Points
on
the
windo
w.
The
angles
sp
ecify
the
start
and
end
p
oin
ts
of
the
arc
|
the
arc
consists
of
all
p
oin
ts
from
the
start
angle
coun
ter-clo
c
kwise
to
the
end
angle.
Angles
are
in
degrees
[0::360]
rather
than
radians
[0::2
].
line
is
a
line
b
et
w
een
t
w
o
Points.
polyline
is
a
series
of
lines
through
a
list
of
Points.
polyBezier
is
a
series
of
(unlled)
b
ezier
curv
es
dened
b
y
a
list
of
3n
+
1
con
trol
Points.
polygon
is
a
lled
p
olygon
dened
b
y
a
list
of
Points.
text
is
a
rendered
String.
P
ortabilit
y
Note:

polyBezier
is
not
pro
vided
in
the
X11
implemen
tation
of
this
library
.

shearEllipse
is
implemen
ted
b
y
p
olygons
on
b
oth
Win32
and
X11.
End
P
ortabilit
y
Note.
2

2.2
Graphic
Mo
diers
One
of
the
most
useful
prop
erties
of
Graphics
is
that
they
can
b
e
mo
died
in
v
arious
w
a
ys.
Here
is
a
selection
of
the
mo
diers
a
v
ailable
>
withFont
::
Font
->
Graphic
->
Graphic
>
withTextColor
::
RGB
->
Graphic
->
Graphic
>
withTextAlignment
::
Alignment
->
Graphic
->
Graphic
>
withBkColor
::
RGB
->
Graphic
->
Graphic
>
withBkMode
::
BkMode
->
Graphic
->
Graphic
>
withPen
::
Pen
->
Graphic
->
Graphic
>
withBrush
::
Brush
->
Graphic
->
Graphic
>
withRGB
::
RGB
->
Graphic
->
Graphic
The
eect
of
these
\mo
diers"
is
to
mo
dify
the
w
a
y
in
whic
h
a
graphic
will
b
e
dra
wn.
F
or
example,
if
courier
::
Font
is
a
10
p
oin
t
Courier
fon
t,
then
dra
wing
withFont
courier
(text
(100,100)
"Hello")
will
dra
w
the
string
"Hello"
on
the
windo
w
using
the
10
p
oin
t
Courier
fon
t.
Mo
diers
are
cum
ulativ
e:
a
series
of
mo
diers
can
b
e
applied
to
a
single
graphic.
F
or
example,
the
graphic
>
withFont
courier
(
>
withTextColor
red
(
>
withTextAlignme
nt
(Center,
Top)
(
>
text
(100,100)
"Hello
World"
>
)
>
)
>
)
will
b
e

horizon
tally
aligned
so
that
the
cen
tre
of
the
text
is
at
(100,
100);

v
ertically
aligned
so
that
the
top
of
the
text
is
at
(100,
100);

colored
red

displa
y
ed
in
10
p
oin
t
Courier
fon
t
Mo
diers
nest
in
the
ob
vious
w
a
y
|
so
>
withTextColor
red
(
>
withTextColor
green
(
>
text
(100,100)
"What
Color
Am
I?"
>
)
>
)
will
pro
duce
green
text,
as
exp
ected.
Aside
As
y
ou
write
more
and
more
complex
graphics,
y
ou'll
quic
kly
realize
that
it's
v
ery
tedious
to
insert
all
those
paren
theses
and
to
k
eep
ev
erything
inden
ted
in
a
w
a
y
that
rev
eals
its
structure.
F
ortunately
,
the
Hask
ell
Prelude
pro
vides
a
righ
t
asso
ciativ
e
application
op
erator
>
($)
::
(a
->
b)
->
a
->
b
whic
h
eliminates
the
need
for
almost
all
paren
theses
when
dening
Graphics.
Using
the
($)
op
erator,
the
ab
o
v
e
example
can
b
e
rewritten
lik
e
this
>
withTextColor
red
$
>
withTextColor
green
$
>
text
(100,100)
"What
Color
Am
I?"
End
aside.
3

2.3
Com
bining
Graphics
The
other
useful
prop
ert
y
of
Graphics
is
that
they
can
b
e
com
bined
using
the
overGraphic
com
binator
>
overGraphic
::
Graphic
->
Graphic
->
Graphic
F
or
example,
dra
wing
this
graphic
pro
duces
a
red
triangle
\on
top
of
"
(or
\in
fron
t
of
")
a
blue
square
>
overGraphic
>
(withBrush
red
$
polygon
[(200,200),(400
,20
0)
,(
300
,4
00)
])
>
(withBrush
blue
$
polygon
[(100,100),(500
,10
0)
,(
500
,5
00)
,(
100
,5
00
)])
Notice
that
mo
diers
resp
ect
the
structure
of
a
graphic
|
mo
diers
applied
to
one
part
of
a
graphic
ha
v
e
no
eect
on
other
parts
of
the
graphic.
F
or
example
the
ab
o
v
e
graphic
could
b
e
rewritten
lik
e
this.
>
withBrush
blue
$
>
overGraphic
>
(withBrush
red
$
polygon
[(200,200),(400
,20
0)
,(
300
,4
00)
])
>
(polygon
[(100,100),(500
,10
0)
,(5
00
,5
00)
,(
100
,5
00
)])
The
overGraphics
function
is
useful
if
y
ou
w
an
t
to
dra
w
a
list
of
graphics.
It's
t
yp
e
and
denition
are
>
overGraphics
::
[Graphic]
->
Graphic
>
overGraphics
=
foldr
overGraphic
emptyGraphic
Notice
that
graphics
at
the
head
of
the
list
are
dra
wn
\in
fron
t
of
"
graphics
at
the
tail
of
the
list.
2.4
A
ttribute
Generators
The
graphic
mo
diers
listed
at
the
start
of
Section
2.2
use
attributes
with
t
yp
es
lik
e
Font,
RGB
and
Brush,
but
so
far
w
e
ha
v
e
no
w
a
y
of
generating
an
y
of
these
attributes.
Some
of
these
t
yp
es
are
c
oncr
ete
(y
ou
can
create
them
using
normal
data
constructors)
and
some
are
abstr
act
(y
ou
can
only
create
them
with
sp
ecial
\attribute
generators").
Here's
the
denitions
of
the
concrete
t
yp
es.
>
type
Angle
=
Double
>
type
Dimension
=
Int
>
type
Point
=
(Dimension,Dimens
io
n)
>
data
RGB
=
RGB
Int
Int
Int
>
>
--
Text
alignments
>
type
Alignment
=
(HAlign,
VAlign)
>
--
names
have
a
tick
to
distinguish
them
from
Prelude
names
(blech!)
>
data
HAlign
=
Left'
|
Center
|
Right'
>
data
VAlign
=
Top
|
Baseline
|
Bottom
>
>
--
Text
background
modes
>
data
BkMode
=
Opaque
|
Transparent
The
attributes
Font,
Brush
and
Pen
are
abstr
act,
and
are
a
little
more
complex
b
ecause
w
e
w
an
t
to
delete
the
fon
t,
brush,
or
p
en
once
w
e'v
e
nished
using
it.
This
giv
es
the
attribute
generators
a
similar
a
v
our
to
the
mo
diers
seen
in
section
2.2
|
these
functions
are
applied
to
an
argumen
t
of
t
yp
e

!
Graphic
and
return
a
Graphic.
4

>
mkFont
::
Point
->
Angle
->
Bool
->
Bool
->
String
->
>
(Font
->
Graphic)
->
Graphic
>
mkBrush
::
RGB
->
(Brush
->
Graphic)
->
Graphic
>
mkPen
::
Style
->
Int
->
RGB
->
(Pen
->
Graphic)
->
Graphic
F
or
example,
the
follo
wing
program
uses
a
50

50
pixel,
non-b
old,
italic,
courier
fon
t
to
dra
w
red
text
on
a
green
bac
kground
at
an
angle
of
45
degrees
across
the
screen.
>
fontDemo
=
runGraphics
$
do
>
w
<-
openWindow
"Font
Demo
Window"
(100,100)
>
drawInWindow
w
$
>
withTextColor
(RGB
255
0
0)
$
>
mkFont
(50,100)
(pi/4)
False
True
"courier"
$
\
font
->
>
withFont
font
$
>
withBkColor
(RGB
0
255
0)
$
>
withBkMode
Opaque
$
>
text
(50,50)
"Font
Demo"
>
getKey
w
>
closeWindow
w
A
default
fon
t
is
substituted
if
the
requested
fon
t
do
es
not
exist.
The
rotation
angle
is
ignored
if
the
fon
t
is
not
a
\T
rueT
yp
e"
fon
t
(e.g.,
for
System
fon
t
on
Win32).
P
ortabilit
y
Note:

X11
do
es
not
directly
supp
ort
fon
t
rotation
so
mkFont
alw
a
ys
ignores
the
rotation
angle
argumen
t
in
the
X11
implemen
tation
of
this
library
.

Man
y
of
the
fon
t
families
t
ypically
a
v
ailable
on
Win32
are
not
a
v
ailable
on
X11
(and
vic
e-versa
).
In
our
exp
erience,
the
fon
t
families
\courier,"
\helv
etica"
and
\times"
are
somewhat
p
ortable.
End
P
ortabilit
y
Note.
2.5
Brushes,
P
ens
and
T
ext
Colors
If
y
ou
w
ere
coun
ting,
y
ou'll
ha
v
e
noticed
that
there
are
v
e
separate
w
a
ys
of
sp
ecifying
colors
>
mkBrush
::
RGB
->
(Brush
->
Graphic)
->
Graphic
>
mkPen
::
Style
->
Int
->
RGB
->
(Pen
->
Graphic)
->
Graphic
>
withTextColor
::
RGB
->
Graphic
->
Graphic
>
withBkColor
::
RGB
->
Graphic
->
Graphic
>
withRGB
::
RGB
->
Graphic
->
Graphic
What
do
these
dieren
t
mo
diers
and
attributes
con
trol?
Brushes
are
used
when
lling
shap
es
|
so
the
brush
color
is
used
when
dra
wing
p
olygons,
ellipses
and
regions.
P
ens
are
used
when
dra
wing
lines
|
so
the
p
en
color
is
used
when
dra
wing
arcs,
lines,
p
olylines
and
p
olyBeziers.
P
ens
also
ha
v
e
a
\st
yle"
and
a
\width".
The
Style
argumen
t
is
used
to
select
solid
lines
or
v
arious
st
yles
of
dotted
and
dashed
lines.
5

>
data
Style
>
=
Solid
>
|
Dash
--
"-------"
>
|
Dot
--
"......."
>
|
DashDot
--
"_._._._"
>
|
DashDotDot
--
"_.._.._"
>
|
Null
>
|
InsideFrame
T
extColor
is
used
as
the
foreground
color
when
dra
wing
text.
BkColor
is
used
as
the
bac
kground
color
when
dra
wing
text
with
bac
kground
mo
de
Opaque.
The
bac
k-
ground
color
is
ignored
when
the
mo
de
is
Transparent.
Finally
,
withRGB
is
a
con
v
enience
function
whic
h
sets
the
brush,
p
en
and
text
colors
to
the
same
v
alue.
Here
is
its
denition
>
withRGB
::
RGB
->
Graphic
->
Graphic
>
withRGB
c
g
=
>
mkBrush
c
$
\
brush
->
>
withBrush
brush
$
>
mkPen
Solid
2
c
$
\
pen
->
>
withPen
pen
$
>
withTextColor
c
$
>
g
P
ortabilit
y
Note:

On
Win32,
the
p
en
is
also
used
to
dra
w
a
line
round
all
the
lled
shap
es
|
so
the
p
en
color
also
aects
ho
w
p
olygons,
ellipses
and
regions
are
dra
wn.

One
of
the
Win32
\gotc
has"
is
that
the
c
hoice
of
Style
only
applies
if
the
width
is
1
or
less.
With
greater
widths,
the
p
en
st
yle
will
alw
a
ys
b
e
Solid
no
matter
what
y
ou
try
to
select.
This
problem
do
es
not
apply
to
X11.
End
P
ortabilit
y
Note.
2.6
Named
Colors
W
orking
with
R
GB
triples
is
a
pain
in
the
nec
k
so
the
GraphicsUtils
mo
dule
pro
vides
these
built
in
colors
as
con
v
enien
t
\abbreviations."
>
data
Color
>
=
Black
>
|
Blue
>
|
Green
>
|
Cyan
>
|
Red
>
|
Magenta
>
|
Yellow
>
|
White
>
deriving
(Eq,
Ord,
Bounded,
Enum,
Ix,
Show,
Read)
This
t
yp
e
is
useful
b
ecause
it
ma
y
b
e
used
to
index
an
arra
y
of
R
GB
triples.
6

>
colorTable
::
Array
Color
RGB
F
or
example,
w
e
pro
vide
this
function
whic
h
lo
oks
up
a
color
in
the
colorTable
and
uses
that
color
for
the
brush,
p
en
and
text
color.
>
withColor
::
Color
->
Graphic
->
Graphic
It's
w
orth
p
oin
ting
out
that
there's
nothing
\magical"
ab
out
the
Color
t
yp
e
or
our
c
hoice
of
colors.
If
y
ou
don't
lik
e
our
c
hoice
of
colors,
our
names,
or
the
w
a
y
w
e
mapp
ed
them
on
to
R
GB
triples,
y
ou
can
write
y
our
o
wn!
T
o
get
y
ou
started,
here's
our
implemen
tation
of
withColor
and
colorTable.
>
withColor
c
=
withRGB
(colorTable
!
c)
>
>
colorTable
=
array
(minBound,
maxBound)
colorList
>
>
colorList
::
[(Color,
RGB)]
>
colorList
=
>
[
(Black
,
RGB
0
0
0)
>
,
(Blue
,
RGB
0
0
255)
>
,
(Green
,
RGB
0
255
0)
>
,
(Cyan
,
RGB
0
255
255)
>
,
(Red
,
RGB
255
0
0)
>
,
(Magenta
,
RGB
255
0
255)
>
,
(Yellow
,
RGB
255
255
0)
>
,
(White
,
RGB
255
255
255)
>
]
2.7
Bitmaps
Bitmaps
can
b
e
displa
y
ed
in
three
w
a
ys:
1.
with
no
transformation
at
a
p
oin
t
2.
stretc
hed
to
t
a
rectangle
3.
rotated
and
sheared
to
t
a
parallelogram
Rectangles
are
sp
ecied
b
y
a
pair
of
p
oin
ts:
the
top-left,
and
b
ottom-righ
t
corners
of
the
rectangle.
>
bitmap
::
Point
->
Bitmap
->
Graphic
>
stretchBitmap
::
Point
->
Point
->
Bitmap
->
Graphic
>
shearBitmap
::
Point
->
Point
->
Point
->
Bitmap
->
Graphic
Bitmaps
are
read
in
from
les
and
disp
osed
of
using
>
readBitmap
::
String
->
IO
Bitmap
>
deleteBitmap
::
Bitmap
->
IO
()
(but
b
e
sure
that
the
curren
t
Graphic
on
a
Window
do
esn't
con
tain
a
reference
to
a
Bitmap
b
efore
y
ou
delete
the
Bitmap!)
This
op
eration
gets
the
size
of
a
bitmap.
>
getBitmapSize
::
Bitmap
->
IO
(Int,
Int)
7

P
ortabilit
y
Note:

The
Bitmap
functions
are
not
curren
tly
pro
vided
in
the
X11
implemen
tation
of
this
library
.

shearBitmap
is
supp
orted
on
Win'NT
but
not
Win'95.
End
P
ortabilit
y
Note.
2.8
Regions
Regions
can
b
e
view
ed
as
an
eÃ†cien
t
represen
tation
of
sets
of
pixels.
They
are
created
from
rectangles,
ellipses,
p
olygons
and
com
bined
using
set
op
erations
(in
tersection,
union,
dierence
and
xor
(symmetric
dierence)).
These
are
the
op
erations
a
v
ailable:
>
emptyRegion
::
Region
>
rectangleRegion
::
Point
->
Point
->
Region
>
ellipseRegion
::
Point
->
Point
->
Region
>
polygonRegion
::
[Point]
->
Region
>
>
intersectRegion
::
Region
->
Region
->
Region
>
unionRegion
::
Region
->
Region
->
Region
>
subtractRegion
::
Region
->
Region
->
Region
>
xorRegion
::
Region
->
Region
->
Region
>
>
regionToGraphic
::
Region
->
Graphic
withBrush
aects
the
color
of
regionToGraphic.
P
ortabilit
y
Note:

emptyRegion
is
not
pro
vided
in
the
Win32
implemen
tation
of
this
library
.
It
is
p
ossible
to
use
an
empt
y
rectangle
region
instead

ellipseRegion
is
implemen
ted
using
p
olygons
in
the
X11
implemen
tation
of
the
library
.
End
P
ortabilit
y
Note.
2.9
The
Graphic
Algebra
The
Graphic
mo
diers
satisfy
a
large
n
um
b
er
of
useful
iden
tities.
F
or
example,

The
triple
hGraphic
;
overGraphic
;
emptyGraphic
i
forms
a
\monoid."
If
this
w
asn't
true,
w
e
w
ouldn't
nd
the
overGraphics
function
v
ery
useful.

Mo
diers
and
generators
all
distribute
o
v
er
overGraphic.
That
is,
>
mkFoo
<args>
(p1
`overGraphic`
p2)
>
=
(mkFoo
<args>
p1)
`overGraphic`
(mkFoo
<args>
p2)
>
withFoo
foo
(p1
`overGraphic`
p2)
>
=
(withFoo
foo
p1)
`overGraphic`
(withFoo
foo
p2)
(These
la
ws
are
esp
ecially
useful
when
trying
to
mak
e
programs
more
eÃ†cien
t
|
see
section
2.10.)
8


\Indep
enden
t"
mo
diers
comm
ute
with
eac
h
other.
F
or
example,
>
withTextColor
c
(withTextAlignme
nt
a
p)
>
=
withTextAlignment
a
(withTextColor
c
p)

Generators
comm
ute
with
mo
diers.
F
or
example,
>
mkBrush
c
(\
b
->
withBrush
b'
p)
=
withBrush
b'
mkBrush
c
(\
b
->
p)
if
b
and
b'
are
distinct.

Generators
comm
ute
with
other
generators.
F
or
example
>
mkBrush
c
(\
b
->
mkBrush
c'
(\
b'
->
p))
>
=
mkBrush
c'
(\
b'
->
mkBrush
c
(\
b
->
p))
if
b
and
b'
are
distinct.

\Irrelev
an
t"
mo
diers
and
generators
can
b
e
added
or
remo
v
ed
at
will.
F
or
example,
the
text
color
has
no
eect
on
line
dra
wing
>
withTextColor
c
(line
p0
p1)
=
line
p0
p1
and
there's
no
need
to
create
a
brush
if
y
ou
don't
use
it
>
mkBrush
c
(\
b
->
p)
=
p,
if
b
does
not
occur
in
p
This
last
la
w
can
also
b
e
stated
in
the
form
>
mkBrush
c
(\
b
->
atomic)
=
atomic
for
an
y
atomic
op
eration.
The
practical
upshot
of
all
this
is
that
there
are
man
y
w
a
ys
to
rearrange
a
graphic
so
that
it
will
b
e
dra
wn
more
(or
less)
eÃ†cien
tly
.
W
e
explore
this
topic
in
the
next
section.
2.10
EÃ†ciency
Considerations
The
other
sections
pro
vide
a
v
ery
simple
set
of
functions
for
creating
graphics
|
but
at
the
cost
of
ignoring
eÃ†ciency
.
F
or
example,
this
inno
cen
t
lo
oking
graphic
>
overGraphics
>
[
withColor
Red
$
ellipse
(000,000)
(100,100)
>
,
withColor
Red
$
ellipse
(100,100)
(200,200)
>
,
withColor
Red
$
ellipse
(200,200)
(300,300)
>
]
will
tak
e
longer
to
dra
w
than
this
equiv
alen
t
graphic
>
mkBrush
(colorTable
!
Red)
$
\
redBrush
->
>
overGraphics
>
[
withBrush
redBrush
$
ellipse
(000,000)
(100,100)
>
,
withBrush
redBrush
$
ellipse
(100,100)
(200,200)
>
,
withBrush
redBrush
$
ellipse
(200,200)
(300,300)
>
]
9

Briey
,
the
problems
are
that
withColor
sets
the
color
of
the
brush,
the
p
en
and
the
text
but
ellipses
only
use
the
brush
color;
and
w
e're
calling
withColor
3
times
more
than
w
e
ha
v
e
to.
This
w
ouldn't
matter
if
brush
creation
w
as
c
heap
and
easy
.
Ho
w
ev
er,
most
t
ypical
w
orkstations
can
only
displa
y
at
most
256
or
65536
dieren
t
colors
on
the
screen
at
once
but
allo
w
y
ou
to
sp
ecify
an
y
one
of
16777216
dieren
t
colors
when
selecting
a
dra
wing
color
|
nding
a
close
matc
h
to
the
requested
color
can
b
e
as
exp
ensiv
e
as
dra
wing
the
primitiv
e
ob
ject
itself.
This
do
esn't
matter
m
uc
h
for
a
graphic
of
this
size
|
but
if
y
ou're
dra
wing
sev
eral
thousand
graphic
elemen
ts
on
to
the
screen
as
part
of
an
animation,
it
can
mak
e
the
dierence
b
et
w
een
a
quite
resp
ectable
frame
rate
of
20{30
frames
p
er
second
and
an
absolutely
un
usable
frame
rate
of
2{3
frames
p
er
second.
2.10.1
Eliminate
calls
to
withRGB
and
withColor
A
t
the
risk
of
p
oin
ting
out
the
ob
vious,
the
rst
step
in
optimizing
a
program
in
this
w
a
y
is
to
expand
all
uses
of
the
withRGB
and
withColor
functions
and
eliminating
unnecessary
calls
to
mkBrush,
mkPen
and
withTextColor.
Applying
this
optimization
to
the
ab
o
v
e
Graphic,
w
e
obtain
this
(whic
h
should
run
ab
out
3
times
faster).
>
overGraphics
>
[
mkBrush
red
$
\
redBrush
->
withBrush
redBrush
$
ellipse
(00,00)
(10,10)
>
,
mkBrush
red
$
\
redBrush
->
withBrush
redBrush
$
ellipse
(10,10)
(20,20)
>
,
mkBrush
red
$
\
redBrush
->
withBrush
redBrush
$
ellipse
(20,20)
(30,30)
>
]
2.10.2
Lifting
generators
to
the
top
of
Graphics
Another
imp
ortan
t
optimization
is
to
a
v
oid
creating
man
y
iden
tical
brushes,
p
ens
or
fon
ts
when
one
will
do.
W
e
do
this
b
y
\lifting"
brush
creation
out
to
the
top
of
a
graphic.
F
or
example,
this
graphic
>
overGraphics
>
[
mkBrush
red
$
\
redBrush
->
withBrush
redBrush
$
ellipse
(00,00)
(10,10)
>
,
mkBrush
red
$
\
redBrush
->
withBrush
redBrush
$
ellipse
(10,10)
(20,20)
>
,
mkBrush
red
$
\
redBrush
->
withBrush
redBrush
$
ellipse
(20,20)
(30,30)
>
]
creates
three
red
brushes.
It
w
ould
b
e
more
eÃ†cien
t
to
rewrite
it
lik
e
this
>
mkBrush
red
$
\
redBrush
->
>
overGraphics
>
[
withBrush
redBrush
$
ellipse
(00,00)
(10,10)
>
,
withBrush
redBrush
$
ellipse
(10,10)
(20,20)
>
,
withBrush
redBrush
$
ellipse
(20,20)
(30,30)
>
]
If
y
our
program
uses
a
lot
of
brushes,
it
ma
y
b
e
more
con
v
enien
t
to
store
the
brushes
in
a
\palette"
(i.e.,
an
arra
y
of
brushes)
>
mkBrush
red
$
\
redBrush
->
>
mkBrush
blue
$
\
blueBrush
->
>
let
palette
=
array
(minBound,
maxBound)
>
[(Red,
redBrush),
(Blue,
blueBrush)]
>
in
10

>
overGraphics
>
[
withBrush
(palette
!
Red)
$
ellipse
(00,00)
(10,10)
>
,
withBrush
(palette
!
Blue)
$
ellipse
(10,10)
(20,20)
>
,
withBrush
(palette
!
Red)
$
ellipse
(20,20)
(30,30)
>
]
2.10.3
Lifting
generators
out
of
graphics
Ev
en
this
program
has
ro
om
for
impro
v
emen
t:
ev
ery
time
the
graphic
is
redra
wn
(e.g.,
whenev
er
the
windo
w
is
resized),
it
will
create
fresh
brushes
with
whic
h
to
dra
w
the
graphic.
The
graphics
library
pro
vides
a
w
a
y
round
this
|
but
it's
more
diÃ†cult
and
fraugh
t
with
danger.
Outline:
This
section
will
talk
ab
out
using
explicit
creation
and
deletion
functions
to
create
brushes,
fon
ts,
etc.
The
situation
isn't
v
ery
happ
y
at
the
momen
t
b
ecause
it's
easy
to
forget
to
deallo
cate
brushes
b
efore
y
ou
quit
or
to
deallo
cate
them
b
efore
y
ou
c
hange
the
graphic.
End
outline.
3
Windo
ws
In
section
1
w
e
sa
w
the
function
drawInWindow
for
dra
wing
a
Graphic
on
a
Window.
It
turns
out
that
drawInWindow
is
not
a
primitiv
e
function
but,
rather,
it
is
dened
using
these
t
w
o
primitiv
e
functions
whic
h
read
the
curren
t
Graphic
and
set
a
new
Graphic.
>
getGraphic
::
Window
->
IO
Graphic
>
setGraphic
::
Window
->
Graphic
->
IO
()
Here's
ho
w
these
functions
are
used
to
dene
the
function
drawInWindow
(whic
h
w
e
used
in
section
1)
and
another
useful
function
clearWindow.
>
drawInWindow
::
Window
->
Graphic
->
IO
()
>
drawInWindow
w
p
=
do
>
oldGraphic
<-
getGraphic
w
>
setGraphic
w
(p
`over`
oldGraphic)
>
>
clearWindow
::
Window
->
IO
()
>
clearWindow
w
=
setGraphic
w
emptyGraphic
4
Ev
en
ts
The
graphics
library
supp
orts
sev
eral
dieren
t
input
devices
(the
mouse,
the
k
eyb
oard,
etc)
eac
h
of
whic
h
can
generate
sev
eral
dieren
t
kinds
of
ev
en
t
(mouse
mo
v
emen
t,
mouse
button
clic
ks,
k
ey
presses,
k
ey
releases,
windo
w
resizing,
etc.)
4.1
Keyb
oard
ev
en
ts
In
section
1
w
e
sa
w
the
function
getKey
b
eing
used
to
w
ait
un
til
a
k
ey
w
as
pressed
and
released.
The
function
getKey
is
dened
in
terms
of
a
more
general
function
getKeyEx
11

>
getKeyEx
::
Window
->
Bool
->
IO
Char
whic
h
can
b
e
used
to
w
ait
un
til
a
k
ey
is
pressed
(getKeyEx
w
True)
or
un
til
it
is
released
(getKeyEx
w
False).
The
denition
of
getKey
using
this
function
is
trivial:
>
getKey
::
Window
->
IO
Char
>
getKey
w
=
do{
getKeyEx
w
True;
getKeyEx
w
False
}
4.2
Mouse
ev
en
ts
As
w
ell
as
w
aiting
for
k
eyb
oard
ev
en
ts,
w
e
can
w
ait
for
mouse
button
ev
en
ts.
W
e
pro
vide
three
functions
for
getting
these
ev
en
ts.
getLBP
and
getRBP
are
used
to
w
ait
for
left
and
righ
t
button
presses.
Both
functions
are
dened
using
getButton
whic
h
can
b
e
used
to
w
ait
for
either
the
left
button
or
the
righ
t
button
b
eing
either
pressed
or
released.
>
getLBP
::
Window
->
IO
Point
>
getRBP
::
Window
->
IO
Point
>
getButton
::
Window
->
Bool
->
Bool
->
IO
Point
>
>
getLBP
w
=
getButton
w
True
True
>
getRBP
w
=
getButton
w
False
True
4.3
General
ev
en
ts
The
functions
getKeyEx
and
getButton
describ
ed
in
the
previous
sections
are
not
primitiv
e
functions.
Rather
they
are
dened
using
the
primitiv
e
function
getWindowEvent
>
getWindowEvent
::
Window
->
IO
Event
whic
h
w
aits
for
the
next
\ev
en
t"
on
a
giv
en
Window.
Events
are
dened
b
y
the
follo
wing
data
t
yp
e.
>
data
Event
>
=
Key
{
char
::
Char,
isDown
::
Bool
}
>
|
Button
{
pt
::
Point,
isLeft,
isDown
::
Bool
}
>
|
MouseMove
{
pt
::
Point
}
>
|
Resize
>
|
Closed
>
deriving
Show
These
ev
en
ts
are:

Keyfchar,
isDowng
o
ccurs
when
a
k
ey
is
pressed
(isDown==True)
or
released
(isDown==False).
char
is
the
\k
eyco
de"
for
the
corresp
onding
k
ey
.
This
k
eyco
de
can
b
e
a
letter,
a
n
um
b
er
or
some
other
v
alue
corresp
onding
to
the
shift
k
ey
,
con
trol
k
ey
,
etc.

Buttonfpt,
isLeft,
isDowng
o
ccurs
when
a
mouse
button
is
pressed
(isDown==True)
or
released
(isDown==False).
pt
is
the
mouse
p
osition
when
the
button
w
as
pressed
and
isLeft
indicates
whether
it
w
as
the
left
or
the
righ
t
button.

MouseMovefptg
o
ccurs
when
the
mouse
is
mo
v
ed
inside
the
windo
w.
pt
is
the
p
osition
of
the
mouse
after
the
mo
v
emen
t.
12


Resize
o
ccurs
when
the
windo
w
is
resized.
The
new
windo
w
size
can
b
e
disco
v
ered
using
these
functions.
>
getWindowRect
::
Window
->
IO
(Point,
Size)
>
getWindowSize
::
Window
->
IO
Size
>
getWindowSize
w
=
do
>
(pt,sz)
<-
getWindowRect
w
>
return
sz

Resize
o
ccurs
when
the
windo
w
is
closed.
P
ortabilit
y
Note:

Programmers
should
assume
that
the
Event
datat
yp
e
will
b
e
extended
in
the
not-to
o-distan
t
future
and
that
individual
ev
en
ts
ma
y
c
hange
sligh
tly
.
As
a
minim
um,
y
ou
should
add
a
\matc
h
an
ything"
alternativ
e
to
an
y
function
whic
h
pattern
matc
hes
against
Events.

X11
systems
t
ypically
ha
v
e
three
button
mice.
Button
1
is
used
as
the
left
button,
button
3
as
the
righ
t
button
and
button
2
(the
middle
button)
is
ignored.
End
P
ortabilit
y
Note.
As
examples
of
ho
w
getWindowEvent
migh
t
b
e
used
in
a
program,
here
are
the
denitions
of
getKeyEx
and
getButton.
>
getKeyEx
::
Window
->
Bool
->
IO
Char
>
getKeyEx
w
down
=
loop
>
where
>
loop
=
do
>
e
<-
getWindowEvent
w
>
case
e
of
>
Key{
char
=
c,
isDown
}
>
|
isDown
==
down
>
->
return
c
>
_
->
loop
>
getButton
::
Window
->
Bool
->
Bool
->
IO
Point
>
getButton
w
left
down
=
loop
>
where
>
loop
=
do
>
e
<-
getWindowEvent
w
>
case
e
of
>
Button{pt,isLeft
,i
sDo
wn
}
>
|
isLeft
==
left
&&
isDown
==
down
>
->
return
pt
>
_
->
loop
4.4
Using
Timers
If
y
ou
w
an
t
to
use
a
timer,
y
ou
ha
v
e
to
op
en
the
windo
w
using
openWindowEx
instead
of
openWindow
13

>
openWindowEx
::
Title
->
Maybe
Point
->
Maybe
Size
->
>
RedrawMode
->
Maybe
Time
->
IO
Window
>
>
data
RedrawMode
>
=
Unbuffered
>
|
DoubleBuffered
This
extende
d
v
ersion
of
openWindow
tak
es
extra
parameters
whic
h
sp
ecify

the
initial
p
osition
of
a
windo
w;

ho
w
to
displa
y
a
graphic
on
a
windo
w;
and

the
time
b
et
w
een
tic
ks
(in
milliseconds).
The
function
openWindow
is
dened
using
openWindowEx
>
openWindow
name
size
=
openWindowEx
name
Nothing
(Just
size)
Unbuffered
Nothing
The
dra
wing
mo
de
can
b
e
either
DoubleBuffered
whic
h
uses
a
\double
buer"
to
reduce
ic
k
er
or
Unbuffered
whic
h
dra
ws
directly
to
the
windo
w
and
runs
sligh
tly
faster
but
is
more
prone
to
ic
k
er.
Y
ou
should
probably
use
DoubleBuffered
for
animations.
The
timer
generates
\tic
k
ev
en
ts"
at
regular
in
terv
als.
The
function
getWindowTick
w
aits
for
the
next
\tic
k
ev
en
t"
to
o
ccur.
>
getWindowTick
::
Window
->
IO
()
Aside
With
normal
ev
en
ts,
lik
e
button
presses,
w
e
store
ev
ery
ev
en
t
that
happ
ens
un
til
y
ou
remo
v
e
that
ev
en
t
from
the
queue.
If
w
e
did
this
with
tic
k
ev
en
ts,
and
y
our
program
tak
es
a
little
to
o
long
to
dra
w
eac
h
frame
of
an
animation,
the
ev
en
t
queue
could
b
ecome
so
sw
amp
ed
with
\tic
ks"
that
y
ou'd
nev
er
resp
ond
to
user
input.
T
o
a
v
oid
this
problem,
w
e
only
insert
a
tic
k
in
to
the
queue
if
there's
no
tic
k
there
already
.
End
aside.
Here's
a
simple
example
of
ho
w
to
use
timers.
Note
the
use
of
setGraphic
instead
of
drawInWindow.
>
timerDemo
=
do
>
w
<-
openWindowEx
>
"Timer
demo"
--
title
>
(Just
(500,500))
--
initial
position
of
window
>
(Just
(100,100))
--
initial
size
of
window
>
DoubleBuffered
--
drawing
mode
-
see
above
>
(Just
50)
--
tick
rate
>
let
>
loop
x
=
do
>
setGraphic
w
$
text
(0,50)
$
show
x
>
getWindowTick
w
--
wait
for
next
tick
on
window
>
loop
(x+1)
>
loop
0
14

5
Concurren
t
Hask
ell
If
y
ou
w
an
t
to
use
m
ultiple
windo
ws
or
eac
h
windo
w
con
tains
a
n
um
b
er
of
essen
tially
indep
enden
t
comp
o-
nen
ts,
it
is
con
v
enien
t
to
use
separate
threads
for
handling
eac
h
windo
w.
Hugs
pro
vides
a
simple
mec
hanism
for
doing
that.
The
simplest
concurrency
primitiv
es
are
par
and
par
>
par
::
IO
a
->
IO
b
->
IO
(a,b)
>
par_
::
IO
a
->
IO
b
->
IO
()
(These
are
b
oth
exp
orted
from
the
GraphicsUtils
mo
dule.)
These
run
t
w
o
IO
actions
in
parallel
and
terminate
when
b
oth
actions
terminate.
The
function
par
discards
the
results
of
the
actions.
Aside
The
underscore
in
the
name
par
is
deriv
ed
from
the
use
of
the
underscore
in
the
denition
of
par
.
>
par_
p
q
=
(p
`par`
q)
>>=
\
_
->
return
()
This
naming
con
v
en
tion
is
also
used
in
the
Hask
ell
Prelude
and
standard
libraries
(mapM
,
zipWithM
,
etc.).
End
aside.
The
function
parMany
generalizes
par
to
lists.
>
parMany
::
[
IO
()
]
->
IO
()
>
parMany
=
foldr
par_
(return
())
Of
course,
y
ou'll
quic
kly
realise
that
there's
not
m
uc
h
p
oin
t
in
b
eing
able
to
create
concurren
t
threads
if
threads
can't
comm
unicate
with
eac
h
other.
Hugs
pro
vides
an
implemen
tation
of
the
\Concurren
t
Hask
ell"
primitiv
es
describ
ed
in
the
Concurren
t
Hask
ell
pap
er
[3
]
to
whic
h
w
e
refer
the
en
th
usiastic
reader.
6
The
Draw
monad
The
Graphic
t
yp
e,
op
erations
and
com
binators
pro
vide
a
exible,
eÃ†cien
t
and
con
v
enien
t
w
a
y
of
dra
wing
images
on
a
windo
w
and
encapsulate
go
o
d
programming
practice
b
y
cleaning
up
an
y
c
hanges
they
m
ust
mak
e
to
the
state
of
the
windo
w.
In
some
applications
though,
it
is
appropriate
to
use
a
lo
w
er-lev
el,
more
error-
prone
in
terface
for
dra
wing
images.
F
or
example,
when
building
a
library
on
top
of
the
Graphics
library
,
one
migh
t
w
an
t
to
build
on
a
sligh
tly
more
eÃ†cien
t,
less
secure
in
terface.
Or,
when
teac
hing
courses
on
computer
graphics,
it
w
ould
not
b
e
p
ossible
to
demonstrate
lo
w-lev
el
asp
ects
of
graphics
using
an
in
terface
whic
h
hides
those
asp
ects.
This
section
describ
es
the
Draw
monad
(an
imp
erativ
e
graphics
in
terface)
and
describ
es
ho
w
this
is
used
to
implemen
t
the
Graphic
t
yp
e
(a
declarativ
e
graphics
in
terface).
This
section
can
b
e
ignored
b
y
most
readers.
6.1
The
Draw
monad
and
the
Graphic
t
yp
e
The
Graphic
t
yp
e
lets
y
ou
describ
e
what
an
image
should
lo
ok
lik
e;
the
Draw
monad
lets
y
ou
describ
e
ho
w
to
build
an
image.
These
views
in
tersect
for
atomic
graphics.
F
or
example,
the
function
to
dra
w
a
line
can
serv
e
b
oth
as
a
description
and
as
the
implemen
tation.
This
is
exploited
in
the
graphics
library
b
y
dening
Graphic
as
an
instance
of
the
Draw
monad.
Th
us,
all
Graphic
t
yp
es
and
op
erations
listed
in
section
2
can
also
b
e
used
with
the
Draw
monad.
15

>
data
Draw
a
=
...
>
instance
Functor
Draw
where
...
>
instance
Monad
Draw
where
...
>
>
type
Graphic
=
Draw
()
The
emptyGraphic
and
overGraphic
functions
are
implemen
ted
using
this
monad.
Their
denitions
should
not
b
e
surprising.
>
emptyGraphic
=
return
()
>
g1
`overGraphic`
g2
=
g2
>>
g1
6.2
Draw
mo
diers
and
generators
The
dierence
b
et
w
een
the
Draw
monad
and
the
Graphic
t
yp
e
is
that
the
Graphic
mo
diers
and
com
binators
resp
ect
the
structure
of
the
graphic
(see
section
2.3).
F
or
example,
the
withBrush
mo
dier
only
aects
the
color
of
the
Graphic
it
is
applied
to,
it
do
es
not
aect
the
color
of
the
Graphic
it
is
em
b
edded
in.
In
con
trast,
the
Draw
monad
pro
vides
op
erations
whic
h
c
hange
the
eect
of
subsequen
t
dra
wing
op
erations.
The
follo
wing
op
erations
corresp
ond
to
the
graphics
mo
diers
describ
ed
in
section
2.2.
>
selectFont
::
Font
->
Draw
Font
>
setTextColor
::
RGB
->
Draw
RGB
>
setTextAlignment
::
Alignment
->
Draw
Alignment
>
setBkColor
::
RGB
->
Draw
RGB
>
setBkMode
::
BkMode
->
Draw
BkMode
>
selectPen
::
Pen
->
Draw
Pen
>
selectBrush
::
Brush
->
Draw
Brush
These
op
erations
all
ha
v
e
a
t
yp
e
of
the
form

!
Draw
.
The
v
alue
returned
is
the
old
v
alue
of
the
attribute
b
eing
c
hanged
and
can
b
e
used
to
restore
the
attribute
to
its
previous
v
alue.
F
or
example,
the
withFont
mo
dier
could
b
e
implemen
ted
lik
e
this:
>
withFont
new
g
=
do
>
old
<-
selectFont
new
>
g
>
selectFont
old
>
return
()
Aside
This
pattern
of
use
is
v
ery
common
in
imp
erativ
e
programs
so
the
Hask
ell
IO
library
pro
vides
t
w
o
com
binators
whic
h
encapsulate
this
b
eha
vior.
The
bracket
function
tak
es
three
op
erations
as
argumen
ts:
a
pre-op
eration
left,
a
p
ost-op
eration
right
and
an
op
eration
middle
and
p
erforms
them
in
the
order
left;
middle;
right.
The
argumen
ts
are
pro
vided
in
the
order
left,
right,
middle
b
ecause
the
left
and
right
op
erations
are
often
\in
v
erses"
of
eac
h
other
suc
h
as
openFile
and
closeFile.
The
bracket
function
is
similar
and
is
used
when
the
middle
op
eration
do
es
not
require
the
result
of
the
left
op
eration.
>
bracket
::
IO
a
->
(a
->
IO
b)
->
(a
->
IO
c)
->
IO
c
>
bracket_
::
IO
a
->
(a
->
IO
b)
->
IO
c
->
IO
c
>
>
bracket
left
right
middle
=
do
>
a
<-
left
>
c
<-
middle
a
>
right
a
>
return
c
16

>
>
bracket_
left
right
middle
=
bracket
left
right
(const
middle)
End
aside.
The
graphics
library
pro
vides
similar
com
binators
for
the
Draw
monad:
>
bracket
::
Draw
a
->
(a
->
Draw
b)
->
(a
->
Draw
c)
->
Draw
c
>
bracket_
::
Draw
a
->
(a
->
Draw
b)
->
Draw
c
->
Draw
c
Aside
In
fact,
the
bracket
and
bracket
functions
do
sligh
tly
more
than
the
ab
o
v
e
description
suggests.
Those
pro
vided
in
the
IO
library
use
Hask
ell's
error-catc
hing
facilities
to
ensure
that
the
right
op
eration
is
p
erformed
ev
en
if
the
middle
op
eration
raises
an
IOError
whilst
those
in
the
Graphics
library
use
Hugs'
exception-handling
facilities
to
ensure
that
the
right
op
eration
is
p
erformed
ev
en
if
the
middle
op
eration
raises
an
exception.
End
aside.
Using
these
com
binators,
it
is
trivial
to
implemen
t
the
mo
diers
describ
ed
in
section
2.2.
>
withFont
x
=
bracket_
(selectFont
x)
selectFont
>
withTextColor
x
=
bracket_
(setTextColor
x)
setTextColor
>
withTextAlignment
x
=
bracket_
(setTextAlignment
x)
setTextAlignmen
t
>
withBkColor
x
=
bracket_
(setBkColor
x)
setBkColor
>
withBkMode
x
=
bracket_
(setBkMode
x)
setBkMode
>
withPen
x
=
bracket_
(selectPen
x)
selectPen
>
withBrush
x
=
bracket_
(selectBrush
x)
selectBrush
References
[1]
A.
Ny
e.
Xlib
Pr
o
gr
amming
Manual.
O'Reilly
and
Asso
ciates,
Inc.,
1988.
ISBN
0-937175-26-9.
[2]
C.
P
etzold.
Pr
o
gr
amming
Windows.
Microsoft
Press,
1999.
ISBN
1-57321-995-X
(hardbac
k).
[3]
S.
P
eyton
Jones,
A.
Gordon,
and
S.
Finne.
Concurren
t
Hask
ell.
In
Confer
enc
e
r
e
c
or
d
of
POPL
'96:
23r
d
A
CM
SIGPLAN-SIGA
CT
Symp
osium
on
Principles
of
Pr
o
gr
amming
Languages,
pages
295{308,
St.
P
etersburg
Beac
h,
FL,
Jan
uary
1996.
A
CM
press.
A
Quic
k
Reference
The
exp
orted
(stable)
in
terface
of
the
library
consists
of
all
sym
b
ols
exp
orted
from
GraphicsCore
and
GraphicsUtils.
GraphicsUtils
reexp
orts
all
sym
b
ols
exp
orted
b
y
GraphicsCore
and
it
is
exp
ected
that
most
users
will
only
imp
ort
GraphicsUtils;
the
GraphicsCore
in
terface
is
aimed
solely
at
those
wishing
to
use
the
graphics
library
as
a
base
on
whic
h
to
build
their
o
wn
library
or
who
nd
the
GraphicsUtils
in
terface
inappropriate
for
their
needs.
17

A.1
Mo
dule
GraphicsCore
>
type
Title
=
String
>
type
Point
=
(Int,Int)
>
type
Size
=
(Int,Int)
>
type
Angle
=
Double
>
type
Time
=
Word32
--
milliseconds
>
data
RGB
=
RGB
Word8
Word8
Word8
>
data
BkMode
=
Opaque
|
Transparent
>
>
type
Alignment
=
(HAlign,
VAlign)
>
--
names
have
a
tick
to
distinguish
them
from
Prelude
names
(blech!)
>
data
HAlign
=
Left'
|
Center
|
Right'
>
deriving
(Enum,
Eq,
Ord,
Ix,
Show)
>
data
VAlign
=
Top
|
Baseline
|
Bottom
>
deriving
(Enum,
Eq,
Ord,
Ix,
Show)
>
>
data
Style
>
=
Solid
>
|
Dash
--
"-------"
>
|
Dot
--
"......."
>
|
DashDot
--
"_._._._"
>
|
DashDotDot
--
"_.._.._"
>
|
Null
>
|
InsideFrame
>
>
runGraphics
::
IO
()
->
IO
()
>
getTime
::
IO
Time
>
>
data
Window
>
openWindowEx
::
Title
->
Maybe
Point
->
Maybe
Size
->
>
RedrawMode
->
Maybe
T.Time
->
IO
Window
>
>
closeWindow
::
Window
->
IO
()
>
getWindowRect
::
Window
->
IO
(Point,Point)
>
getWindowEvent
::
Window
->
IO
Event
>
getWindowTick
::
Window
->
IO
()
>
maybeGetWindowEve
nt
::
Window
->
IO
(Maybe
Event)
>
>
type
Graphic
=
Draw
()
>
setGraphic
::
Window
->
Graphic
->
IO
()
>
getGraphic
::
Window
->
IO
Graphic
>
modGraphic
::
Window
->
(Graphic
->
Graphic)
->
IO
()
>
directDraw
::
Window
->
Graphic
->
IO
()
>
>
selectFont
::
Font
->
Draw
Font
>
setTextColor
::
RGB
->
Draw
RGB
>
setTextAlignment
::
Alignment
->
Draw
Alignment
>
setBkColor
::
RGB
->
Draw
RGB
>
setBkMode
::
BkMode
->
Draw
BkMode
>
selectPen
::
Pen
->
Draw
Pen
18

>
selectBrush
::
Brush
->
Draw
Brush
>
>
bracket
::
Draw
a
->
(a
->
Draw
b)
->
(a
->
Draw
c)
->
Draw
c
>
bracket_
::
Draw
a
->
(a
->
Draw
b)
->
Draw
c
->
Draw
c
>
>
data
Font
>
createFont
::
Point
->
Angle
->
Bool
->
Bool
->
String
->
IO
Font
>
deleteFont
::
Font
->
IO
()
>
>
data
Brush
>
mkBrush
::
RGB
->
(Brush
->
Draw
a)
->
Draw
a
>
>
data
Pen
>
mkPen
::
Style
->
Int
->
RGB
->
(Pen
->
Draw
a)
->
Draw
a
>
createPen
::
Style
->
Int
->
RGB
->
IO
Pen
>
>
arc
::
Point
->
Point
->
Angle
->
Angle
->
Graphic
--
unfilled
>
line
::
Point
->
Point
->
Graphic
--
unfilled
>
polyline
::
[Point]
->
Graphic
--
unfilled
>
ellipse
::
Point
->
Point
->
Graphic
--
filled
>
shearEllipse
::
Point
->
Point
->
Point
->
Graphic
--
filled
>
polygon
::
[Point]
->
Graphic
--
filled
>
text
::
Point
->
String
->
Graphic
--
filled
>
>
data
Region
>
emptyRegion
::
Region
>
rectangleRegion
::
Point
->
Point
->
Region
>
ellipseRegion
::
Point
->
Point
->
Region
>
polygonRegion
::
[Point]
->
Region
>
intersectRegion
::
Region
->
Region
->
Region
>
unionRegion
::
Region
->
Region
->
Region
>
subtractRegion
::
Region
->
Region
->
Region
>
xorRegion
::
Region
->
Region
->
Region
>
regionToGraphic
::
Region
->
Graphic
>
>
data
Event
>
=
Key
{
char
::
Char,
isDown
::
Bool
}
>
|
Button
{
pt
::
Point,
isLeft,
isDown
::
Bool
}
>
|
MouseMove
{
pt
::
Point
}
>
|
Resize
>
|
Closed
>
deriving
Show
A.2
Mo
dule
GraphicsUtils
Note
that
this
do
cumen
t
rep
eats
the
denitions
of
all
the
functions
dened
in
GraphicsUtils.
>
--
Reexports
GraphicsCore
>
>
openWindow
::
Title
->
Size
->
IO
Window
>
clearWindow
::
Window
->
IO
()
19

>
drawInWindow
::
Window
->
Graphic
->
IO
()
>
>
getWindowSize
::
Window
->
IO
Size
>
getLBP
::
Window
->
IO
Point
>
getRBP
::
Window
->
IO
Point
>
getButton
::
Window
->
Bool
->
Bool
->
IO
Point
>
getKey
::
Window
->
IO
Char
>
getKeyEx
::
Window
->
Bool
->
IO
Char
>
>
emptyGraphic
::
Graphic
>
overGraphic
::
Graphic
->
Graphic
->
Graphic
>
overGraphics
::
[Graphic]
->
Graphic
>
>
withFont
::
Font
->
Graphic
->
Graphic
>
withTextColor
::
RGB
->
Graphic
->
Graphic
>
withTextAlignment
::
Alignment
->
Graphic
->
Graphic
>
withBkColor
::
RGB
->
Graphic
->
Graphic
>
withBkMode
::
BkMode
->
Graphic
->
Graphic
>
withPen
::
Pen
->
Graphic
->
Graphic
>
withBrush
::
Brush
->
Graphic
->
Graphic
>
withRGB
::
RGB
->
Graphic
->
Graphic
>
>
data
Color
>
=
Black
>
|
Blue
>
|
Green
>
|
Cyan
>
|
Red
>
|
Magenta
>
|
Yellow
>
|
White
>
deriving
(Eq,
Ord,
Bounded,
Enum,
Ix,
Show,
Read)
>
>
colorList
::
[(Color,
RGB)]
>
colorTable
::
Array
Color
RGB
>
withColor
::
Color
->
Graphic
->
Graphic
>
>
par
::
IO
a
->
IO
b
->
IO
(a,b)
>
par_
::
IO
a
->
IO
b
->
IO
()
>
parMany
::
[IO
()]
->
IO
()
A.3
P
ortabilit
y
notes

polyBezier
is
not
pro
vided
in
the
X11
implemen
tation
of
this
library
.

shearEllipse
is
implemen
ted
b
y
p
olygons
on
b
oth
Win32
and
X11.

X11
do
es
not
directly
supp
ort
fon
t
rotation
so
mkFont
alw
a
ys
ignores
the
rotation
angle
argumen
t
in
the
X11
implemen
tation
of
this
library
.

Man
y
of
the
fon
t
families
t
ypically
a
v
ailable
on
Win32
are
not
a
v
ailable
on
X11
(and
vic
e-versa
).
In
our
exp
erience,
the
fon
t
families
\courier,"
\helv
etica"
and
\times"
are
somewhat
p
ortable.
20


On
Win32,
the
p
en
is
also
used
to
dra
w
a
line
round
all
the
lled
shap
es
|
so
the
p
en
color
also
aects
ho
w
p
olygons,
ellipses
and
regions
are
dra
wn.

One
of
the
Win32
\gotc
has"
is
that
the
c
hoice
of
Style
only
applies
if
the
width
is
1
or
less.
With
greater
widths,
the
p
en
st
yle
will
alw
a
ys
b
e
Solid
no
matter
what
y
ou
try
to
select.
This
problem
do
es
not
apply
to
X11.

The
Bitmap
functions
are
not
curren
tly
pro
vided
in
the
X11
implemen
tation
of
this
library
.

shearBitmap
is
supp
orted
on
Win'NT
but
not
Win'95.

emptyRegion
is
not
pro
vided
in
the
Win32
implemen
tation
of
this
library
.
It
is
p
ossible
to
use
an
empt
y
rectangle
region
instead

ellipseRegion
is
implemen
ted
using
p
olygons
in
the
X11
implemen
tation
of
the
library
.

Programmers
should
assume
that
the
Event
datat
yp
e
will
b
e
extended
in
the
not-to
o-distan
t
future
and
that
individual
ev
en
ts
ma
y
c
hange
sligh
tly
.
As
a
minim
um,
y
ou
should
add
a
\matc
h
an
ything"
alternativ
e
to
an
y
function
whic
h
pattern
matc
hes
against
Events.

X11
systems
t
ypically
ha
v
e
three
button
mice.
Button
1
is
used
as
the
left
button,
button
3
as
the
righ
t
button
and
button
2
(the
middle
button)
is
ignored.
21

