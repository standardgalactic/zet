Mallo
c
P
oin
ters
and
Stable
P
oin
ters:
Impro
ving
Hask
ell's
F
oreign
Language
In
terface
Alastair
Reid

Computing
Science
Departmen
t,
Univ
ersit
y
of
Glasgo
w
Glasgo
w
G
QQ,
Scotland
Septem
b
er
,
		
Abstract
The
Glasgo
w
Hask
ell
compiler
pro
vides
a
foreign
language
in
terface
whic
h
allo
ws
Hask
ell
programs
to
call
arbitrary
C
functions.
This
has
b
een
used
b
oth
to
implemen
t
the
standard
Hask
ell
IO
system
and
a
v
ariet
y
of
applications
including
an
arcade
game
[
],
and
a
graphical
user
in
terface
to
a
database
[	
].
The
theoretical
problems
asso
ciated
with
using
impure
functions
from
pure
functional
languages
are
a
v
oided
through
the
use
of
monads
[
];
and
the
mismatc
h
b
et
w
een
strict
languages
with
no
garbage
collection
and
lazy
languages
with
garbage
collection
is
tac
kled
b
y
un
b
o
xing
(that
is,
forcing
ev
aluation
of
argumen
ts
and
stripping
o
an
y
header
information)
[
].
Whilst
this
w
orks
w
ell
for
simple
examples,
it
is
unsuitable
when
one
w
an
ts
to
pass
argumen
ts
(or
results)
whic
h
are
lazy
,
p
olymorphic
or
v
ery
large.
W
e
describ
e
t
w
o
extensions
to
the
garbage
collector
whic
h
solv
e
these
problems
b
y
allo
wing
b
etter
in
teraction
b
et
w
een
the
Hask
ell
garbage
collector
and
memory
allo
cation
in
the
imp
erativ
e
w
orld.

In
tro
duction
The
LISP
and
Standard
ML
comm
unities
ha
v
e
kno
wn
for
some
time
that
im-
pure
functional
languages
are
useful
for
more
than
just
sym
b
olic
manipulation
and
to
y
programs
|
functional
programs
can
also
pro
vide
sophisticated
user
in
terfaces
[	
,

]
and
can
b
e
used
for
systems
programming
tasks
suc
h
as
imple-
men
ting
comm
unications
proto
cols
[0
].
The
(lazy)
pure
functional
w
orld
is
b
eginning
to
demonstrate
that
pure
functional
languages
are
also
go
o
d
for
writing
programs
traditionally
considered
to
b
e
outside
their
domain.
A
go
o
d
example
is
Carlson
and
Hallgren's
F
udget
system
[]
|
an
ecien
t
library
of
\functional
widgets"
whic
h
can
b
e
used
to
implemen
t
graphical
user
in
terfaces.

email:
areid@uk.ac.glasgow.dcs
;
h
ttp:
//www.dcs.gla.ac.uk/~are
id


It
is
therefore
te
chnic
al
ly
p
ossible
to
discard
most
(or
all?)
existing
imp
er-
ativ
e
libraries
and
reimplemen
t
them
all
in
a
(pure)
functional
language
but
there
are
comp
elling
reasons
wh
y
w
e
cannot
or
should
not
do
so:
Dev
elopmen
t
Eort
In
addition
to
the
libraries
that
come
supplied
with
op
erating
systems
and
compilers,
there
are
sev
eral
substan
tial
libraries
of
freely-a
v
ailable
soft
w
are
suc
h
as
the
X
widget
system,
and
the
F
ree
Soft
w
are
F
oundation's
libraries.
If
eac
h
suc
h
library
m
ust
b
e
reimplemen
ted
in
a
functional
language
b
efore
it
can
b
e
used,
functional
programs
will
require
considerably
more
eort
to
pro
duce
than
imp
erativ
e
programs.
P
erformance
Despite
signican
t
impro
v
emen
ts
in
compiler
tec
hnology
,
highly
tuned
imp
erativ
e
programs
remain
signican
tly
more
ecien
t
in
time
and
(esp
ecially)
space
than
equiv
alen
t
lazy
functional
programs.
There
are
t
w
o
ma
jor
problems
in
calling
imp
erativ
e
library
routines
from
a
pure,
lazy
functional
language:
Con
trol
o
w
In
a
pure
functional
language,
the
order
of
ev
aluation
can
only
aect
termination
and
resource
usage
|
this
lea
v
es
the
optimisation
phases
of
the
compiler
and
the
run
time
system
considerable
freedom
to
c
ho
ose
an
ev
aluation
order.
If
\impurities"
(i.e.
side
eects)
are
in
tro-
duced,
steps
m
ust
b
e
tak
en
to
constrain
the
c
hoice
of
ev
aluation
order.
P
assing
Data
The
older
(and
most
p
opular)
imp
erativ
e
languages
(suc
h
as
C
and
Pascal
)
either
allo
cate
ob
jects
at
a
xed
address,
on
the
stac
k
or
on
the
heap
according
to
their
lifetime.
All
heap
allo
cated
ob
jects
m
ust
b
e
explicitly
deallo
cated.
In
functional
languages
most
ob
jects
are
heap
allo
cated
and
automati-
cally
deallo
cated
through
garbage
collection.
(A
lifetime
analysis
is
also
p
ossible
|
allo
wing
the
compiler
to
decides
where
to
allo
cate
an
ob
ject
or
to
p
erform
\compile-time"
garbage
collection.)
Issues
of
con
trol
o
w
can
b
e
dealt
with
b
y
writing
programs
in
con
tin
uation
passing
st
yle
or
monadic
st
yle
[
];
therefore
this
pap
er
is
primarily
concerned
with
issues
asso
ciated
with
passing
data
to
and
from
an
imp
erativ
e
language.
Section

describ
es
the
Glasgo
w
Hask
ell
Compiler's
foreign
language
in
ter-
face.
Section

describ
es
problems
in
passing
argumen
ts
that
are:
p
olymor-
phic;
lazy;
large;
p
ersisten
t
from
one
call
to
another;
or
functions.
W
e
prop
ose
t
w
o
new
t
yp
es
and
asso
ciated
op
erations
to
o
v
ercome
these
problems.
These
extensions
are
included
in
the
latest
release
of
the
Glasgo
w
compiler
|
the
implemen
tation
is
outlined
in
section
.

The
Ra
w
Iron
This
section
outlines
some
of
the
primitiv
e
facilities
for
calling
imp
erativ
e
func-
tions
pro
vided
b
y
ghc
:
the
\ra
w
iron"
from
whic
h
higher
lev
el
facilities
are
built.
F
urther
facilities
are
describ
ed
in
section

when
w
e
discuss
the
extensions
w
e
made
to
the
compiler.)

.
C
calls
and
the
PrimIO
monad
F
or
our
purp
oses,
the
most
imp
ortan
t
of
ghc
's
primitiv
e
op
erations
is
_ccall_
whic
h
is
used
to
call
an
arbitrary
C
function
from
within
Hask
ell.
T
o
call
the
standard
C
trigonometric
function
sin
,
one
writes
_ccall_
sin
(.::Double)
and
to
call
the
standard
C
output
function
printf
,
one
writes
_ccall_
printf
"The
answer
is
%d.\n"
(::Int)
Note
that
the
compiler
m
ust
b
e
able
to
determine
the
t
yp
e
of
the
argumen
ts
(and
results)
of
a
_ccall_
|
hence
the
explicit
t
yp
e
signatures
on
argumen
ts
that
w
ould
otherwise
b
e
am
biguous.
Note
to
o
that
_ccall_
do
es
not
distinguish
b
et
w
een
pure
functions
(suc
h
as
sin
)
and
impure
functions
(suc
h
as
printf
)
|
b
oth
are
assumed
to
ha
v
e
side-eects.
The
theoretical
and
practical
problems
arising
from
calling
impure
functions
from
a
pure
functional
language
are
a
v
oided
b
y
using
a
monad
to
force
strict
sequencing
of
_ccall_
s.
W
e
refer
the
reader
to
[
,

,

]
for
a
detailed
discussion
of
the
monadic
approac
h
but
note
that
the
t
yp
e
PrimIO
and
functions
thenPrimIO
,
returnPrimIO
and
unsafePerformPr
im
IO
w
ere
called
IO
,
thenIO
,
returnIO
and
performIO
resp
ectiv
ely
in
[
].
If
a
programmer
b
eliev
es
that
a
computation
of
t
yp
e
PrimIO

is
referen-
tially
transparen
t
and
do
es
not
ha
v
e
an
y
side-eects,
unsafePerformPri
mIO
::
PrimIO

!

can
b
e
used
to
eliminate
the
need
to
include
it
the
main
thread
of
execution.

F
or
example,
the
follo
wing
program
assumes
the
existence
of
t
w
o
imp
erativ
e
functions
readInt
and
writeInt
to
read
t
w
o
n
um
b
ers
and
write
their
sum.
mainPrimIO
=
_ccall_
readInt
`thenPrimIO`
\
x
->
_ccall_
readInt
`thenPrimIO`
\
y
->
_ccall_
writeInt
((x+y)
::
Int)
`thenPrimIO`
\
()
->
returnPrimIO
()
(Hask
ell
Notation:
If
f
is
a
binary
function,
the
function
`f`
is
a
binary
inx
op
erator.
The
notation
\x
->
e
represen
ts
the
lam
b
da
term
x:e;
the
scop
e
of
x
extends
as
far
to
the
righ
t
as
p
ossible.)
.
CCallable
and
CReturnable
data
t
yp
es
The
represen
tation
of
v
alues
used
in
a
language
implemen
tation
dep
ends
on
whether
automatic
garbage
collection
is
pro
vided
or
not:
languages
with
garbage
collection
t
ypically
add
a
header
to
the
fron
t
of
ev
ery
ob
ject
for
use
during
garbage
collection.
This
header
m
ust
b
e
remo
v
ed
from
argumen
ts
to
a
_ccall_
and
added
to
the
fron
t
of
results.
In
addition,
v
alues
in
lazy
languages
ma
y
b
e
represen
ted
b
y
a
\th
unk"
represen
ting
the
calculation
required
to
calculate

The
w
ord
\unsafe"
is
in
tended
to
remind
the
programmer
that
the
compiler
has
no
w
a
y
of
c
hec
king
whether
or
not
the
op
eration
has
side-eects.
Apart
from
the
ob
vious
debugging
uses,
w
e
ha
v
e
y
et
to
see
a
program
that
safely
uses
this
function
to
call
a
side-eecting
function.

that
v
alue.
In
most
cases,
imp
erativ
e
functions
m
ust
b
e
passed
the
v
alue
of
a
\th
unk"
rather
than
the
\th
unk"
itself.
The
necessary
con
v
ersions
could
b
e
made
explicit
through
the
use
of
\un-
b
o
xed
t
yp
es"
[
]
but
ghc
automatically
p
erforms
these
con
v
ersions
on
the
follo
wing
basic
data
t
yp
es:
Char
,
Int
,
Float
and
Double
.
These
t
yp
es
can
b
e
b
oth
passed
as
argumen
ts
in
_ccall_
s
and
returned
as
results
from
_ccall_
s
|
w
e
call
suc
h
t
yp
es
CCallable
and
CReturnable
resp
ectiv
ely
.
(There
is
a
mec
hanism
for
expanding
the
set
of
CCallable
and
CReturnable
t
yp
es
whic
h
w
e
shall
not
elab
orate
here.)
.
Nonstandard
T
yp
es
In
addition
to
these
standard
Hask
ell
t
yp
es,
ghc
pro
vides
the
non-standard
t
yp
es
_Word
(an
unsigned
in
teger),
_Addr
(a
mac
hine
address),
_ByteArray
(a
con
tiguous
region
of
b
ytes
in
the
Hask
ell
heap
whic
h
ma
y
b
e
read
but
not
mo
di-
ed)
and
_MutableByteArr
ay
(a
con
tiguous
region
of
b
ytes
in
the
Hask
ell
heap
whic
h
ma
y
b
e
b
oth
read
and
written).
ghc
pro
vides
a
small
set
of
op
erations
on
these
t
yp
es
including
equalit
y
tests,
bit
manipulations
and
arra
y
allo
cation
and
indexing
op
erations.
_MutableByteArr
ay
s
can
b
e
used
to
return
m
ultiple
argumen
ts
from
a
C
function.
F
or
example
one
could
write
the
follo
wing
to
call
the
standard
C
function
sincos
whic
h
tak
es
a
double-precision
angle
and
the
address
of
t
w
o
double-precision
v
ariables
and
writes
the
sine
and
cosine
of
the
angle
in
to
the
t
w
o
v
ariables.
sincos
::
Double
->
PrimIO
(Double,
Double)
sincos
a
=
unsafePerformPrim
IO
(
newDouble
`thenPrimIO`
\
sv
->
newDouble
`thenPrimIO`
\
cv
->
_ccall_
sincos_wrapper
a
sv
cv
`thenPrimIO`
\
()
->
readDouble
sv
`thenPrimIO`
\
sin
->
readDouble
cv
`thenPrimIO`
\
cos
->
returnPrimIO
(sin,
cos)
)
The
non-standard
functions
newDouble
and
readDouble
are
dened
us-
ing
primitiv
e
op
erations
on
_MutableByteArr
ay
s.
They
are
used
to
allo
cate
enough
memory
to
hold
a
Double
and
to
extract
a
Double
from
an
arra
y
.
The
wrapp
er
function
sincos_wrapper
p
erforms
t
yp
e
co
ercions
and,
most
imp
or-
tan
tly
,
o
v
ercomes
an
y
restrictions
on
alignmen
t
of
double
imp
osed
b
y
mo
dern
RISC
arc
hitectures
through
the
use
of
some
mac
hine-sp
ecic
macros
for
assign-
ing
unaligned
double
s.
void
sincos_wrapper(S
tgD
ou
ble
a,
StgByteArray
*sin,
StgByteArray
*cos)
{
double
s,
c;
sincos(a,
&s,
&c);
ASSIGN_DBL(
(StgDouble
*)
sin,
s);
ASSIGN_DBL(
(StgDouble
*)
cos,
c);
}

The
need
to
write
a
small
wrapp
er
function
for
ev
ery
imp
erativ
e
function
called
is
rather
tedious
and
error-prone.
A
far
more
reliable
approac
h
w
ould
b
e
to
write
a
wrapp
er-generator
whic
h
automatically
constructed
the
Haskell
and
C
wrapp
er
functions
from
a
list
of
t
yp
e
signatures.

Problems
with
the
ra
w
iron
Man
y
v
alues
found
in
Hask
ell
programs
are
unev
aluated
heap-allo
cated
ob
jects
of
arbitrary
size
suc
h
as
Lists
and
arbitrary
precision
In
tegers.
Most
v
alues
in
imp
erativ
e
programs
are
fully
ev
aluated
stac
k-allo
cated
ob
jects
of
a
xed
(small)
size
suc
h
as
-bit
in
tegers.
This
mismatc
h
b
et
w
een
Hask
ell
and
the
languages
it
is
calling
can
usually
b
e
solv
ed
b
y
fully
ev
aluating
the
v
alue
and
passing
it
to
the
imp
erativ
e
function
using
the
standard
argumen
t
passing
con-
v
en
tion
for
that
arc
hitecture.
This
standard
approac
h
is
restricted
in
a
n
um
b
er
of
w
a
ys:
Laziness:
Since
all
argumen
ts
are
ev
aluated
b
efore
calling
the
C
function,
one
cannot
write
lazy
functions.
Giv
en
that
C
is
a
strict
language,
this
seems
p
erfectly
reasonable.
Ho
w
ev
er,
O'Donnell
[
]
describ
es
a
hardw
are
im-
plemen
tation
of
arra
ys
whic
h
pro
vides
extensible,
sparse
functional
arra
ys
(called
\ESF
arra
ys").
By
exploiting
the
parallelism
inheren
t
in
hardw
are,
O'Donnell
is
able
to
p
erform
b
oth
up
date
and
lo
okup
in
constan
t
time.
When
using
suc
h
a
device
from
a
lazy
language,
one
w
ould
ob
viously
re-
quire
these
arra
ys
to
con
tain
(p
oin
ters
to)
unev
aluated
v
alues
rather
than
just
in
tegers.
P
olymorphism:
Since
Haskell
's
ev
aluation
mec
hanism
and
C's
argumen
t
passing
mec
hanisms
v
ary
from
one
t
yp
e
to
another,
one
cannot
write
functions
exhibiting
pure
p
olymorphism.
Again,
since
C
do
es
not
pro
vide
pure
p
olymorphism,
this
seems
p
erfectly
reasonable.
Ho
w
ev
er,
problems
w
ould
arise
if
one
wished
to
use
O'Donnell's
ESF
arra
ys
to
implemen
t
arra
ys
of
c
haracters,
oating
p
oin
t
n
um
b
ers
or
ev
en
arra
ys.
Large
p
ersisten
t
data
structures:
Since
C's
argumen
t
passing
con
v
en
tion
restricts
one
to
passing
\small"
v
alues
(ie
v
alues
that
will
t
in
registers)
one
cannot
directly
pass
(or
return)
large
ob
jects
but
m
ust
pass
their
address
instead.
If
the
ob
ject
b
eing
passed
has
a
short
w
ell-dened
lifetime,
it
is
reasonable
to
use
tric
ks
suc
h
as
that
used
in
section
.
where
w
e
explicitly
allo
cated
space
on
the
heap,
call
the
function
sincos
and
read
the
v
alues
out.
Similarily
,
if
returning
an
arra
y
of
c
haracters
(sa
y)
from
C
to
Haskell
,
one
migh
t
explicitly
allo
cate
an
arra
y
on
the
C
heap,
cop
y
the
result
in
to
the
arra
y
,
return
the
address
of
the
result
to
Haskell
,
read
the
c
haracters
from
the
arra
y
in
to
a
list
and
call
the
C
function
free
to
explicitly
deallo
cate
the
arra
y
.
As
w
ell
as
b
eing
somewhat
inecien
t,
suc
h
solutions
can
cause
garbage
collection
problems
if
an
ob
ject
\p
ersists"
from
one
function
call
to
the
next:


Man
y
mo
dern
garbage
collectors
mo
v
e
ob
jects
during
garbage
col-
lection.
This
do
esn't
normally
cause
a
problem
b
ecause
all
p
oin
ters
to
an
ob
ject
are
up
dated
when
the
ob
ject
is
mo
v
ed.
If
the
garbage
collector
is
una
w
are
that
the
imp
erativ
e
w
orld
has
a
p
oin
ter
to
a
Hask
ell
heap
ob
ject,
the
p
oin
ter
cannot
b
e
up
dated
and
errors
can
arise.

Garbage
collection
reclaims
storage
used
b
y
ob
jects
that
are
no
longer
referenced.
If
the
garbage
collector
is
una
w
are
that
the
im-
p
erativ
e
w
orld
has
a
reference
to
a
Hask
ell
heap
ob
ject,
it
migh
t
b
e
deallo
cated
when
references
still
exist.

Since
most
C
implemen
tations
do
not
ha
v
e
automatic
garbage
col-
lection
(see,
for
example,
[]
for
an
exception),
it
is
necessary
to
explicitly
deallo
cate
heap-allo
cated
ob
jects
as
the
last
reference
to
the
ob
ject
is
deleted.
This
is
hard
to
do
correctly
in
an
imp
erativ
e
language;
it
is
virtually
imp
ossible
in
a
lazy
functional
language.
Hask
ell
functions
In
C
a
function
ma
y
b
e
represen
ted
b
y
a
p
oin
ter
to
the
corresp
onding
mac
hine
co
de
for
that
function.
Suc
h
p
oin
ters
ma
y
b
e
passed
to
and
returned
from
other
functions.
In
Haskell
,
it
is
not
enough
to
pass
a
p
oin
ter
to
the
mac
hine
co
de,
one
m
ust
also
pass
an
y
v
alues
b
ound
to
free
v
ariables
o
ccuring
in
the
function.
Since
the
n
um
b
er
of
free
v
ariables
ma
y
b
e
c
hanged
b
y
ev
aluation
and
b
y
optimisations
(b
oth
at
compile
time
and
during
garbage
collection),
there
is
no
easy
w
a
y
to
con
v
ert
Haskell
functions
to
their
corresp
onding
represen
tation
in
C
.
W
e
ha
v
e
come
across
sev
eral
examples
where
it
w
ould
b
e
useful
to
b
e
able
to
pass
Haskell
functions
to
C:

When
writing
graphical
user
in
terfaces
under
X,
w
e
m
ust
pro
vide
the
\widgets"
with
actions
(\callbac
ks")
to
p
erform
when
the
user
clic
ks
a
mouse
on
a
widget
or
closes
a
windo
w.
If
one
wishes
to
write
graphical
user
in
terfaces
in
Hask
ell,
the
natural
w
a
y
of
dening
whic
h
callbac
k
to
call
in
resp
onse
to
a
giv
en
ev
en
t
is
to
store
the
address
of
the
(p
ossibly
heap-allo
cated)
callbac
k
routine
in
the
Widget
|
almost
exactly
as
one
do
es
for
C.
(Our
earlier
pap
er
[	
]
describ
es
a
rather
ad
ho
c
approac
h
whic
h
a
v
oids
the
need
to
extend
the
garbage
collector.)

The
Hask
ell
.
IO
prop
osal
denes
a
function
setInterrupt
::
IO
()
->
IO
(IO
())
whic
h
allo
ws
a
monadic
program
to
sp
ecify
an
\in
terrupt
handler"
to
b
e
executed
when
a
console
in
terrupt
o
ccurs.
An
ecien
t
implemen
tation
requires
the
run
time
system
to
store
the
curren
t
\in
terrupt
handler"
in
a
global
C
v
ariable.
(Since
this
is
part
of
the
run
time
system,
it
w
ould
b
e
p
ossible
to
build
it
in
to
the
garbage
collector
as
a
sp
ecial
case.)
Our
solution
to
the
ab
o
v
e
problems
is
to
add
t
w
o
new
primitiv
e
t
yp
es
to
the
language:
_MallocPtr
s
are
p
oin
ters
from
the
Haskell
heap
to
ob
jects
in
the
C
heap;
and
_StablePtr
s
are
p
oin
ters
from
the
C
heap
to
ob
jects
in
the

Haskell
heap.
W
e
mo
dify
the
garbage
collector
to
tak
e
these
ob
jects
in
to
accoun
t
during
garbage
collection.
.
Mallo
c
P
oin
ters
In
principle
an
ob
ject
of
t
yp
e
_MallocPtr
is
just
an
index
in
to
a
table
of
addresses
of
ob
jects
in
the
C
heap.
(The
name
deriv
es
from
the
w
a
y
most
ob
jects
in
the
C
heap
are
allo
cated:
b
y
calling
the
standard
library
function
malloc
.
Ho
w
ev
er,
w
e
exp
ect
_MallocPtr
s
to
b
e
v
alues
suc
h
as
le
handles,
ESF
arra
y
iden
tiers,
etc.)
A
_MallocPtr
is
automatically
allo
cated
on
return
from
a
_ccall_
with
re-
sult
t
yp
e
_MallocPtr
and
is
automatically
dereferenced
when
passed
as
an
ar-
gumen
t
to
_ccall_
.
When
the
ghc
run
time
system
detects
that
a
_MallocPtr
is
no
longer
accessible,
the
_MallocPtr
is
deallo
cated
and
a
programmer-
supplied
C
function
void
FreeMallocPtr(
StgMallocPtr
mp
)
is
called.
Since
ghc
will
only
detect
that
a
_MallocPtr
is
inaccessible
during
garbage
collection,
C
programs
ma
y
call
the
C
function
StgPerformGarba
geC
ol
le
cti
on
to
force
a
garbage
collection.

.
Stable
P
oin
ters
In
principle
(and
in
practice),
an
ob
ject
of
t
yp
e
_StablePtr

is
an
index
in
to
a
table
of
addresses
of
ob
jects
of
t
yp
e

in
the
Hask
ell
heap.
When
the
Hask
ell
garbage
collector
mo
v
es
an
ob
ject
to
whic
h
there
is
a
_StablePtr
,
the
corresp
onding
en
try
in
the
table
is
up
dated;
an
ob
ject
will
not
b
e
deallo
cated
if
a
stable
p
oin
ter
to
it
exists.
Stable
p
oin
ters
ma
y
b
e
passed
to
and
returned
from
_ccall_
s.
The
follo
w-
ing
op
erations
ma
y
b
e
used
from
Hask
ell
to
explicitly
allo
cate,
deallo
cate
and
dereference
_StablePtr
s.
makeStablePointe
r
::
a
->
PrimIO
(_StablePtr
a)
freeStablePointe
r
::
_StablePtr
a
->
PrimIO
()
derefStablePoint
er
::
_StablePtr
a
->
a
Note
that,
b
ecause
of
the
use
of
explicit
allo
cation
and
deallo
cation,
space
leaks
can
result
if
stable
p
oin
ters
are
not
released
when
nished
with.
It
is
for
this
reason
that
makeStablePointe
r
is
not
of
t
yp
e

!
_StablePtr
:
use
of
the
PrimIO
monad
a
v
oids
an
y
risk
of
a
single
use
b
eing
\optimised"
in
to
sev
eral
uses.
There
is
also
a
C
pro
cedure
void
FreeStablePtr(
StgStablePtr
sp
)

If
a
_ccall_
is
lik
ely
to
p
erform
a
garbage
collection,
it
is
necessary
to
tak
e
considerable
care
that
no
registers
con
tain
liv
e
heap
p
oin
ters
and
to
mak
e
the
con
ten
ts
of
essen
tial
registers
suc
h
as
the
heap
p
oin
ter
a
v
ailable.
Rather
than
pa
y
this
extra
cost
on
ev
ery
_ccall_
,
w
e
pro
vide
a
sp
ecial
form
_ccall_GC_
whic
h
should
b
e
used
if
StgPerformGarbageCollect
ion
can
b
e
called
b
y
the
C
function
b
eing
called.
It
is
a
c
hec
k
ed
run
time
error
to
call
StgPerformGarbageCollec
tion
during
a
plain
_ccall_
.

whic
h
frees
a
stable
p
oin
ter.
(This
is
the
only
ghc
-pro
vided
op
eration
whic
h
ma
y
b
e
called
within
FreeMallocPtr
.)
T
o
supp
ort
the
callbac
k
mec
hanism,
there
are
also
C
functions
void
enterPrimIO
(
StgStablePtr
sp
)
int
enterInt
(
StgStablePtr
sp
)
...
whic
h
calls
stable
p
oin
ter
of
t
yp
e
StablePtr
(PrimIO
())
,
StablePtr
Int
,
etc.
Sadly
,
there
is
little
p
ossibilit
y
of
adequately
t
yp
ec
hec
king
these
calls.
.
Applications
Of
the
t
w
o
mec
hanisms,
w
e
ha
v
e
found
_MallocPtr
s
to
b
e
the
most
useful.
In
addition
to
the
uses
men
tioned
ab
o
v
e,
some
p
ossible
applications
include:

Hask
ell
pro
vides
an
op
eration
to
lazily
read
a
le.
The
result
of
this
function
is
a
string
consisting
of
the
con
ten
ts
of
the
le
but,
b
ecause
the
read
is
p
erformed
lazily
(ie
as
eac
h
c
haracter
in
the
le
is
demanded),
it
is
still
p
ossible
to
pro
cess
a
le
in
constan
t
space.
One
problem
is
in
automatically
closing
these
les.
If
the
end
of
the
le
is
reac
hed,
the
le
ma
y
b
e
simply
closed;
but
if
the
le
is
discarded
b
efore
the
end
of
the
le
is
reac
hed,
the
le
will
remain
op
en.
As
w
ell
as
prev
en
ting
other
programs
from
writing
to
the
le,
this
migh
t
result
in
the
program
running
out
of
le
handles
(on
a
UNIX
system,
eac
h
pro
cess
is
only
allo
w
ed
to
op
en
a
certain
n
um
b
er
of
les).

In
the
X
windo
w
system,
eac
h
displa
y
runs
a
serv
er
whic
h
can
dra
w
lines,
text,
etc.
on
the
screen.
Programs
wishing
to
p
erform
graphics
on
a
giv
en
displa
y
connect
to
the
appropriate
serv
er
and
send
a
stream
of
requests
to
dra
w
images.
T
o
reduce
the
amoun
t
of
net
w
ork
comm
unication,
bitmaps,
fon
ts,
colours,
etc
are
stored
in
the
serv
er's
memory
.
Allo
cation
and
deal-
lo
cation
of
these
resources
is
p
erformed
explicitly
.
(One
migh
t
think
that
resources
could
b
e
deallo
cated
when
a
connection
is
brok
en.
The
X
proto-
col
allo
ws
resources
to
b
e
shared
b
et
w
een
pro
cesses
but
do
es
not
require
clien
ts
to
inform
it
of
suc
h
sharing
|
this
prev
en
ts
suc
h
deallo
cation
from
o
ccuring.)
A
common
problem
with
imp
er
ative
pr
o
gr
ams
is
that
they
fail
to
deal-
lo
cate
some
of
the
resources
allo
cated
to
them.
This
leads
to
a
grad-
ual
degradation
of
p
erformance
and
functionalit
y
as
the
resources
of
the
serv
er
gradually
disapp
ear
and,
to
alleviate
this
problem,
most
serv
ers
are
initially
allo
cated
far
more
memory
than
they
require.
It
should
b
e
p
ossible
to
a
v
oid
this
problem
b
y
using
_MallocPtr
to
repre-
sen
t
all
serv
er
ob
jects.
If
an
y
allo
cation
request
fails,
the
clien
t
should
call
StgPerformGarba
geC
ol
le
cti
on
in
the
hop
e
of
freeing
some
unreac
hable
_MallocPtr
s.
One
p
oten
tial
problem
with
this
sc
heme
is
that
it
is
p
ossible
for
one
qui-
escen
t
program
(a
mail-reader,
sa
y)
to
hog
all
the
resources
if
it
do
es
not
p
erform
a
garbage
collection
v
ery
often.
This
could
p
erhaps
b
e
o
v
ercome
b
y
mo
difying
the
serv
er
to
inform
al
l
clien
ts
when
it
w
as
lo
w
on
resources.

A
program
receiving
this
notication
could
p
erform
a
garbage
collection
in
the
hop
e
of
freeing
some
_MallocPtr
s.

Implemen
tation
This
section
describ
es
ho
w
stable
p
oin
ters
and
mallo
c
p
oin
ters
are
implemen
ted.
.
Mallo
c
P
oin
ters
Programmers
are
encouraged
to
think
of
_MallocPtr
s
as
indexes
in
a
table
of
p
oin
ters
in
to
the
C
Heap.
Ho
w
ev
er,
since
the
only
op
eration
on
these
\indexes"
is
to
dereference
them
and
to
scan
through
them
all,
it
is
p
ossible
to
implemen
t
the
\table"
as
a
link
ed
list
without
an
y
loss
of
eciency
.
(This
a
v
oids
the
need
to
implemen
t
complex
op
erations
to
resize
the
table.)
(There
is
one
sligh
tly
subtle
asp
ect
to
this
c
hoice
of
represen
tation:
during
garbage
collection,
an
ob
ject
is
normally
considered
to
b
e
\liv
e"
if
it
is
a
\ro
ot"
or
it
is
p
oin
ted
to
b
y
an
y
other
\liv
e"
ob
ject;
it
is
imp
ortan
t
not
to
treat
the
link
to
the
next
_MallocPtr
in
the
list
as
an
ordinary
p
oin
ter
or
_MallocPtr
s
will
only
die
when
all
_MallocPtr
s
further
up
the
list
die.
This
migh
t
badly
aect
a
conserv
ativ
e
garbage
collector
op
erating
without
kno
wledge
of
the
in
ternal
structure
of
heap
ob
jects.)
.
Stable
P
oin
ters
A
_StablePtr
is
represen
ted
as
an
index
in
to
a
table.
The
table
is
allo
cated
on
the
heap
and
ma
y
b
e
resized
to
suit
demand.
Ev
ery
time
the
table
o
v
ero
ws,
it
is
doubled
in
size
resulting
in
an
amortised
constan
t-time
op
eration.
W
e
main-
tain
a
\stac
k"
of
un
used
en
tries
in
the
table.
(This
stac
k
could
b
e
eliminated
b
y
threading
a
free
list
through
the
table
of
\unstable"
p
oin
ters.
This
w
ould
require
a
w
a
y
of
distinguishing
\unstable
p
oin
ters"
from
links
in
the
list.)
Ignoring
standard
header
information
(used
b
y
the
garbage
collector)
a
sta-
ble
p
oin
ter
table
closure
lo
oks
lik
e
this:
N
P
tr
s
S
P
0
S
P

:
:
:
S
P
n 
T
op
s
0
s

:
:
:
s
n 
The
elds
are:
N
P
tr
s
The
n
um
b
er
of
(stable)
p
oin
ters.
S
P
i
An
\unstable"
p
oin
ter
to
a
closure.
This
is
the
p
oin
ter
that
gets
up
dated
when
the
garbage
collector
mo
v
es
an
ob
ject
w
e
ha
v
e
a
stable
p
oin
ter
to.
If
the
p
oin
ter
is
not
in
use,
it
p
oin
ts
to
a
preallo
cated
static
closure.
T
op
The
index
of
the
rst
elemen
t
ab
o
v
e
the
top
of
the
stac
k.
s
i
An
en
try
in
a
stac
k
of
un
used
p
oin
ters.
En
tries
in
use
will
con
tain
a
n
um
b
er
in
the
range
0
:
:
:
n
 .
F
or
example,
with
n
=

and
p
oin
ters
0
and

in
use
(p
oin
ting
to
p
and
p
resp
ectiv
ely),
the
table
migh
t
lo
ok
lik
e
this:

p
?
?
p



?
?

.
Garbage
Collection
Glasgo
w
Hask
ell
supp
orts
four
dieren
t
garbage
collectors:

a
-space
cop
ying
collector
[
];

a
-space
compacting
collector
[
];

a
\dual
mo
de"
collector
whic
h
op
erates
either
as
a
t
w
o
space
collector
or
a
compacting
collector
dep
ending
on
the
amoun
t
of
liv
e
data
[0
];
and

a
generational
collector
[,

].
This
collector
main
tains
just
t
w
o
genera-
tions:
the
new
generation
is
collected
using
a
t
w
o-space
collector;
and
the
old
generation
is
collected
using
a
one-space
collector.
T
o
allo
w
separate
collection
of
the
generations,
a
list
of
p
oin
ters
from
the
old
generation
to
the
new
generation
is
main
tained.
The
c
hanges
required
to
the
collectors
are
as
follo
ws:
..
Copying
c
ol
le
ctor
-space
collection
consists
of
a
single
main
phase
whic
h
alternates
b
et
w
een
cop
ying
liv
e
heap
ob
jects
in
to
a
new
area
of
memory
(ev
acuation)
and
scanning
copied
ob
jects
for
p
oin
ters
to
uncopied
heap
ob
jects
(sca
v
enging).
When
an
ob
ject
is
ev
acuated,
it
is
o
v
erwritten
b
y
a
\forw
arding
p
oin
ter"
whic
h
p
oin
ts
to
the
cop
y
|
this
allo
ws
all
references
to
an
ob
ject
to
b
e
up
dated
with
the
same
address.
The
stable
p
oin
ter
table
is
treated
as
a
\ro
ot"
during
garbage
collection
and
collected
in
the
normal
w
a
y
.
After
this
main
phase
has
completed,
elemen
ts
of
the
_MallocPtr
List
(whic
h
will
still
b
e
in
the
from
space)
is
scanned
c
hec
king
whic
h
ob
jects
ha
v
e
b
een
replaced
b
y
forw
arding
p
oin
ters
(and
so
are
still
liv
e)
and
whic
h
are
no
w
dead
and
can
b
e
released.
Eac
h
liv
e
ob
ject
is
added
to
the
new
_MallocPtr
list.
There
is
one
sligh
t
subtlet
y
.
When
a
heap-ob
ject
is
o
v
erwritten
with
a
forw
arding
p
oin
ter,
care
m
ust
b
e
tak
en
not
to
o
v
erwrite
the
link
to
the
next
MallocPtr
in
the
c
hain
since
this
is
required
later
in
the
garbage
collection.
(In
all
other
ob
jects,
the
garbage
collector
is
free
to
trash
the
con
ten
ts
of
an
ob
ject
as
so
on
as
it
has
b
een
copied.)
..
Comp
acting
Col
le
ctor
-space
collection
consists
of
three
main
phases:
a
traditional
marking
phase
whic
h
writes
\marks"
to
a
bitmap;
a
linking
phase
whic
h
links
all
references
to
an
ob
ject
in
to
a
single
list;
and
a
mo
ving
phase
whic
h
mo
v
es
all
heap
ob
jects
do
wn
in
memory
deleting
holes
and
up
dating
references
to
ob
jects.
Again,
the
stable
p
oin
ter
table
m
ust
b
e
treated
as
a
\ro
ot"
during
garbage
collection.
After
the
marking
phase,
w
e
scan
through
the
_MallocPtr
list
releasing
those
whic
h
ha
v
e
not
b
een
mark
ed.
(This
m
ust
b
e
done
b
efore
the
linking
phase
so
that
the
stable
p
oin
ter
table
will
con
tain
sensible
v
alues
and
can
b
e
up
dated
b
y
an
y
calls
to
freeStablePtr
.)
Eac
h
_MallocPtr
is
added
to
the
_MallocPtr
list
as
it
is
mo
v
ed.

..
Dual
Mo
de
Col
le
ction
The
dual-mo
de
collector
switc
hes
b
et
w
een
cop
ying
(-space)
collection
and
compacting
(-space)
collection
according
to
residency
.
It
is
simply
a
com-
bination
of
the
ab
o
v
e.
..
(App
el)
Gener
ational
Col
le
ction
The
App
el
generational
collector
main
tains
t
w
o
separate
generations:
an
old
generation
whic
h
is
collected
b
y
a
compacting
collector
and
a
new
generation
whic
h
is
collected
b
y
a
cop
ying
collector.
(When
the
new
generation
is
collected,
it
is
copied
on
to
the
end
of
the
old
generation.)
This
is
essen
tially
just
a
straigh
tforw
ard
com
bination
of
the
cop
ying
and
the
compacting
collectors.
Ho
w
ev
er,
since
the
generations
are
collected
separately
,
w
e
main
tain
a
separate
_MallocPtr
list
for
eac
h
generation.
Collecting
the
new
generation
transfers
all
liv
e
ob
jects
to
the
old
generation
and
so
the
new
_MallocPtr
list
is
emptied
and
the
old
list
extended.
Care
m
ust
b
e
tak
en
to
ensure
that
StgPerformGarbage
Co
lle
ct
io
n
p
er-
forms
a
full
garbage
collection:
merely
ushing
the
new
generation
migh
t
not
release
all
unreac
hable
ob
jects.

F
urther
W
ork
.
Supp
orting
Sev
eral
Kinds
of
Mallo
c
P
oin
ter
So
far
most
of
our
applications
ha
v
e
only
used
mallo
c
p
oin
ters
as
p
oin
ters
to
a
single
kind
of
ob
ject
(eg
strings
or
images).
In
this
situation,
dening
the
function
FreeMallocPtr
is
straigh
tforw
ard.
As
mallo
c
p
oin
ters
are
used
more
hea
vily
,
w
e
an
ticipate
problems
with
dieren
t
kinds
of
ob
ject
requiring
dieren
t
deallo
cation
routines.
An
ob
vious
solution
is
that
instead
of
returning
a
p
oin
ter
to
an
ob
ject,
a
C
function
should
return
a
p
oin
ter
to
a
pair
con
taining
a
p
oin
ter
to
an
ob
ject
and
a
p
oin
ter
to
a
freeing
routine
appropriate
to
that
kind
of
ob
ject.
(An
early
implemen
tation
stored
b
oth
the
p
oin
ter
to
the
ob
ject
and
a
p
oin
ter
to
the
freeing
routine
in
the
Hask
ell
heap.
The
p
oin
ter
to
the
freeing
routine
w
as
remo
v
ed
after
problems
p
ersuading
C
compilers
to
return
pairs
reliably
.)
.
Eliminating
a
Space
Leak
Though
individually
safe,
the
pro
vision
of
b
oth
stable
p
oin
ters
and
mallo
c
p
oin
ters
in
tro
duces
a
p
oten
tial
space
leak.
The
reason
for
this
is
that
it
is
p
ossible
to
setup
a
cyclic
structure
in
v
olving
an
ob
ject
in
the
C
w
orld
whic
h
con
tains
a
stable
p
oin
ter
in
the
Hask
ell
w
orld
whic
h
con
tains
a
mallo
c
p
oin
ter
to
the
C
ob
ject.
This
space
leak
could
b
e
eliminated
b
y
c
hanging
the
in
terface
to
mallo
c
p
oin
ters
to
allo
w
the
C
w
orld
to
tak
e
a
more
activ
e
role
in
garbage
collection.

A
t
start
of
GC,
tell
the
C
w
orld
that
GC
is
ab
out
to
start.
(This
w
ould
allo
w
the
C
w
orld
to
clear
mark
bits
(sa
y)
on
heap
ob
jects.)


During
GC,
tell
the
C
w
orld
whenev
er
a
liv
e
mallo
c
p
oin
ter
is
found.
(This
ma
y
cause
the
C
w
orld
to
inform
the
Hask
ell
w
orld
that
a
stable
p
oin
ter
is
liv
e.)

A
t
end
of
GC,
tell
the
C
w
orld
that
GC
is
ending.
(This
w
ould
allo
w
the
C
w
orld
to
delete
an
y
mallo
c
p
oin
ters
that
ha
v
e
not
b
een
mark
ed
as
liv
e.)
(In
a
generational
collector,
the
C
w
orld
should
b
e
told
that
all
mallo
c
p
oin
ters
in
uncollected
(old)
generations
are
liv
e
at
the
end
of
GC.)
W
e
ha
v
e
not
implemen
ted
this
alternativ
e
since
the
greater
complexit
y
(and
harder
testing)
did
not
seem
to
b
e
justied
b
y
the
risk.
.
Better
Generational
Collection
Garbage
collecting
an
en
tire
heap
ma
y
tak
e
some
time
{
it
w
ould
b
e
nice
to
b
e
able
to
p
erform
only
as
m
uc
h
w
ork
as
is
required
to
free
enough
Mallo
cPtr.
In
a
generational
garbage
collector,
this
could
b
e
done
b
y
pro
viding
an
additional
parameter
indicating
ho
w
man
y
generations
are
to
b
e
collected.
One
could
then
write:
generation
=
0;
while(freeSpace
<
requiredSpace
&&
generation
!=
numGenerations){
StgPerformGarbage
Co
lle
ct
io
n(
generation
);
generation
+=
;
}
Eac
h
call
to
the
collector
copies
the
curren
t
generation
in
to
the
next
lev
el.
Th
us,
the
only
o
v
erhead
of
rep
eatedly
calling
the
collector
are
the
tests
that
the
lo
w-n
um
b
ered
generations
are
indeed
empt
y
.

Related
W
ork
Our
\mallo
c
p
oin
ters"
mec
hanisms
b
ear
some
resem
blance
to
the
\w
eak
ref-
erences"
and
\w
eak
arra
ys"
of
(the
DEC
SR
C
implemen
tation
of
)
Mo
dula

[]
and
the
Ob
ject
w
orksnSmalltalk
implemen
tation
[
]
resp
ectiv
ely
.
Both
pro-
vide
a
metho
d
of
asso
ciating
a
\clean
up
pro
cedure"
to
an
ob
ject
whic
h
is
called
when
the
asso
ciated
ob
ject
\dies".
An
essen
tial
dierence
is
that
the
clean
up
pro
cedure
is
written
in
Mo
dula

(resp
ectiv
ely
Smalltalk).
This
is
p
ossible
b
ecause
b
oth
languages
supp
ort
m
ultitasking
and
asso
ciated
mec
hanisms
suc
h
as
semaphores
to
use
it
safely
.
Since
the
clean
up
pro
cedures
will,
b
y
their
nature,
in
v
olv
e
side-eects,
it
is
not
clear
that
this
solution
w
ould
b
e
appropriate
in
Hask
ell.
W
e
note
that
there
is
no
need
to
build
stable
p
oin
ters
in
to
an
imp
erativ
e
language
implemen
tation:
they
are
readily
implemen
ted
b
y
using
a
global
table
or
list
of
stable
p
oin
ters.
This
pro
vides
the
same
b
eha
viour
since
the
garbage
collector
will
automatically
trace
all
global
v
ariables.


Summary
There
is
a
w
ealth
of
high
qualit
y
library
co
de
freely
a
v
ailable
for
use
b
y
imp
er-
ativ
e
programmers.
If
functional
programmers
are
unable
to
(or
c
ho
ose
not
to)
use
this
resource,
an
y
claims
of
greater
pro
ductivit
y
or
higher
lev
els
of
reuse
b
ecome
nonsense.
Glasgo
w
Hask
ell's
existing
foreign
language
in
terface
allo
w
ed
one
to
call
simple
library
functions
but
w
as
insucien
t
for
creating
a
reliable
in
terface
to
a
large
library
featuring
in
v
olving
large
lazy
p
olymorphic
ob
jects
whic
h
p
ersist
from
one
function
call
to
the
next.
W
e
ha
v
e
describ
ed
t
w
o
new
t
yp
es
to
o
v
ercome
these
problems:
_MallocPtr
s
to
allo
w
Haskell
to
refer
to
C
ob
jects;
and
_StablePtr
s
to
allo
w
C
to
refer
to
Haskell
ob
jects.
Ac
kno
wledgemen
ts
As
w
ell
as
b
eneting
from
the
existence
of
a
system
on
whic
h
to
implemen
t
the
ideas
in
this
pap
er,
I
ha
v
e
receiv
ed
considerable
help
from
those
w
orking
on
the
Glasgo
w
Hask
ell
compiler.
In
particular,
Simon
P
eyton
Jones,
Will
P
ar-
tain
and
Jim
Mattson
ha
v
e
pro
vided
considerable
assistance
with
the
compiler
mo
dications
describ
ed
here.
Sigb
jorn
Finne,
Da
vid
F
raser,
Satnam
Singh,
P
aul
Smith
and
Kevin
Ham-
mond
(all
at
Glasgo
w
Univ
ersit
y)
pro
vided
early
v
ersions
of
Hask
ell
in
terfaces
to
a
v
ariet
y
of
libraries
whic
h
motiv
ated
the
dev
elopmen
t
of
the
ideas
in
this
pap
er.
Ian
P
o
ole
(at
the
Medical
Researc
h
Council
Human
Genetics
Unit,
Edin
burgh)
image-pro
cessing
requiremen
ts
prompted
the
implemen
tation
of
\Mallo
c
P
oin
ters"
describ
ed
in
this
pap
er.
Jim
Mattson's
implemen
tation
of
in
terrupt
handlers
pro
vided
y
et
another
motiv
ation
for
Stable
P
oin
ters.
T
oDo:
Simon:
where
did
the
money
y
ou
paid
me
come
from?
References
[]
A
W
App
el,
Simple
generational
garbage
collection
and
fast
allo
cation,
Soft
w
are
|
Practice
and
Exp
erience
	,
{,
F
eb.
		.
[]
JF
Bartlett,
Compacting
garbage
collection
with
am
biguous
ro
ots,
Lisp
P
oin
ters
,
,
{,
Apr.
	.
T
oDo:
Chec
k
that
this
reference
describ
es
w
eak
p
oin
ters
[]
HJ
Bo
ehm,
Space
ecien
t
conserv
ativ
e
garbage
collection,
in
Pro
c.
A
CM
Comference
on
Programming
Language
Design
and
Implemen
tation,
Al-
buquerque,
	{0,
June
		.
[]
L
Cardelli,
J
Donah
ue,
L
Glassman,
M
Jordan,
B
Kalso
w,
G
Nelson,
Mo
dula-
Language
Denition,
A
CM
SIGPLAN
Notices,
,
,
{,
Aug.
		.
[]
M
Carlsson
and
T
Hallgren,
F
udgets:
a
graphical
user
in
terface
in
a
lazy
functional
language,
in
Pro
c.
Conference
on
F
unctional
Programming
and
Computer
Arc
hitecture,
		.

[]
CJ
Cheney
,
A
nonrecursiv
e
list
compacting
algorithm,
Comm
unications
of
the
A
CM
,
{,
No
v.
	0.
[]
CLX
Common
Lisp
X
In
terface,
T
exas
In
trumen
ts
Incorp
orated,
		.
[]
D
F
raser,
Hask
ell
Defender:
implemen
ting
arcade
games
in
lazy
functional
languages,
Senior
Honours
Pro
ject,
Computing
Science
Departmen
t,
Uni-
v
ersit
y
of
Glasgo
w,
		.
[	]
ER
Gansner,
JH
Repp
y
,
eXene,
Oct.
		.
[0]
R
Harp
er
and
P
Lee,
Adv
anced
languages
for
systems
soft
w
are:
the
F
o
x
pro
ject
in
		,
CMU-CS-	-0,
Departmen
t
of
Computing
Science,
Carnegie
Mellon
Univ
ersit
y
,
Jan
		.
[]
HBM
Jonk
ers,
A
fast
garbage
compaction
algorithm,
Information
Pro
cess-
ing
Letters
	,
{0,
July
		.
[]
JT
O'Donnell,
Data
parallel
implemen
tation
of
Extensible
Sparse
F
unc-
tional
Arra
ys,
P
arallel
Arc
hitectures
and
Languages
Europ
e,
LNCS
	,
Springer-V
erlag,
{	,
		.
[]
P
arcPlace
Systems,
Ob
ject
w
orksnSmalltalk
User's
Guide
(Release
),
0
Plymouth
Street,
Moun
tain
View,
California
	0.
		0.
[]
SL
P
eyton
Jones
and
J
Launc
h
bury
,
Lazy
imp
erativ
e
programming,
A
CM
SIGPLAN
W
orkshop
in
State
in
Programming
Languages,
Cop
enhagen,
June
		.
[]
SL
P
eyton
Jones
and
J
Launc
h
bury
,
Un
b
o
xed
v
alues
as
rst
class
citizens
in
a
non-strict
functional
language,
in
Pro
c.
		
Conference
on
F
unctional
Programming
and
Computer
Arc
hitecture,
Cam
bridge,
Sept.
		.
[]
SL
P
eyton
Jones
and
J
Launc
h
bury
,
Lazy
functional
state
threads,
in
Pro
c.
A
CM
Comference
on
Programming
Language
Design
and
Implemen
tation,
Orlando,
June
		.
[]
SL
P
eyton
Jones
and
PL
W
adler,
Imp
erativ
e
functional
programming,
in
Pro
c.
0th
A
CM
Symp
osium
on
Principles
of
Programming
Languages,
Charlotte,
A
CM,
Jan
		.
[]
I
P
o
ole
and
D
Charleston,
Exp
erience
of
dev
eloping
a
cervical
cytology
scanning
system
using
Gofer
and
Hask
ell,
this
v
olume,
Septem
b
er
		.
[	]
AD
Reid
and
S
Singh,
Implemen
ting
fudgets
with
standard
widget
sets,
in
Pro
c.
Glasgo
w
W
orkshop
on
F
unctional
Programming,
W
orkshops
in
Computing
Series,
Springer-V
erlag,
July
		.
[0]
PM
Sansom,
Com
bining
cop
ying
and
compacting
garbage
collection,
in
Pro
c.
Glasgo
w
W
orkshop
on
F
unctional
Programming,
W
orkshops
in
Com-
puting
Series,
Springer-V
erlag,
Aug
		.
[]
PM
Sansom
and
SL
P
eyton
Jones,
Generational
garbage
collection
for
Hask
ell,
in
Pro
ceedings
of
the
		
Conference
on
F
unctional
Programming
and
Computer
Arc
hitecture.

