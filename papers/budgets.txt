Implemen
ting
F
udgets
with
Standard
Widget
Sets
Alastair
Reid
&
Satnam
Singh

Computing
Science
Departmen
t
Univ
ersit
y
of
Glasgo
w
July
,
		
Abstract
Carlsson
and
Hallgren
[
]
describ
e
the
implemen
tation
of
a
set
of
\functional
widgets"
(F
udgets):
comp
onen
ts
for
programming
graphical
user
in
terfaces
under
the
X
windo
w
system
using
the
non-
strict
functional
programming
language
Hask
ell.
W
e
describ
e
an
alternativ
e
implemen
tation
based
on
existing
widget
sets
(curren
tly
Op
enlo
ok
and
Motif
).
Our
purp
ose
is
t
w
ofold:
to
sho
w
that
the
F
udgets
approac
h
can
b
e
applied
to
existing
widget
sets;
and
to
discuss
problems
exp
erienced
with
F
udgets
during
an
industrial
case
study
.

In
tro
duction
Imp
erativ
e
language
programmers
enjo
y
relativ
ely
easy
access
to
the
graphics
resources
of
w
orkstations.
The
graphics
hardw
are
is
manipulated
b
y
side-eecting
pro
cedure
calls.
Ev
en
if
the
library
of
graphics
pro
cedures
is
written
in
one
imp
erativ
e
language
(e.g
`C'),
programs
written
in
another
imp
erativ
e
language
can
usually
mak
e
calls
to
foreign
pro
cedures.
F
or
example,
Ada
allo
ws
foreign
pro
cedures
to
b
e
called
b
y
giving
a
standard
pragma.
Ada
compilers
also
allo
w
Ada
routines
to
b
y
called
b
y
alien
pro
cedures.
This
rep
ort
describ
es
a
library
for
building
high
qualit
y
user-in
terfaces
for
the
purely
functional
lazy
program-
ming
language
Hask
ell.
Graphics
op
erations
are
pro
duced
b
y
making
alien
pro
cedure
calls
to
C
language
routines.
Comm
unicating
data
b
et
w
een
Hask
ell
and
C
programs
is
not
trivial
b
ecause
Hask
ell
is
a
lazy
language,
has
a
garbage
collector
and
uses
a
v
ery
dieren
t
represen
tation
for
data
(ev
en
for
simple
t
yp
es
lik
e
in
tegers).
W
e
outline
ho
w
to
write
Hask
ell
programs
that
comm
unicate
data
with
C
routines
in
an
orderly
fashion
using
the
Glasgo
w
IO
monad.
The
st
yle
of
our
in
terface
is
delib
erately
similar
to
the
idiomatic
st
yle
used
in
C
for
writing
X
Windo
ws
graphics
soft
w
are.
This
in
vites
comparison
with
equiv
alen
t
C
programs
and
mak
es
it
easier
to
use
the
extensiv
e
b
o
dy
of
X
programming
man
uals.
The
structuring
tec
hnique
emplo
y
ed
is
based
on
the
excellen
t
F
udgets
systems
whic
h
uses
higher-order
com
binators
to
glue
together
collections
of
user
in
terface
comp
onen
ts.
W
e
describ
e
some
of
the
problems
that
arise
from
the
static
nature
of
the
user
in
terfaces
generated
b
y
the
F
udgets
system.
The
F
udgets
system
denes
its
o
wn
user
in
terface
comp
onen
ts.
W
e
also
sho
w
ho
w
the
F
udgets
approac
h
can
b
e
mo
died
to
use
existing
user
in
terface
comp
onen
ts.
In
particular,
w
e
ha
v
e
adapted
F
udgets
to
use
Op
enLo
ok
and
Motif
for
building
commercial
qualit
y
and
standardised
user
in
terfaces.

Email:
fareid,satnamg@@dcs.glasg
ow.
ac.u
k



C
Programmer's
view
of
X
widgets
The
target
graphics
system
for
our
graphics
library
is
the
X
Windo
w
System.
This
system
runs
on
a
large
v
ariet
y
of
graphics
w
orkstations
and
aords
us
some
degree
of
device
indep
endence.
The
X
Windo
w
System
is
based
around
a
serv
er-clien
t
mo
del.
A
clien
t
program
(e.g.
a
dra
wing
program)
need
not
run
on
the
mac
hine
that
actually
supp
orts
the
displa
y
(a
graphics
w
orkstation).
Indeed,
the
clien
t
mac
hine
ma
y
ha
v
e
no
displa
y
at
all
b
ecause
the
clien
t
and
serv
er
are
connected
o
v
er
a
net
w
ork.
A
clien
t
program
sends
requests
to
the
serv
er
to
dra
w
lines,
p
oin
ts
etc.
The
clien
t
program
is
also
notied
ab
out
ev
en
ts
on
the
serv
er's
displa
y
.
A
t
the
lo
w
est
lev
el,
the
X
Windo
w
System
is
a
net
w
ork
proto
col
whic
h
pro
vides
a
net
w
ork
transparen
t
in
terface
for
serv
ers
and
clien
ts.
A
C
program
language
in
terface
to
this
proto
col
is
called
Xlib.
This
pro
vides
data
t
yp
es
and
pro
cedures
for
p
erforming
v
ery
basic
graphics
op
erations.
Xlib
is
usually
the
lo
w
est
lev
el
at
whic
h
X
applications
are
written.
Ho
w
ev
er,
little
supp
ort
is
pro
vided
for
building
user
in
terfaces
comprising
of
comp
onen
ts
lik
e
buttons,
men
us
and
scrollbars.
The
X
In
trinsics
T
o
olkit
(Xt)
is
a
collection
of
C
t
yp
es
and
pro
cedures
that
describ
e
the
infrastructure
need
to
build
graphical
user
in
terfaces.
A
mec
hanism
is
pro
vided
for
creating
user
in
terface
comp
onen
ts
called
widgets.
Comp
osite
widgets
ma
y
con
tain
other
widgets,
allo
wing
user
in
terfaces
to
b
e
constructed
in
a
mo
dular
fashion
as
a
widget
tree.
Widgets
con
tain
lo
cal
state
and
are
often
implemen
ted
as
nite
state
mac
hines.
The
system
w
e
describ
e
uses
Xlib
and
Xt.
Xt
do
es
not
dene
the
b
eha
viour
or
app
earance
of
an
y
particular
widget.
It
only
pro
vides
a
`bac
kplane'
in
to
whic
h
sp
ecic
widget
sets
can
b
e
plugged
in
to.
Widget
sets
include
A
thena
(distributed
with
Xt),
Op
enLo
ok
In
trinsic
T
o
olkit
(OLIT)
and
Motif.
Though
broadly
similar,
dieren
t
widget
sets
ha
v
e
dieren
t
resources
and
callbac
ks,
so
it
is
hard
to
mo
dify
a
program
written
with
one
widget
set
to
w
ork
with
another
widget
set.
The
Xt
system
for
managing
ev
en
ts
lik
e
button
clic
ks
and
men
u
selection
is
based
around
c
al
lb
acks.
Callbac
ks
are
similar
to
in
terrupts.
A
widget
can
ha
v
e
sev
eral
kinds
of
ev
en
ts.
F
or
eac
h
widget
and
eac
h
kind
of
ev
en
t,
a
callbac
k
routine
can
b
e
sp
ecied.
(F
or
example,
a
button
w
ould
ha
v
e
a
handler
that
is
called
whenev
er
it
is
clic
k
ed.
The
callbac
k
routine
is
lik
e
a
closure
(it
is
basically
a
co
de-en
vironmen
t
pair).
Unlik
e
an
in
terrupt,
the
clien
t
program
is
not
immediately
in
terrupted
and
con
trol
transfered
to
the
handler.
Instead,
this
ev
en
t
is
queued.
The
top
lev
el
of
an
Xt
program
con
tains
a
lo
op
that
w
aits
for
an
ev
en
t
and
then
dispatc
hes
the
ev
en
t
b
y
calling
the
appropriate
callbac
k.
Th
us,
only
one
callbac
k
can
o
ccur
at
an
y
time.
The
rest
of
the
program
is
held
up
un
til
the
callbac
k
routine
has
nished.
The
execution
of
Xt
programs
tak
es
place
in
three
distinct
phases.
First
a
connection
to
the
X
serv
er
is
created.
Once
the
connection
is
formed,
a
widget
that
corresp
onds
to
the
ro
ot
windo
w
of
the
serv
er
displa
y
is
returned.
A
clien
t
has
as
its
top
lev
el
a
shel
l
widget
whose
paren
t
is
the
ro
ot
windo
w.
The
widgets
of
the
clien
t
program
are
realised
and
the
clien
t
program
en
ters
its
ev
en
t
lo
op.
Eac
h
widget
has
asso
ciated
with
it
a
set
of
r
esour
c
es.
Resources
allo
w
certain
asp
ects
ab
out
the
b
eha
viour
or
app
earance
of
a
widget
to
b
e
determined
either
when
it
is
initialised
or
during
execution.
Resources
are
also
useful
for
describing
the
p
ositioning
of
widgets
on
the
screen,
colouration
or
in
ternationalisation.
Both
X
and
Xt
are
equipp
ed
with
sophisticated
resource
database
managers.
T
o
illustrate
the
idiomatic
C
st
yle
for
writing
X
soft
w
are,
w
e
sho
w
b
elo
w
a
(sligh
tly
simplied)
program
that
c
hanges
the
lab
el
text
of
a
user
in
terface
comp
onen
t
(tak
en
from
[]):
static
int
count
=
0;
static
void
setDisplay(Widge
t
display,
int
i)
{


char
s[0];
Arg
wargs[];
sprintf(s,
"%d",
i);
XtSetArg(wargs[0]
,X
mN
lab
el
Str
in
g,
s);
XtSetValues(displ
ay
,
wargs,
);
}
static
void
increment(Widget
display)
{
count++;
setDisplay(displa
y,
count);
}
void
main()
{
Widget
top,
row,
button,
counter;
top
=
XtInitialise();
row
=
XmCreateRowColu
mn(
"r
ow"
,
top);
display
=
XmCreateLabel("d
isp
la
y",
ro
w)
;
button
=
XmCreatePushButto
n("
bu
tto
n"
,r
ow)
;
setDisplay(
display,
count
);
XtAddCallback(but
to
n,
increment,
display);
XtRealizeWidget()
;
XtMainLoop();
}
The
main
pro
cedure
sets
up
a
connection
to
the
X
serv
er
and
creates
a
hierarc
h
y
of
widgets.
A
callbac
k
routine
is
declared
for
the
button,
namely
increment.
Whenev
er
the
button
is
clic
k
ed,
an
ev
en
t
is
registered.
The
XtMainLoop
pro
cedure
pro
cesses
this
ev
en
t
b
y
lo
oking
up
and
then
executing
the
callbac
k
declared
for
the
button
(i.e.
increment).
The
increment
routine
simply
up
dates
a
global
coun
ter
v
ariable
and
then
mak
es
the
lab
el
displa
y
the
decimal
represen
tation
of
this
coun
t
as
its
lab
el
text.
The
lab
el
text
is
mo
died
b
y
up
dating
the
lab
el
resource
(XmNlabelString)
for
the
button
widget.

Accessing
widgets
from
Hask
ell
Our
metho
d
of
accessing
the
v
arious
X
and
widget
libraries
migh
t
b
e
regarded
as
the
most
straigh
tforw
ard
approac
h:
for
ev
ery
library
function
that
w
e
w
an
t
to
access,
w
e
dene
a
Hask
ell
function
that
calls
that
function.
Since
the
X-library
functions
ha
v
e
v
arious
side-eects
(the
most
ob
vious
of
whic
h
is
dra
wing
an
image
on
the
screen)
it
is
necessary
to
ensure
that
the
op
erations
o
ccur
in
the
correct
sequence.
Previous
approac
hes
[,

]
ha
v
e
guaran
teed
that
actions
o
ccur
in
a
strict
sequence
b
y
sending
a
list
of
commands
to
an
in
terpreter
(written
in
an
imp
erativ
e
language)
whic
h
executes
the
commands
in
the
order
they
are
receiv
ed.
A
more
recen
t
approac
h
(supp
orted
b
y
the
Glasgo
w
compiler)
is
to
use
a
monad
[]
to
execute
a
series
of
side-eecting
actions
in
a
strict
sequence.
Briey
,
the
Glasgow
IO
monad
pro
vides:

A
data
t
yp
e
IO

whic
h
is
the
t
yp
e
of
a
(p
ossibly
side-eecting)
action
whic
h,
when
executed,
returns
a
v
alue
of
t
yp
e
.



A
mec
hanism
that
allo
ws
arbitrary
co
de
written
in
an
imp
erativ
e
language
to
b
e
used
as
an
action
of
t
yp
e
IO
.

A
function
returnIO
::

!
IO

whic
h,
when
executed
returns
its
argumen
t.

The
com
binator
thenIO
::
IO

->
(
->
IO

)
->
IO

whic
h
com
bines
t
w
o
actions
in
to
one
action.
When
executed,
a
`thenIO`
a
rst
executes
a
obtaining
a
result
r
and
then
executes
the
action
a
r.
W
e
refer
the
reader
to
[]
for
further
details.
Using
the
monadic
approac
h,
the
main
task
of
pro
viding
access
to
a
set
of
imp
erativ
e
library
functions
is
to
dene
a
set
of
Hask
ell
functions
whic
h
call
the
corresp
onding
imp
erativ
e
function.
The
ma
jor
dicult
y
here
is
in
passing
v
alues
from
Hask
ell
in
to
the
imp
erativ
e
functions
and
from
imp
erativ
e
functions
in
to
Hask
ell.
F
or
simple
v
alues
suc
h
as
in
tegers
and
strings,
w
e
w
ere
able
to
use
the
metho
d
of
\un
b
o
xing"
describ
ed
b
y
P
eyton
Jones
and
Launc
h
bury
[];
to
allo
w
us
to
pass
more
complex
v
alues
suc
h
as
callbac
ks,
w
e
made
a
small,
general-purp
ose
extension
to
the
Glasgo
w
compiler.

This
basic
approac
h
can
also
b
e
used
to
translate
programs
whic
h
use
the
X
and
widget
libraries
in
to
Hask
ell.
One
further
dicult
y
lies
in
the
implemen
tation
of
global
v
ariables.
W
e
use
the
follo
wing
solution
describ
ed
b
y
Launc
h
bury
in
[].

The
t
yp
e
Var

is
an
abstract
data
t
yp
e
of
m
utable
v
ariables
of
t
yp
e
.

Giv
en
an
initial
v
alue
x
sa
y
,
executing
the
op
eration
newVar
x
allo
cates
a
v
ariable
with
initial
v
alue
x,
and
returns
a
reference
to
the
v
ariable.

Giv
en
a
v
ariable
v::Var
,
executing
readVar
v
reads
the
curren
t
v
alue
of
the
v
ariable
v.
Similarily
,
executing
writeVar
up
dates
the
v
alue
of
the
v
ariable.
F
or
example,
the
program
at
the
end
of
section

ma
y
b
e
\translated"
in
to
the
follo
wing
Hask
ell
program.
>
increment
::
Label
d
=>
Var
Int
->
d
->
IO
()
>
increment
var
display
=
>
readVar
var
`thenIO`
\
count
->
>
writeVar
var
(count
+
)
`thenIO`
\
_
->
>
setDisplay
display
(count
+
)
>
>
setDisplay
::
Label
d
=>
d
->
Int
->
IO
()
>
setDisplay
display
count
=
>
setLabel
display
(LabelString
(show
count))
>
>
mainIO
::
IO
()
>
mainIO
=
>
initialise
"Xtest"
`thenIO`
\
top
->
>
createRowColumn
"row"
top
`thenIO`
\
row
->

Our
initial
implemen
tation
used
a
dieren
t
approac
h
based
on
the
fact
that
callbac
ks
are
only
called
b
y
the
ev
en
t
lo
op
and
it
is
p
ossible
to
write
y
our
o
wn
ev
en
tlo
op
for
X.
All
w
e
had
to
do
w
as
write
callbac
k
routines
whic
h
insert
\callbac
k
ev
en
ts"
in
to
an
ev
en
t
queue
and
replace
the
ev
en
t
lo
op
with
a
Hask
ell
lo
op
whic
h
rep
eatedly
calls
the
normal
ev
en
t-handling
routines
(whic
h
migh
t
cause
callbac
ks
to
happ
en)
and
then
dispatc
hes
an
y
callbac
ks
found
in
the
ev
en
t
queue.
Since
the
ev
en
t
lo
op
is
written
in
Hask
ell,
there
is
no
dicult
y
in
calling
callbac
k
routines
written
in
Hask
ell.
This
approac
h
could
b
e
used
quite
eectiv
ely
(and
ecien
tly!)
b
y
those
wishing
to
apply
our
o
v
erall
approac
h
under
other
compilers.


>
createLabel
"label"
row
`thenIO`
\
display
->
>
createButton
"Press
Me!"
row
`thenIO`
\
button
->
>
newVar
0
`thenIO`
\
countVar
->
>
setDisplay
display
0
`thenIO`
\
_
->
>
addButtonCallba
ck
button
>
(increment
countVar
display)
`thenIO`
\
_
->
>
realizeWidget
top
`thenIO`
\
_
->
>
mainloop
The
ab
o
v
e
example
illustrates
ho
w
one
migh
t
(naiv
ely)
write
GUI's
in
Hask
ell:
rst
write
the
program
in
C
and
then
translate
it
in
to
Hask
ell.
Ho
w
ev
er,
ev
en
if
with
practice
w
e
learn
to
a
v
oid
writing
the
program
in
C
rst,
this
kind
of
approac
h
cannot
b
e
exp
ected
to
lead
to
functional
GUIs
whic
h
are
an
y
simpler
than
their
imp
erativ
e
coun
terparts.
The
next
section
discusses
an
approac
h
whic
h
is
dramatically
simpler
than
the
ab
o
v
e.

F
udgets
In
[
]
Carlsson
and
Hallgren
argue
that
functional
languages
are
b
etter
for
implemen
ting
GUIs
b
ecause
they
oer
b
etter
abstraction
facilities.
In
particular,
their
approac
h
mak
es
extensiv
e
use
of
higher-order
functions
to
capture
common
patterns
of
co
ding
within
GUI
programs.
The
essence
of
Carlsson
and
Hallgren's
approac
h
is
to
treat
eac
h
comp
onen
t
of
the
user-in
terface
as
a
\blac
k
b
o
x"
(a
F
udget
)
receiving
input
on
a
single
\input
pin"
and
sending
output
on
a
single
\output
pin."
In
Carlsson
and
Hallgren's
implemen
tation
(see
gure
a),
eac
h
(primitiv
e)
fudget
is
resp
onsible
for
(at
most)
one
windo
w
whose
app
earance
it
con
trols
b
y
sending
X-proto
col
requests
to
the
X-serv
er
and
whic
h
comm
unicates
with
the
fudget
b
y
sending
X-ev
en
ts
to
the
fudget.
In
our
implemen
tation
(see
gure
b),
eac
h
(primitiv
e)
fudget
is
resp
onsible
for
(at
most)
one
widget
whose
app
earance
and
b
eha
viour
is
con
trolled
b
y
calling
resource
setting
routines
(suc
h
as
setLabel)
and
whic
h
comm
unicates
with
the
fudget
b
y
executing
callbac
ks.
α
β
Window
Fudget
Figure
a.
A
Sw
edish
F
udget
α
β
Widget
Fudget
Figure
b.
A
Glasgo
w
F
udget
F
rom
the
programmer's
p
oin
t
of
view,
there
is
little
dierence
b
et
w
een
the
t
w
o
approac
hes.
Some
examples
of
simple
fudgets
are:

button
::
String
->
F

Click
encapsulates
the
pushButton
widget.
The
String
is
used
as
the
lab
el
displa
y
ed
on
the
button.
When
the
user
clic
ks
on
the
button,
a
v
alue
Click

is
sen
t
to
the
output
pin.
(All
input
is
ignored.)

In
Hask
ell,
the
t
yp
e
Click
is
dened
b
y
data
Click
=
Click.



label
::
Text

=>
F


encapsulates
the
lab
el
widget
used
for
outputting
(small)
pieces
of
text.
When
a
v
alue
is
receiv
ed
on
its
input
pin,
its
textual
represen
tation
is
displa
y
ed
on
the
lab
el
widget.
(No
output
is
pro
duced.)

textField
::
F

String
encapsulates
the
text
eld
widget
used
for
inputting
(small)
pieces
of
text.
When
a
v
alue
is
receiv
ed
on
its
input
pin,
the
curren
t
text
en
tered
b
y
the
user
is
sen
t
to
the
output.
It
is
also
useful
to
create
fudgets
whic
h
are
not
asso
ciated
with
an
y
widgets
at
all.
Tw
o
suc
h
fudgets
are:

ioToFudget
::
(
!
IO

)
!
(F


)
encapsulates
an
IO
op
eration.
When
a
v
alue
is
receiv
ed
on
its
input
pin,
the
IO
op
eration
is
applied
to
that
v
alue
(and
executed)
and
the
result
is
sen
t
to
the
output
pin.
A
t
ypical
use
of
this
function
is
to
write
the
input
text
to
a
le
or
to
p
erform
a
database
transaction
on
receiving
data
on
the
input
pin.

stateMachine
::
((s,
)
!
(s,
))
!
s
!
F


encapsulates
a
piece
of
lo
cal
state.
When
a
v
alue
is
receiv
ed
on
its
input
pin,
the
input
and
curren
t
state
are
used
to
calculate
an
output
and
a
successor
state
and
the
output
is
sen
t
to
the
output
pin.
The
strength
of
Carlsson
and
Hallgren's
approac
h
lies
in
the
pro
vision
of
fudget
com
binators
whic
h
allo
w
simple
fudgets
to
b
e
com
bined
in
to
more
p
o
w
erful
com
binators.
F
or
example
fudget
comp
osition
is
ac
hiev
ed
with
the
com
binator
<==<
::
F


!
F


!
F


whic
h
connects
the
output
of
the
second
fudget
to
the
input
of
the
rst
fudget
(see
gure
).
Lik
e
function
comp
osition,
fudget
comp
osition
is
asso
ciativ
e.
α
β
γ
f2
f1
Widget 1
Widget 2
Figure
.
The
fudget
f
<==<
f
F
or
example,
the
example
discussed
in
the
previous
sections
can
b
e
implemen
ted
as
follo
ws
(see
gure
):

>
mainIO
::
IO
()
>
mainIO
=
doFudget
counter
>
>
counter
=
label
0
<==<
>
stateMachine
count
0
<==<
>
button
"Press
Me!"
>
where
>
count
(c,
Click)
=
let
c'
=
c+
in
(c',c')

The
function
doFudget
::
F


!
IO
()
initialises
the
widgets
con
tained
within
a
fudget
and
en
ters
the
ev
en
t
lo
op.


10
Press Me!
label
button
count
n.c.
n.c.
Int
Click
Figure
.
The
Coun
ter
F
udget

Implemen
tation
of
F
udgets
It
is
straigh
tforw
ard
to
implemen
t
fudgets
using
the
library
discussed
in
section
.
Our
implemen
tation
of
fudgets
is
based
on
the
follo
wing
observ
ations:

When
a
fudget
is
created,
w
e
m
ust
call
the
creation
function
to
create
the
corresp
onding
widget.
All
creation
functions
ha
v
e
a
parent
parameter
whic
h
is
used
b
y
X-to
olkit
to
create
the
widget
hierarc
h
y
.
Therefore
a
fudget
m
ust
b
e
a
function
taking
(at
least)
a
paren
t
widget
as
a
parameter.

Since
widgets
comm
unicate
with
fudgets
b
y
executing
callbac
ks,
the
simplest
w
a
y
for
fudgets
to
com-
m
unicate
with
eac
h
other
is
b
y
executing
functions
of
the
same
t
yp
e
as
callbac
ks.
W
e
call
suc
h
functions
\handlers."
type
Handler

=

!
IO
()
That
is,
when
a
fudget
is
created,
it
is
passed
an
output
handler
(whic
h
it
will
call
when
it
w
an
ts
to
send
output)
and
returns
an
input
handler
(whic
h
is
called
when
it
is
b
eing
sen
t
input).
F
or
these
reasons,
the
t
yp
e
F


is
dened
b
y:
type
F


=
Widget
!
Handler

!
IO
(Handler
)
The
denition
of
the
four
fudgets
and
com
binators
used
in
the
ab
o
v
e
example
is
straigh
tforw
ard:

The
button
fudget
creates
a
push
button
widget;
adds
a
callbac
k;
and
returns
an
input
handler.
When
the
button
is
pressed,
the
callbac
k
applies
the
button's
output
handler
to
a
Click
(th
us
\sending"
a
Click
to
the
button's
output);
the
button's
input
handler
ignores
all
input.
>
(button
text)
parent
outputHandler
=
>
createButton
text
parent
`thenIO`
\
but
->
>
addButtonCallbac
k
but
>
(outputHandler
Click)
`thenIO`
\
_
->
>
returnIO
inputHandler
>
where
>
inputHandler
a
=
returnIO
()



The
label
fudget
creates
a
lab
el
widget
and
returns
an
input
handler
whic
h
sets
the
lab
el
string
to
the
input
v
alue's
textual
represen
tation.
The
output
handler
is
ignored
since
lab
els
ha
v
e
no
output.
>
(label
text)
parent
outputHandler
=
>
createLabel
text
parent
`thenIO`
\
lab
->
>
returnIO
(inputHandler
lab)
>
where
>
(inputHandler
lab)
a
=
>
setLabel
lab
(LabelString
(show
a))

The
stateMachine
fudget
creates
a
v
ariable
in
whic
h
to
store
the
state.
The
input
handler
returned
applies
the
transition
function
f
to
the
curren
t
state
and
the
input
v
alue
and
then
up
dates
the
state
and
applies
the
output
handler
to
the
output
v
alue.
>
(stateMachine
f
init)
parent
outputHandler
=
>
newVar
init
`thenIO`
\
stateVar
->
>
returnIO
(inputHandler
stateVar)
>
where
>
(inputHandler
stateVar)
a
=
>
readVar
stateVar
`thenIO`
\
s
->
>
let
(s',
b)
=
f
(s,
a)
>
in
writeVar
stateVar
s'
`thenIO`
\
_
->
>
outputHandler
b

The
fudget
comp
osition
op
eration
<==<
creates
t
w
o
fudgets
in
order.
>
(f
<==<
f)
parent
outputHandler
=
>
f
parent
outputHandler
`thenIO`
\
handler
->
>
f
parent
handler
`thenIO`
\
inputHandler
->
>
returnIO
inputHandler
The
com
binators
describ
ed
so
far
are,
at
most
concerned
with
the
lo
c
al
app
earance
of
the
in
terface:
none
are
concerned
with
the
o
v
erall
la
y
out
of
the
widgets
on
the
screen.
This
issue
can
b
e
tac
kled
in
sev
eral
w
a
ys.
.
The
default
la
y
out
of
widgets
on
the
screen
is
determined
b
y
the
order
in
whic
h
the
widgets
are
created:
the
rst
widgets
created
will
b
e
nearer
the
top
or
the
left-hand
side
of
their
paren
t
than
the
last
widgets.
Therefore,
in
a
fudget
of
the
form
f
<==<
f,
(where
data
o
ws
from
righ
t
to
left)
f
will
app
ear
ab
o
v
e
or
to
the
left
of
f.
A
simple
w
a
y
of
c
hanging
the
la
y
out
of
widgets
is
to
c
hange
the
order
in
whic
h
they
are
created.
F
or
example,
using
an
alternativ
e
fudget
com
binator
>==>
::
F


!
F


!
F


(in
whic
h
data
o
ws
from
left
to
righ
t)
it
is
p
ossible
to
sw
ap
the
order
in
whic
h
a
fudget
(or
group
of
fudgets)
is
created.
This
com
binator
is
a
little
tric
ky
to
implemen
t
b
ecause
it
is
necessary
to
create
the
rst
fudget
b
efore
its
output
handler
is
kno
wn.
One
w
a
y
to
implemen
t
this
is
to
use
a
m
utable
v
ariable
as
a
\place-holder"
un
til
the
second
fudget
is
created
(when
the
output
handler
for
the
rst
fudget
will
b
e
kno
wn).

.
Most
widget
sets
pro
vide
an
extensiv
e
range
of
la
y
out
mo
diers
whic
h
allo
w
non-default
la
y
outs
to
b
e
created.
F
or
example,
the
c
hildren
of
a
Motif
RowColumn
widget
will
either
b
e
arranged
in
a
ro
w
or
in
a
column
dep
ending
on
the
curren
t
v
alue
of
the
XmNorientation
resource.

P
eyton-Jones
has
sho
wn
us
a
simpler
solution
based
on
the
xp
oin
t
monad
op
erator
fixIO
::
(
!
IO
)
!
IO
.


A
t
presen
t,
w
e
pro
vide
three
suc
h
\fudget
mo
diers":
row,
column,
grid
(all
of
t
yp
e
F


!
F


)
whic
h
arrange
the
widgets
in
the
fudgets
they
are
applied
to
in
a
horizon
tal
ro
w,
a
v
ertical
column
or
in
a
rectangular
grid.

Problems
with
F
udgets
W
e
ha
v
e
applied
a
set
of
F
udgets
based
on
the
ab
o
v
e
implemen
tation
tec
hnique
to
a
large
industrial
pro
ject.
Ov
erall,
our
exp
erience
of
using
F
udgets
is
that
they
allo
w
one
to
generate
sophisticated
in
terfaces
quic
kly
and
easily
.
Ho
w
ev
er,
in
some
circumstances,
w
e
found
the
structured
approac
h
required
when
using
F
udgets
o
v
erly
restrictiv
e.
During
the
summer
of
		,
the
rst
author
carried
out
a
case
study
for
BT
|
in
v
estigating
the
suitabilit
y
of
F
unctional
Programming
Languages
for
industrial
use
[]
|
during
whic
h
w
e
implemen
ted
a
fron
t
end
for
a
small
part
of
BT's
database.
A
(simplied)
v
ersion
of
a
single
screen
had
the
follo
wing
c
haracteristics:

When
a
button
is
pressed,
a
query
(consisting
of
a
name
and
an
address)
is
to
b
e
sen
t
to
the
database
and
the
result
displa
y
ed
in
an
output
eld.

Queries
are
to
b
e
\v
alidated"
b
efore
b
eing
sen
t
to
the
database.
(F
or
example,
one
migh
t
c
hec
k
that
the
name
is
a
non-empt
y
sequence
of
letters.)

In
the
ev
en
t
of
an
error
(whether
caused
b
y
failing
the
v
alidation
c
hec
k
or
an
unsuccessful
query),
an
error
shell
m
ust
\p
opup"
and
displa
y
the
error
message.
Figure

sho
ws
the
datao
w
within
this
application.
Search
Button
Name:_________
Input 1
Input 2
Address:_______
Error Shell
Error:_____________
Validation
DB Query
Result
Phone: 041-339-8855
Figure
.
A
Database
F
ron
tend
There
are
three
ma
jor
problems
in
turning
this
diagram
in
to
a
v
alid
fudget:
.
The
t
w
o
searc
h
strings
m
ust
b
e
receiv
ed
sim
ultaneously
b
y
the
v
alidation
section.
With
the
ab
o
v
e
denition
of
F
udgets,
w
e
m
ust
send
messages
to
the
t
w
o
input
fudgets
requesting
them
to
output
their
curren
t
con
ten
ts;
there
is
no
p
ossibilit
y
of
sending
these
messages
\sim
ultaneously"
and
so
no
p
ossibilit
y
of
receiving
the
resp
onses
\sim
ultaneously
."
Our
solution
is
to
dene
a
second
kind
of
F
udget
consisting
of
those
widgets
whic
h
cannot
generate
callbac
ks.
F
udgets
of
this
kind
can
b
e
represen
ted
b
y
the
t
yp
e
type
F


=
Widget
!
IO
(
!
IO

)
and
com
bined
with
the
com
binator
>|<
::
F



!
F



!
F
(,
)
(
,

)
whic
h,
on
receiving
a
pair
of
v
alues,
sends
the
rst
v
alue
to
the
rst
fudget
and
the
second
v
alue
to
the
second
fudget
and
returns
the
t
w
o
replies
receiv
ed.
	

>
(f
>|<
f)
parent
=
>
f
parent
`thenIO`
\
h
->
>
f
parent
`thenIO`
\
h
->
>
returnIO
(h
`combine`
h)
>
where
>
(h
`combine`
h)
(a,
a)
=
>
h
a
`thenIO`
\
b
->
>
h
a
`thenIO`
\
b
->
>
returnIO
(b,
b)
This
second
kind
of
fudget
is
readily
con
v
erted
to
the
rst
kind.
It
is
neither
p
ossible
nor
sensible
to
con
v
ert
the
rst
kind
to
the
second
kind.
Carlsson
and
Hallgren
ha
v
e
conrmed
[
]
that
their
implemen
tation
of
F
udgets
suers
from
a
similar
problem
though
they
solv
e
it
in
a
dieren
t
manner.
.
Both
the
v
alidation
section
and
the
database
lo
okup
section
ha
v
e
t
w
o
outputs;
with
b
oth
Carlsson
and
Hallgren's
F
udgets
and
our
o
wn,
F
udgets
are
only
allo
w
ed
to
ha
v
e
a
single
output.
There
are
t
w
o
solutions
to
this
problem:

W
e
migh
t
design
the
v
alidation
and
database
lo
okup
fudgets
so
that
they
\tag"
their
output
according
to
whether
it
is
an
error
message
or
a
v
alid
result.
Sp
ecial
\routing
com
binators"
could
use
these
tags
to
decide
where
to
send
the
result.
Problems
with
this
solution
are
that
they
tend
to
in
tro
duce
a
lot
of
tagging
and
un
tagging
functions
in
to
the
program
and
also,
b
ecause
the
datao
w
is
no
longer
explicit
in
the
structure
of
the
program,
m
uc
h
of
the
b
enet
of
the
F
udget
approac
h
is
lost.

An
alternativ
e
solution
is
to
pro
vide
a
third
kind
of
F
udget
(and
asso
ciated
com
binators)
with
a
single
input
but
t
w
o
outputs.
This
is
p
erfectly
p
ossible
but
w
e
see
no
reason
to
supp
ose
that
w
e
w
on't
also
nd
a
need
for
still
more
kinds
of
F
udget
with
t
w
o
inputs
and
t
w
o
outputs,
one
input
and
three
output,
etc.
The
tension
here
is
b
et
w
een
pro
viding
a
small
but
restrictiv
e
library
of
w
ell-understo
o
d
comp
o-
nen
ts
or
a
larger
library
of
less
general,
less
w
ell-understo
o
d
comp
onen
ts.
W
e
fa
v
our
the
former.
.
One
asp
ect
of
the
w
a
y
the
X
windo
w
system
organises
windo
ws
in
hierarc
hies
is
that
p
opup
shells
m
ust
b
e
c
hildren
of
the
top-lev
el
shell
to
w
ork
correctly
.
On
the
other
hand,
w
e
w
ould
probably
w
an
t
to
use
a
fudget
mo
dier
suc
h
as
row
to
con
trol
the
la
y
out
of
the
other
fudgets
and
so
the
other
fudgets
will
not
b
e
paren
ts
of
the
top-lev
el
shell.
With
the
widget
com
binators
and
mo
diers
discussed
ab
o
v
e,
it
is
not
p
ossible
for
the
input
widgets
and
the
error
widget
to
ha
v
e
dieren
t
paren
ts.
This
is
just
a
single
instance
of
a
basic
problem:
in
widget-based
programs,
the
o
v
erall
structure
of
the
visual
la
y
out
of
the
in
terface
is
determined
b
y
the
widget
hierarc
h
y;
in
fudget-based
programs,
the
widget
hierarc
h
y
is
determined
b
y
the
datao
w
within
the
application.
That
is,
the
datao
w
within
the
application
will
determine
the
o
v
erall
structure
of
the
visual
la
y
out
of
the
in
terface.
It
follo
ws
that
it
ma
y
b
e
hard
or
ev
en
imp
ossible
to
obtain
a
particular
visual
la
y
out
without
signican
tly
sacricing
the
clarit
y
of
the
program.
It
is
w
orth
noting
that
the
last
t
w
o
problems
are
caused
b
y
the
structured
approac
h
imp
osed
b
y
the
use
of
com
binators.
In
the
rst
case,
the
problem
is
that
a
highly
structured
approac
h
do
esn't
seem
to
b
e
appropriate;
while
in
the
second
case,
there
is
a
clash
b
et
w
een
the
structure
imp
osed
b
y
the
datao
w
and
the
structure
imp
osed
b
y
the
visual
app
earance
required
of
the
in
terface.
0


Conclusions
Till
recen
tly
,
there
has
b
een
no
easy
w
a
y
to
create
graphical
user
in
terfaces
in
lazy
functional
languages.
Carlsson
and
Hallgren
ha
v
e
implemen
ted
a
complete
widget
(or,
rather,
fudget)
set
and
com
binators
for
com
bining
simple
fudgets
to
create
complete
applications.
Though
not
without
problems,
their
system
is
v
ery
impressiv
e:
it
pro
vides
a
fast
and
eectiv
e
w
a
y
of
generating
graphical
user-in
terfaces.
The
alternativ
e
fudget
implemen
tation
describ
ed
here
suers
from
man
y
of
the
same
problems
as
Carlsson
and
Hallgren's
implemen
tation
but
diers
in
one
imp
ortan
t
resp
ect:
our
implemen
tation
approac
h
can
b
e
applied
to
standard
widget
sets.
This
has
t
w
o
adv
an
tages:

Applications
dev
elop
ed
with
our
fudgets
will
b
e
consisten
t
with
other
applications
dev
elop
ed
with
the
same
widget
set
(irresp
ectiv
e
of
whic
h
language
they
are
implemen
ted
in).
In
particular,
they
will
ha
v
e
the
same
\lo
ok
and
feel"
and
the
same
resource
databases
can
b
e
used
to
con
trol
their
o
v
erall
colouration,
etc.

It
tak
es
a
substan
tial
eort
to
create
a
widget
set.
By
using
pre-existing
widget
sets,
w
e
a
v
oid
the
need
to
recreate
that
eort.
W
e
see
t
w
o
w
a
ys
of
dev
eloping
this
w
ork
further:

Man
y
imp
erativ
e
programmers
do
not
directly
write
programs
lik
e
that
sho
wn
at
the
end
of
section
.
Instead,
they
use
a
\GUI
builder"
whic
h
allo
ws
them
to
place
widgets
directly
on
the
screen.
The
GUI
builder
automatically
generates
a
program
to
whic
h
the
programmer
need
only
add
the
callbac
k
routines.
W
e
see
this
approac
h
as
a
useful
w
a
y
of
o
v
ercoming
one
of
F
udgets
main
problems:
obtaining
the
correct
la
y
out.
W
e
imagine
that
one
w
ould
rst
write
the
application
and
then
use
the
GUI
builder
to
rearrange
the
widgets
on
screen.
(W
e
understand
that
there
is
a
GUI
builder
for
Carlsson
and
Hallgren's
F
udget
system
though
w
e
ha
v
e
not
b
een
able
to
see
this
builder
in
op
eration.)

Ideally
,
one
w
ould
lik
e
to
mo
del
eac
h
user
in
terface
comp
onen
t
as
a
concurren
t
function
(widget).
User
in
terface
comp
onen
ts
then
comm
unicate
with
eac
h
other
and
the
clien
t
program
via
streams
of
messages.
This
remo
v
es
the
need
for
callbac
k
functions,
whic
h
are
only
needed
in
languages
lik
e
C
b
ecause
they
ha
v
e
no
supp
ort
for
concurrency
.
Curren
tly
,
the
Glasgo
w
Hask
ell
compiler
do
es
not
generate
co
de
whic
h
can
b
e
executed
concurren
tly
.
Ho
w
ev
er,
this
facilit
y
migh
t
b
e
a
v
ailable
in
a
future
v
ersion.
The
authors
ha
v
e
already
built
a
concurren
t
X
in
terface
for
Ada
whic
h
results
in
m
uc
h
simpler
soft
w
are.
An
in
terface
in
a
concurren
t
Hask
ell
should
b
enet
similarly
.
Ac
kno
wledgemen
ts
The
w
ork
rep
orted
here
is
based
on
an
Op
enlo
ok
v
ersion
dev
elop
ed
while
at
Glasgo
w
Univ
ersit
y's
Computing
Science
Departmen
t.
The
Motif
v
ersion
and
(a
c
onsider
ably
extende
d
v
arian
t
of
)
the
database
example
w
ere
dev
elop
ed
b
y
the
rst
author
while
w
orking
at
BT
Researc
h
Labs
on
the
FLARE
pro
ject
whose
supp
ort
w
e
gratefully
ac
kno
wledge.
Thanks
to
o
to
Will
P
artain
and
Simon
P
eyton-Jones
for
their
patience
in
explaining
ho
w
to
extend
the
Glasgo
w
Hask
ell
Compiler.


References
[]
M.
Carlsson
and
T.
Hallgren.
F
udgets:
A
Graphical
User
In
terface
in
a
Lazy
F
unctional
Language.
In
Pr
o
c
e
e
dings
of
the
Confer
enc
e
on
F
unctional
Pr
o
gr
amming
and
Computer
A
r
chite
ctur
e,
		.
[]
M.
Carlsson
and
T.
Hallgren.
Priv
ate
comm
unication.

Octob
er,
		.
[]
S.L.
P
eyton
Jones
and
J.
Launc
h
bury
.
Un
b
o
xed
v
alues
as
rst
class
citizens
in
a
non-strict
functional
lan-
guages.
In
J.
Hughes,
editor,
Pr
o
c
e
e
dings
of
the
Confer
enc
e
on
F
unctional
Pr
o
gr
amming
and
Computer
A
r
chite
ctur
e,
pp.
{,
Cam
bridge,
Massac
h
ussets,
USA,
{
August
		.
[]
S.L.
P
eyton-Jones
and
P
.
W
adler.
Imp
erativ
e
F
unctional
Programming.
In
Pr
o
c
e
e
dings
of
the
		
Confer
enc
e
on
Principles
of
Pr
o
gr
amming
L
anguages,
Charleston,
A
CM,
		.
[]
J.
Launc
h
bury
.
Lazy
Imp
erativ
e
Programming.
In
Pr
o
c
e
e
dings
of
the
Workshop
on
State
in
Pr
o
gr
amming
L
anguages,
pp.
{,
Cop
enhagen,
		.
(Av
ailable
as
Y
ALEU/DCS/RR-	,
Y
ale
Univ
ersit
y
.)
[]
A.
Reid.
A
Windo
w-based
Application
F
ron
t-End
in
Hask
ell
BT
Researc
h
Labs,
Martlesham
Heath.
Septem
b
er
		.
[]
D.
Sinclair.
Lazy
W
afe
|
Graphical
In
terfaces
for
F
unctional
Languages.
In
Heldal
et
al.,
editor,
Glasgow
Workshop
on
F
unctional
Pr
o
gr
amming,
		.
[]
S.
Singh.
Using
XView/X
from
Miranda.
In
Heldal
et
al.,
editor,
Glasgow
Workshop
on
F
unctional
Pr
o
gr
amming,
		.


