A
seman
tics
for
imprecise
exceptions
Simon
P
eyton
Jones
Microsoft
Researc
h
Ltd,
Cam
bridge
simonpj@microsoft.com
Alastair
Reid
Y
ale
Univ
ersit
y
reid-alastair@cs.yale.edu
T
on
y
Hoare

Cam
bridge
Univ
ersit
y
Computer
Lab
oratory
carh@comlab.ox.ac.uk
Simon
Marlo
w
Microsoft
Researc
h
Ltd,
Cam
bridge
t-simonm@microsoft.com
F
ergus
Henderson
The
Univ
ersit
y
of
Melb
ourne
fjh@cs.mu.oz.au
Abstract
Some
mo
dern
sup
erscalar
micropro
cessors
pro
vide
only
im-
pr
e
cise
exc
eptions.
That
is,
they
do
not
guaran
tee
to
re-
p
ort
the
same
exception
that
w
ould
b
e
encoun
tered
b
y
a
straigh
tforw
ard
sequen
tial
execution
of
the
program.
In
ex-
c
hange,
they
oer
increased
p
erformance
or
decreased
c
hip
area
(whic
h
amoun
t
to
m
uc
h
the
same
thing).
This
p
erformance/precision
tradeo
has
not
so
far
b
een
m
uc
h
explored
at
the
programming
language
lev
el.
In
this
pap
er
w
e
prop
ose
a
design
for
imprecise
exceptions
in
the
lazy
functional
programming
language
Hask
ell.
W
e
discuss
sev
eral
designs,
and
conclude
that
imprecision
is
essen
tial
if
the
language
is
still
to
enjo
y
its
curren
t
ric
h
algebra
of
trans-
formations.
W
e
sk
etc
h
a
precise
seman
tics
for
the
language
extended
with
exceptions.
The
pap
er
sho
ws
ho
w
to
extend
Hask
ell
with
exceptions
without
crippling
the
language
or
its
compilers.
W
e
do
not
y
et
ha
v
e
enough
exp
erience
of
using
the
new
mec
hanism
to
kno
w
whether
it
strik
es
an
appropriate
balance
b
et
w
een
ex-
pressiv
eness
and
p
erformance.

In
tro
duction
All
curren
t
programming
languages
that
supp
ort
exceptions
tak
e
it
for
gran
ted
that
the
language
denition
should
sp
ec-
ify
,
for
a
giv
en
program,
what
exception,
if
an
y
,
is
raised
when
the
program
is
executed.
That
used
to
b
e
the
case
in
micropro
cessor
arc
hitecture
to
o,
but
it
is
no
longer
so.
Some
pro
cessors,
notably
the
Alpha,
pro
vide
so-called
im-
pr
e
cise
exc
eptions.
These
CPUs
execute
man
y
instructions
in
parallel,
and
p
erhaps
out
of
order;
it
follo
ws
that
the
rst
exception
(divide-b
y-zero,
sa
y)
that
is
encoun
tered
is

On
study
lea
v
e
from
the
Oxford
Univ
ersit
y
Computing
Lab
oratory
This
pap
er
app
ears
in
Pro
ceedings
of
the
SIGPLAN
Symp
osium
on
Programming
Language
Design
and
Im-
plemen
tation
(PLDI'		),
A
tlan
ta
not
necessarily
the
rst
that
w
ould
b
e
encoun
tered
in
sim-
ple
sequen
tial
execution.
One
approac
h
is
to
pro
vide
lots
of
hardw
are
to
sort
the
mess
out,
and
main
tain
the
program-
mer's
illusion
of
a
simple
sequen
tial
execution
engine;
this
is
what
the
P
en
tium
do
es.
Another,
tak
en
b
y
the
Alpha,
is
to
giv
e
a
less
precise
indication
of
the
whereab
outs
of
the
exception.
In
this
pap
er
w
e
explore
this
same
idea
at
the
lev
el
of
the
programming
language.
The
compiler,
or
the
programmer,
migh
t
w
an
t
to
impro
v
e
p
erformance
b
y
c
hanging
the
pro-
gram's
ev
aluation
order.
But
c
hanging
the
ev
aluation
order
ma
y
c
hange
whic
h
exception
is
encoun
tered
rst.
One
so-
lution
is
to
ban
suc
h
transformations,
or
to
restrict
them
to
ev
aluations
that
pro
v
ably
cannot
raise
exceptions
[	
].
The
alternativ
e
w
e
prop
ose
here
is
to
trade
precision
for
p
erformance:
p
ermit
ric
her
transformations,
and
mak
e
the
language
seman
tics
less
precise
with
resp
ect
to
whic
h
excep-
tion
is
raised.
Note
that
the
use
of
imprecise
exceptions
at
the
program-
ming
language
lev
el
is
not
due
to
the
use
of
imprecise
ex-
ceptions
at
the
hardw
are
lev
el.
(Indeed,
the
latter
ma
y
w
ell
pro
v
e
ephemeral.)
Rather,
b
oth
of
these
arise
from
the
same
motiv
ation:
p
ermitting
b
etter
optimization.
It's
quite
p
ossible
to
ha
v
e
imprecise
exceptions
at
the
program-
ming
language
lev
el
but
not
at
the
hardw
are
lev
el,
or
vice
v
ersa.
Ho
w
ev
er,
the
use
of
imprecise
exceptions
at
the
pro-
gramming
language
lev
el
ma
y
mak
e
it
m
uc
h
easier
for
im-
plemen
tations
to
generate
ecien
t
co
de
on
hardw
are
that
has
imprecise
exceptions.
W
e
mak
e
all
this
concrete
b
y
considering
a
particular
pro-
gramming
language,
Hask
ell,
that
curren
tly
lac
ks
excep-
tions.
Our
con
tributions
are
as
follo
ws:

W
e
review
and
critique
the
folk-lore
on
exception-
handling
in
a
lazy
language
lik
e
Hask
ell
(Section
).
Non-functional
programmers
ma
y
nd
the
idea
of
exceptions-as-v
alues,
as
opp
osed
to
exceptions-as-
con
trol-o
w,
in
teresting.

W
e
presen
t
a
new
design,
based
on
sets
of
exceptions,
to
mo
del
imprecision
ab
out
whic
h
exceptions
can
o
ccur
(Section
).

W
e
sk
etc
h
a
seman
tics
for
the
resulting
language,
using

t
w
o
la
y
ers:
a
denotational
seman
tics
for
pure
expres-
sions
(including
exception-raising
ones),
and
an
op
er-
ational
seman
tics
\on
top"
that
deals
with
exception
handling,
as
w
ell
as
input/output
(Section
).

Informed
b
y
this
seman
tics,
w
e
sho
w
that
v
arious
ex-
tensions
of
the
basic
idea,
suc
h
as
resource-exhaustion
in
terrupts,
can
readily
b
e
accommo
dated;
while
oth-
ers,
suc
h
as
a
\pure"
exception
handler,
are
more
trou-
blesome
(Section
).
There
has
b
een
a
small
urry
of
recen
t
prop
osals
and
pap
ers
on
exception-handling
in
Hask
ell
[
,

,
].
The
distinctiv
e
feature
of
this
pap
er
is
its
fo
cus
on
the
seman
tics
of
the
resulting
language.
The
tric
k
lies
in
getting
the
nice
fea-
tures
of
exceptions
(eciency
,
implicit
propagation,
and
the
lik
e)
without
thro
wing
the
bab
y
out
with
the
bath-w
ater
and
crippling
the
language
design.
Those
less
in
terested
in
functional
programming
p
er
se
ma
y
nev
ertheless
nd
in
teresting
our
dev
elopmen
t
of
the
(old)
idea
of
exceptions-as-v
alues,
and
the
trade-o
b
et
w
een
pre-
cision
and
p
erformance.

The
status
quo
an
te
Hask
ell
has
managed
without
exceptions
for
a
long
time,
so
it
is
natural
to
ask
whether
they
are
either
necessary
or
appropriate.
W
e
briey
explore
this
question,
as
a
w
a
y
of
setting
the
scene
for
the
rest
of
the
pap
er.
Before
w
e
b
egin,
it
is
w
orth
iden
tifying
three
dieren
t
w
a
ys
in
whic
h
exceptions
are
t
ypically
used
in
languages
that
sup-
p
ort
them:
Disaster
reco
v
ery
uses
an
exception
to
signal
a
(hop
efully
rare)
error
condition,
suc
h
as
division
b
y
zero
or
an
assertion
failure.
In
a
language
lik
e
ML
or
Hask
ell
w
e
ma
y
add
pattern-matc
h
failure,
when
a
function
is
ap-
plied
to
a
v
alue
for
whic
h
it
do
es
not
ha
v
e
a
dening
equation
(e.g.
head
of
the
empt
y
list).
The
program-
mer
can
usually
also
raise
an
exception,
using
a
prim-
itiv
e
suc
h
as
raise.
The
exception
handler
t
ypically
catc
hes
exceptions
from
a
large
c
h
unk
of
co
de,
and
p
erforms
some
kind
of
reco
v
ery
action.
Exception
handling
used
in
this
w
a
y
pro
vides
a
degree
of
mo
dularit
y:
one
part
of
a
system
can
protect
itself
against
failure
in
another
part
of
the
system.
Alternativ
e
return.
Exceptions
are
sometimes
used
as
an
alternativ
e
w
a
y
to
return
a
v
alue
from
a
function,
where
no
error
condition
is
necessarily
implied.
An
example
migh
t
b
e
lo
oking
up
a
k
ey
in
a
nite
map:
it's
not
necessarily
an
error
if
the
k
ey
isn't
in
the
map,
but
in
languages
that
supp
ort
exceptions
it's
not
un-
usual
to
see
them
used
in
this
w
a
y
.
The
exception
handler
t
ypically
catc
hes
exceptions
from
a
relativ
ely
circumscrib
ed
c
h
unk
of
co
de,
and
serv
es
mainly
as
an
alternativ
e
con
tin
uation
for
a
call.
Async
hronous
ev
en
ts.
In
some
languages,
an
asyn-
c
hronous
external
ev
en
t,
suc
h
as
the
programmer
t
yp-
ing
\^C
"
or
a
timeout,
are
reected
in
to
the
program-
mer's
mo
del
as
an
exception.
W
e
call
suc
h
things
asyn-
chr
onous
exc
eptions,
to
distinguish
them
from
the
t
w
o
previous
categories,
whic
h
are
b
oth
synchr
onous
ex-
c
eptions.
.
Exceptions
as
v
alues
No
lazy
functional
programming
language
has
so
far
sup-
p
orted
exceptions,
for
t
w
o
apparen
tly
p
ersuasiv
e
reasons.
Firstly
,
lazy
evaluation
scr
ambles
c
ontr
ol
ow.
Ev
aluation
is
demand-driv
en;
that
is,
an
expression
is
ev
aluated
only
when
its
v
alue
is
required
[
].
As
a
result,
programs
don't
ha
v
e
a
readily-predictable
con
trol
o
w;
the
only
pro
ductiv
e
w
a
y
to
think
ab
out
an
expression
is
to
consider
the
value
it
c
omputes,
not
the
way
in
which
the
value
is
c
ompute
d.
Since
exceptions
are
t
ypically
explained
in
terms
of
c
hanges
in
con
trol
o
w,
exceptions
and
lazy
ev
aluation
do
not
app
ear
v
ery
compatible.
Secondly
,
exc
eptions
c
an
b
e
explicitly
enc
o
de
d
in
values,
in
the
existing
language,
so
p
erhaps
exceptions
are
in
an
y
case
unnecessary
.
F
or
example,
consider
a
function,
f,
that
tak
es
an
in
teger
argumen
t,
and
either
returns
an
in
teger
or
raises
an
exception.
W
e
can
enco
de
it
in
Hask
ell
th
us:
data
ExVal
a
=
OK
a
|
Bad
Exception
f
::
Int
->
ExVal
Int
f
x
=
...defn
of
f...
The
data
declaration
sa
ys
that
a
v
alue
of
t
yp
e
ExVal
t
is
either
of
the
form
(Bad
ex)
,
where
ex
has
t
yp
e
Exception
,
or
is
of
the
form
(OK
val)
,
where
val
has
t
yp
e
t.
The
t
yp
e
signature
of
f
declares
that
f
returns
a
result
of
t
yp
e
ExVal
Int
;
that
is,
either
an
Int
or
an
exception
v
alue.
In
short,
the
exc
eption
is
enc
o
de
d
into
the
value
r
eturne
d
by
f.
An
y
consumer
of
f
's
result
is
forced,
willy
nilly
,
to
rst
p
er-
form
a
case
analysis
on
it:
case
(f
)
of
OK
val
->
...normal
case...
Bad
ex
->
...handle
exception...
There
are
go
o
d
things
ab
out
this
approac
h:
no
extension
to
the
language
is
necessary;
the
t
yp
e
of
a
function
mak
es
it
clear
whether
it
can
raise
an
exception;
and
the
t
yp
e
system
mak
es
it
imp
ossible
to
forget
to
handle
an
exception.
The
idea
of
exceptions
as
v
alues
is
v
ery
old
[0
,

].
Subse-
quen
tly
it
w
as
realised
that
the
exception
t
yp
e
constructor,
ExVal
,
forms
a
monad
[
,
	].
Rather
than
ha
ving
lots
of
ad
ho
c
pattern
matc
hes
on
OK
and
Bad
,
standard
monadic
ma-
c
hinery
suc
h
as
Hask
ell's
do
notation,
can
hide
a
w
a
y
m
uc
h
of
the
plum
bing.


.
Inadequacies
of
exceptions
as
v
alues
Enco
ding
exceptions
explicitly
in
an
un-mo
died
language
w
orks
b
eautifully
for
the
alternativ
e-return
usage
of
excep-
tions,
but
badly
for
the
disaster-reco
v
ery
use,
and
not
at
all
for
async
hronous
ev
en
ts.
There
are
sev
eral
distinct
prob-
lems:

Incr
e
ase
d
strictness.
When
adding
exception
handling
to
a
lazy
program,
it
is
v
ery
easy
to
acciden
tally
mak
e
the
program
strict,
b
y
testing
a
function
argumen
t
for
errors
when
it
is
p
asse
d
instead
of
when
it
is
use
d.

Exc
essive
clutter.
The
principal
feature
of
an
excep-
tion
mec
hanism
is
that
exceptions
propagate
implic-
itly
,
without
requiring
extra
clutter
in
the
co
de
b
e-
t
w
een
the
place
the
exception
is
raised
and
where
it
is
handled.
In
stark
con
trast,
the
explicit-enco
ding
approac
h
forces
all
the
in
termediate
co
de
to
deal
ex-
plicitly
(or
monadically)
with
exceptional
v
alues.
The
resulting
clutter
is
absolutely
in
tolerable
for
those
sit-
uations
where
exceptions
are
used
to
signal
disaster,
b
ecause
in
these
cases
propagation
is
almost
alw
a
ys
re-
quired.
F
or
example,
where
w
e
w
ould
originally
ha
v
e
written:
(f
x)
+
(g
y)
w
e
are
no
w
forced
to
write

:
case
(f
x)
of
Bad
ex
->
Bad
ex
OK
xv
->
case
(g
y)
of
Bad
ex
->
Bad
ex
OK
yv
->
OK
(xv+yv)
These
strictures
do
not
apply
where
exceptions
are
used
as
an
alternativ
e
return
mec
hanism.
In
this
case,
the
approac
h
w
orks
b
eautifully
b
ecause
propagation
isn't
nearly
so
imp
ortan
t.

Built-in
exc
eptions
ar
e
un-c
atchable.
In
Hask
ell,
all
the
causes
of
failure
recognised
b
y
the
language
itself
(suc
h
as
divide
b
y
zero,
and
pattern-matc
h
failure)
are
treated
seman
tically
as
b
ottom
(?),
and
are
treated
in
practice
b
y
bringing
the
program
to
a
halt.
Hask
ell
al-
lo
ws
the
program
to
trigger
a
similar
failure
b
y
calling
the
standard
function
error
,
whose
t
yp
e
is:
error
::
String
->
a
So,
ev
aluating
the
call
(error
"Urk")
halts
execution,
prin
ting
\Urk
"
on
standard
error.
The
language
oers
no
w
a
y
to
catc
h
and
reco
v
er
from
an
y
of
these
(syn-
c
hronous)
ev
en
ts.
This
is
a
serious
problem
when
writ-
ing
programs
comp
osed
out
of
large
pieces
o
v
er
whic
h
one
has
little
con
trol;
there
is
just
no
w
a
y
to
reco
v
er
from
failure
in
an
y
sub-comp
onen
t.

L
oss
of
mo
dularity
and
c
o
de
r
e-use,
esp
ecially
for
higher-order
functions.
F
or
example,
a
sorting
func-
tion
that
tak
es
a
comparison
function
as
an
argu-
men
t
w
ould
need
to
b
e
mo
died
to
b
e
used
with
an
exception-raising
comparison
function.

The
monadic
v
ersion
is
nearly
as
bad.

Po
or
eciency.
Exceptions
should
cost
v
ery
little
if
they
don't
actually
o
ccur.
Alas,
an
explicit
enco
ding
in
to
Hask
ell
v
alues
forces
a
test-and-propagate
at
ev
ery
call
site,
with
a
substan
tial
cost
in
co
de
size
and
sp
eed.

L
oss
of
tr
ansformations.
Programs
written
in
a
monadic
st
yle
ha
v
e
man
y
few
er
transformations
than
their
pure
coun
terparts.
W
e
elab
orate
on
this
problem
in
Section
.

No
asynchr
onous
exc
eptions.
Async
hronous
excep-
tions,
b
y
their
nature,
ha
v
e
nothing
to
do
with
the
v
alue
of
the
unfortunate
expression
that
happ
ens
to
b
e
under
ev
aluation
when
the
external
ev
en
t
o
ccurs.
Since
they
arise
from
external
sources,
they
clearly
cannot
b
e
dealt
with
as
an
explicitly-enco
ded
v
alue.
.
Goals
With
these
though
ts
in
mind,
w
e
ha
v
e
the
follo
wing
goals:

Hask
ell
programs
that
don't
in
v
ok
e
exceptions
should
ha
v
e
unc
hanged
seman
tics
(no
clutter),
and
run
with
unc
hanged
eciency
.

All
transformations
that
are
v
alid
for
ordinary
Hask
ell
programs
should
b
e
v
alid
for
the
language
extended
with
exceptions.
It
turns
out
that
w
e
do
not
quite
ac
hiev
e
this
goal,
for
go
o
d
reasons
(Section
.).

It
should
b
e
p
ossible
to
reason
ab
out
whic
h
exceptions
a
program
migh
t
raise.
F
or
example,
w
e
migh
t
hop
e
to
b
e
able
to
pro
v
e
that
non-recursiv
e
programs
will
ter-
minate,
and
programs
that
don't
use
arithmetic
can't
raise
division
b
y
zero.

In
so
far
as
non-determinism
arises,
it
should
b
e
p
ossi-
ble
for
the
programmer
to
conne
the
non-determinism
to
a
clearly-delineated
part
of
the
program.
These
prop
erties
ma
y
seem
ob
vious,
but
they
are
a
little
tric
ky
to
ac
hiev
e.
In
existing
languages
that
supp
ort
excep-
tions,
suc
h
as
ML
or
Ada,
the
need
to
main
tain
the
exception
seman
tics
noticeably
constrains
the
v
alid
set
of
transforma-
tions
and
optimisations
that
a
programmer
or
compiler
can
p
erform.
Compilers
often
attempt
to
infer
the
set
of
p
ossi-
ble
exceptions
with
a
view
to
lifting
these
restrictions,
but
their
p
o
w
er
of
inference
is
limited;
for
example,
they
m
ust
b
e
p
essimistic
across
mo
dule
b
oundaries
in
the
presence
of
separate
compilation.
W
e
claim
that
our
design
retains
al-
most
all
useful
opp
ortunities
for
transformation,
using
only
the
monadic
t
yp
e
system
built
in
to
Hask
ell.
No
separate
eect
analysis
is
required.

A
new
design
Adding
exceptions
to
a
lazy
language,
as
opp
osed
to
enco
d-
ing
exceptions
in
the
un-extended
language,
has
receiv
ed
relativ
ely
little
atten
tion
un
til
recen
tly
.
Dornan
and
Ham-
mond
discussed
adding
exceptions
to
the
pure
(non-I/O)
part
of
a
lazy
language
[],
and
there
has
b
een
a
urry
of
recen
t
activit
y
[
,

,
].
Dra
wing
on
this
w
ork,
w
e
prop
ose


a
programming
in
terface
for
an
exceptions
mec
hanism.
This
sets
the
scene
for
the
core
of
our
pap
er,
the
seman
tics
for
the
resulting
language.
.
The
basic
idea
As
discussed
in
Section
.,
our
rst
design
decision
is
more
or
less
forced
b
y
the
fact
that
Hask
ell
is
a
lazy
language:
ex-
c
eptions
ar
e
asso
ciate
d
with
data
values,
r
ather
than
with
c
ontr
ol
ow.
This
diers
fundamen
tally
from
the
stan-
dard
approac
h
to
exceptions
tak
en
for
imp
erativ
e,
or
strict
functional,
languages,
where
exceptions
are
asso
ciated
with
con
trol
o
w
rather
than
with
data
o
w.
One
place
that
exceptions-as-v
alues
do
es
sho
w
up
in
the
imp
erativ
e
w
orld
is
the
NaNs
(not-a-n
um
b
er)
and
innities
of
the
IEEE
oat-
ing
p
oin
t
standard,
where
certain
bit-patterns
enco
de
ex-
ceptional
v
alues,
whic
h
are
propagated
b
y
the
oating
p
oin
t
op
erations
[0
].
W
e
extend
this
exceptions-as-v
alues
idea
uniformly
to
v
alues
of
any
t
yp
e.
A
v
alue
(of
an
y
t
yp
e)
is
either
a
\normal"
v
alue,
or
it
is
an
\exceptional"
v
alue.
An
\exceptional"
v
alue
con
tains
an
exception,
and
w
e
m
ust
sa
y
what
that
is.
The
data
t
yp
e
Exception
is
the
t
yp
e
of
exceptions.
It
is
a
new
algebraic
data
t
yp
e,
supplied
as
part
of
the
Hask
ell
Prelude,
dened
something
lik
e
this:
data
Exception
=
DivideByZero
|
Overflow
|
UserError
String
...
One
could
imagine
a
simpler
t
yp
e
(e.g.
enco
ding
an
ex-
ception
as
an
in
teger,
or
a
string),
or
a
ric
her
t
yp
e
(e.g.
a
user-extensible
data
t
yp
e,
suc
h
as
is
pro
vided
b
y
ML),
but
this
one
is
a
useful
compromise
for
this
pap
er.
Nothing
w
e
sa
y
dep
ends
on
the
exact
c
hoice
of
constructors
in
the
data
t
yp
e;
hence
the
\...
".
F
or
eac
h
t
yp
e
a,
the
new,
primitiv
e
function
raise
maps
an
Exception
in
to
an
exceptional
v
alue
of
t
yp
e
a:
raise
::
Exception
->
a
Here,
immediately
,
w
e
see
a
dierence
from
the
explicit-
enco
ding
approac
h.
Every
t
yp
e
in
the
language
con
tains
exeptional
v
alues
|
previously
only
the
t
yp
e
ExVal
t
had
that
p
ossibilit
y
.
W
e
can
also
see
that
the
same
Exception
t
yp
e
serv
es
to
represen
t
an
exception,
regardless
of
the
t
yp
e
in
to
whic
h
the
exception
is
em
b
edded.
The
previously-primitiv
e
function
error
can
no
w
readily
b
e
dened
using
raise
:
error
::
String
->
a
error
str
=
raise
(UserError
str)
Next,
w
e
need
to
b
e
able
to
catc
h
exceptions.
The
new,
primitiv
e
function
getException
tak
es
a
v
alue,
and
deter-
mines
whether
or
not
it
is
an
exceptional
v
alue

:
getException
::
a
->
ExVal
a

W
e
will
see
later
that
there
is
a
fundamen
tal
problem
with
giv-
ing
getException
this
t
yp
e,
but
w
e
defer
discussion
of
this
p
oin
t
to
Section
..
In
eect,
getException
reies
the
implicit
presence
or
ab-
sence
of
an
exception
in
its
argumen
t
to
an
explicit
dis-
criminated
union,
represen
ted
b
y
the
new
Prelude
data
t
yp
e
ExVal
:
data
ExVal
a
=
OK
a
|
Bad
Exception
Here
is
an
example
of
ho
w
getException
migh
t
b
e
used:
case
getException
(goop
x)
of
OK
val
->
normal_case
val
Bad
exn
->
recovery_case
exn
Here,
getException
catc
hes
an
y
exception
raised
while
goop
is
ev
aluated,
and
presen
ts
the
result
as
a
v
alue
of
t
yp
e
ExVal
.
The
case
expression
scrutinises
that
v
alue
and
tak
es
appro-
priate
action.
.
Propagation
The
whole
p
oin
t
of
exceptions
is,
of
course,
that
they
propa-
gate
automatically
.
So
in
teger
addition,
for
example,
should
deliv
er
an
exceptional
v
alue
if
either
of
its
argumen
ts
is
an
exceptional
v
alue.
In
a
lazy
language,
ho
w
ev
er,
w
e
ha
v
e
to
re-examine
our
notion
of
propagation.
In
particular,
an
exceptional
v
alue
migh
t
lurk
inside
an
unev
aluated
function
argumen
t
or
data
structure.
F
or
example,
consider
the
zipWith
function:
zipWith
f
[]
[]
=
[]
zipWith
f
(x:xs)
(y:ys)
=
f
x
y
:
zipWith
f
xs
ys
zipWith
f
xs
ys
=
error
"Unequal
lists"
A
call
to
zipWith
ma
y
return
an
exception
v
alue
directly
|
for
example,
zipWith
(+)
[]
[].
A
call
to
zipWith
ma
y
also
return
a
list
with
an
exception
v
alue
at
the
end
|
for
example,
zipWith
(+)
[]
[,].
Finally
,
it
ma
y
deliv
er
a
list
whose
spine
is
fully
dened,
but
some
of
whose
elemen
ts
are
exceptional
v
alues
|
for
example
zipWith
(/)
[,]
[,0].
T
o
rep
eat:
it
is
values
not
c
al
ls
that
ma
y
b
e
exceptional,
and
exceptional
v
alues
ma
y
,
for
example,
hide
inside
lazy
data
structures.
T
o
b
e
sure
that
a
data
structure
con
tains
no
exceptional
v
alues
one
m
ust
force
ev
aluation
of
all
the
elemen
ts
of
that
structure
(this
can
b
e
done
using
Hask
ell's
built-in
seq
function).
.
Implemen
tation
One
adv
an
tage
of
the
story
so
far
is
that
it
is
readily
,
and
c
heaply
,
implemen
table.
W
e
certainly
do
not
w
an
t
the
space
and
time
cost
of
explicitly
tagging
ev
ery
v
alue
with
an
in-
dication
of
whether
it
is
\normal"
or
\exceptional".
F
ortu-
nately
,
the
standard
exception-handling
mec
hanisms
from
pro
cedural
languages
w
ork
p
erfectly
w
ell:

getException
forces
the
ev
aluation
of
its
argumen
t
to
head
normal
form;
b
efore
it
b
egins
this
ev
aluation,
it
marks
the
ev
aluation
stac
k
in
some
w
a
y
.

raise
ex
simply
trims
the
stac
k
to
the
top-most
getException
mark,
and
returns
Bad
ex
as
the
result


of
getException.

If
the
ev
aluation
of
the
argumen
t
to
getException
completes
without
pro
v
oking
a
call
to
raise,
then
getException
returns
OK
val,
where
val
is
the
v
alue
of
the
argumen
t.
Actually
,
matters
are
not
quite
as
simple
as
w
e
suggest
here.
In
particular,
trimming
the
stac
k
after
a
call
(raise
ex)
w
e
m
ust
b
e
careful
to
o
v
erwrite
eac
h
th
unk
that
is
under
ev
alu-
ation
with
(raise
ex).
That
w
a
y
,
if
the
th
unk
is
ev
aluated
again,
the
same
exception
will
b
e
raised
again,
whic
h
is
as
it
should
b
e

.
The
details
are
describ
ed
b
y
[
],
and
need
not
concern
us
here.
The
main
p
oin
t
is
that
the
eciency
of
programs
that
do
not
in
v
ok
e
exceptions
is
unaected.
Indeed,
the
eciency
of
an
y
function
that
do
es
not
in
v
ok
e
exceptions
explicitly
is
unaected.
Notice
that
an
exceptional
v
alue
b
ehaves
as
a
rst
class
v
alue,
but
it
is
nev
er
explicitly
r
epr
esente
d
as
suc
h.
When
an
exception
o
ccurs,
instead
of
building
a
v
alue
that
represen
ts
it,
w
e
lo
ok
for
the
exception
handler
righ
t
a
w
a
y
.
The
seman
tic
mo
del
(exceptional
v
alues)
is
quite
dieren
t
from
the
implemen
tation
(ev
aluation
stac
ks
and
stac
k
trim-
ming).
The
situation
is
similar
to
that
with
lazy
ev
aluation:
a
v
alue
ma
y
b
ehave
as
an
innite
list,
but
it
is
certainly
nev
er
explicitly
r
epr
esente
d
as
suc
h.
.
A
problem
and
its
solution
There
is
a
w
ell-kno
wn
dicult
y
with
the
approac
h
w
e
ha
v
e
just
describ
ed:
it
in
v
alidates
man
y
useful
transformations.
F
or
example,
in
teger
addition
should
b
e
comm
utativ
e;
that
is,
e

+e

=
e

+e

.
But
what
are
w
e
to
mak
e
of
this
expres-
sion?
getException
((/0)
+
(error
"Urk"))
Do
es
it
deliv
er
DivideByZero
or
UserError
"Urk"?
Urk
in-
deed!
There
are
t
w
o
w
ell
kno
wn
w
a
ys
to
address
this
prob-
lem,
and
one
more
cunning
one
whic
h
w
e
shall
adopt:

Fix
the
ev
aluation
order,
as
part
of
the
language
se-
man
tics.
F
or
example,
the
seman
tics
could
state
that
+
ev
aluates
its
rst
argumen
t
rst,
so
that
if
its
rst
ar-
gumen
t
is
exceptional
then
that's
the
exception
that
is
returned.
This
is
the
most
common
approac
h,
adopted
b
y
(among
others)
ML,
FL,
and
some
prop
osals
for
Hask
ell
[
].
It
giv
es
rise
to
a
simple
seman
tics,
but
has
the
V
ery
Bad
F
eature
that
it
in
v
alidates
man
y
useful
transformations
|
in
particular,
ones
that
alter
the
order
of
ev
aluation.
This
loss
of
transformations
is
a
serious
w
eakness.
Williams,
Aik
en,
and
Wimmers
giv
e
n
umerous
exam-
ples
of
ho
w
the
presence
of
exceptions
can
seriously
w
eak
en
the
transformation
algebra
of
the
(strict)
lan-
guage
FL
[	
].
F
or
a
lazy
language,
the
loss
of
trans-
formations
w
ould
b
e
ev
en
more
of
a
catastrophe.
In
particular,
Hask
ell
compilers
p
erform
strictness
anal-
ysis
to
to
turn
call-b
y-need
in
to
call-b
y-v
alue.
This

Real
implemen
tations
o
v
erwrite
a
th
unk
with
a
\blac
k
hole"
when
its
ev
aluation
is
b
egun
to
a
v
oid
a
celebrated
space
leak
[].
That
is
wh
y
,
when
an
exception
causes
their
ev
aluation
to
b
e
abandoned,
they
m
ust
b
e
o
v
erwritten
with
something
more
informativ
e.
crucial
transformation
c
hanges
the
ev
aluation
order,
b
y
ev
aluating
a
function
argumen
t
when
the
function
is
called,
rather
than
when
the
argumen
t
is
demanded.
Rather
than
remo
v
e
suc
h
transformations
altogether,
optimising
compilers
often
p
erform
some
v
arian
t
of
ef-
fect
analysis,
to
iden
tify
the
common
case
where
excep-
tions
cannot
o
ccur
(e.g.
[
]).
They
use
this
informa-
tion
to
enable
the
otherwise-in
v
alid
transformations.
Williams,
Aik
en,
and
Wimmers
describ
e
a
calculus
for
the
language
FL
that
expresses
the
absence
of
excep-
tions
as
a
sp
ecial
program
annotation;
they
can
then
giv
e
a
precise
c
haracterisation
of
the
transformation
algebra
of
this
augmen
ted
language
[	
].
What
all
these
approac
hes
ha
v
e
in
common
is
that
use-
ful
transformations
are
disabled
if
the
sub-expressions
are
not
pro
v
ably
exception-free.

Go
non-deterministic.
That
is,
declare
that
+
mak
es
a
non-deterministic
c
hoice
of
whic
h
argumen
t
to
ev
al-
uate
rst.
Then
the
compiler
is
free
to
mak
e
that
c
hoice
ho
w
ev
er
it
lik
es.
Alas,
this
approac
h
exp
oses
non-determinism
in
the
source
language,
whic
h
also
in
v
alidates
useful
la
ws.
In
particular,

reduction
is
not
v
alid
an
y
more.
F
or
example,
consider:
let
x
=
(/0)
+
(error
"Urk")
in
getException
x
==
getException
x
As
it
stands,
the
v
alue
of
this
expression
is
presumably
True.
But
if
the
t
w
o
o
ccurrences
of
x
are
eac
h
replaced
b
y
x's
righ
t
hand
side,
then
the
non-deterministic
+
migh
t
(in
principle)
mak
e
a
dieren
t
c
hoice
at
its
t
w
o
o
ccurrences,
so
the
expression
could
b
e
False.
W
e
coun
t
this
to
o
high
a
price
to
pa
y
.

The
more
cunning
c
hoice
is
to
return
b
oth
exceptions!
That
is,
w
e
redene
an
exceptional
v
alue
to
con
tain
a
set
of
exceptions,
instead
of
just
one;
and
+
tak
es
the
union
of
the
exception
sets
of
its
t
w
o
argumen
ts.
No
w
(/0)
+
(error
"Urk")
returns
an
exceptional
v
alue
including
b
oth
DivideByZero
and
UserError
"Urk",
and
(seman
tically)
it
will
do
so
regardless
of
the
order
in
whic
h
+
ev
aluates
its
argumen
ts.
The
b
eaut
y
of
this
approac
h
is
that
almost
al
l
tr
ans-
formations
r
emain
valid,
ev
en
in
the
presence
of
excep-
tions
(Section
.
discusses
the
\almost").
No
analysis
required!
.
Fixing
getException
The
allegedly
cunning
c
hoice
ma
y
ha
v
e
xed
the
comm
uta-
tivit
y
of
+,
but,
no
w
that
an
exceptional
v
alue
can
con
tain
a
set
of
exceptions,
w
e
m
ust
revisit
the
question
of
what
getException
should
do.
There
are
t
w
o
p
ossibilities.
One
alternativ
e
is
for
getException
to
return
the
complete
set
of
exceptions
(if
an
y)
in
its
argumen
t
v
alue.
This
w
ould
b
e
an
absolute
disaster
from
an
implemen
tation
p
oin
t
of
view!
It
w
ould
mean
that
the
implemen
tation
w
ould
really
ha
v
e
to
main
tain
a
set
of
exceptions;
if
the
rst
argumen
t
to
+
failed,
then
the
second
w
ould
ha
v
e
to
b
e
ev
aluated
an
yw
a
y
so
that
an
y
exceptions
in
it
could
b
e
gathered
up.


The
cunning
c
hoice
is
only
cunning
b
ecause
there
is
another
alternativ
e:
getException
can
c
ho
ose
just
one
mem
b
er
of
the
set
of
exceptions
to
return.
Of
course,
that
simply
exp
oses
the
non-determinism
again,
but
w
e
can
emplo
y
a
no
w-standard
tric
k
[
]:
put
getException
in
the
IO
monad.
Th
us,
w
e
giv
e
getException
the
follo
wing
t
yp
e:
getException
::
a
->
IO
(ExVal
a)
T
o
mak
e
sense
of
this
new
denition,
w
e
digress
briey
to
in-
tro
duce
Hask
ell's
IO
monad.
In
Hask
ell,
a
v
alue
of
t
yp
e
IO
t
is
a
c
omputation
that
migh
t
p
erform
some
input/output,
b
e-
fore
ev
en
tually
returning
a
v
alue
of
t
yp
e
t.
A
v
alue
of
t
yp
e
IO
t
is
a
rst-class
v
alue
|
it
can
b
e
passed
as
an
argu-
men
ts,
stored
in
a
data
structure
|
and
ev
aluating
it
has
no
side
eects.
Only
when
it
is
p
erforme
d
do
es
it
ha
v
e
an
eect.
An
en
tire
Hask
ell
program
is
a
single
v
alue
of
t
yp
e
IO
();
to
run
the
program
is
to
p
erform
the
sp
ecied
com-
putation.
F
or
example,
here
is
a
complete
Hask
ell
program
that
gets
one
c
haracter
from
standard
input
and
ec
ho
es
it
to
standard
output

:
main
::
IO
()
main
=
getChar
>>=
(\ch
->
putChar
ch
>>=
(\()
->
return
()
))
The
t
yp
es
of
the
v
arious
functions
in
v
olv
ed
are
as
follo
ws:
(>>=)
::
IO
a
->
(a
->
IO
b)
->
IO
b
return
::
a
->
IO
a
getChar
::
IO
Char
putChar
::
Char
->
IO
()
The
com
binators
>>=
glues
together
t
w
o
IO
computations
in
sequence,
passing
the
result
from
the
rst
to
the
second.
return
do
es
no
input/output,
simply
returning
its
argu-
men
t.
getChar
gets
a
c
haracter
from
the
standard
input
and
returns
it;
putChar
do
es
the
rev
erse.
When
main
is
p
er-
formed,
it
p
erforms
getChar
,
reading
a
c
haracter
from
stan-
dard
input,
and
then
p
erforms
the
computation
obtained
b
y
applying
the
\ch
->
...
abstraction
to
the
c
haracter,
in
this
case
putChar
ch.
A
more
complete
discussion
of
monadic
I/O
can
b
e
found
in
[
].
No
w
w
e
return
to
the
t
yp
e
of
getException
.
By
giving
it
an
IO
t
yp
e
w
e
allo
w
getException
to
p
erform
input/output.
Hence,
when
c
ho
osing
whic
h
of
the
exceptions
in
the
set
to
c
ho
ose,
getException
is
free
(although
absolutely
not
re-
quired)
to
consult
some
external
oracle
(the
FT
Share
In-
dex,
sa
y).
Eac
h
call
to
getException
can
mak
e
a
dieren
t
c
hoice;
the
same
call
to
getException
in
dieren
t
runs
of
the
same
program
can
mak
e
a
dieren
t
c
hoice;
and
so
on.
Beta
reduction
remains
v
alid.
F
or
example
the
meaning
of:
let
x
=
(/0)
+
error
"Urk"
in
getException
x
>>=
(\v
->
getException
x
>>=
(\v
->
return
(v==v)))
is
unaected
if
b
oth
o
ccurrences
of
x
are
replaced
b
y
x's
righ
t
hand
side,
th
us:

The
\\"
is
Hask
ell's
notation
for

getException
((/0)
+
error
"Urk")
>>=
(\v
->
getException
((/0)
+
error
"Urk")
>>=
(\v
->
return
(v==v)))
Wh
y?
Because
whether
or
not
this
substitution
is
made,
getException
will
b
e
p
erformed
t
wice,
making
an
inde-
p
enden
t
non-deterministic
c
hoice
eac
h
time.
Lik
e
an
y
IO
computation,
(getException
e)
can
b
e
shared,
and
ev
en
ev
aluated,
without
actually
p
erforming
the
nondeterminis-
tic
c
hoice.
That
only
happ
ens
when
the
computation
is
p
er-
forme
d.
The
really
nice
thing
ab
out
this
approac
h
is
that
the
stac
k-
trimming
implemen
tation
do
es
not
ha
v
e
to
c
hange.
The
set
of
exc
eptions
asso
ciate
d
with
an
exc
eptional
value
is
r
epr
e-
sente
d
by
a
single
memb
er,
namely
the
exception
that
hap-
p
ens
to
b
e
encoun
tered
rst.
getException
w
orks
just
as
b
e-
fore:
mark
the
ev
aluation
stac
k,
and
ev
aluate
its
argumen
t.
Successiv
e
runs
of
a
program,
using
the
same
compiler
opti-
misation
lev
el,
will
in
practice
giv
e
the
same
b
eha
viour;
but
if
the
program
is
recompiled
with
dieren
t
optimisation
set-
tings,
then
indeed
the
order
of
ev
aluation
migh
t
c
hange,
so
a
dieren
t
exception
migh
t
b
e
encoun
tered
rst,
and
hence
the
exception
returned
b
y
getException
migh
t
c
hange.
The
idea
of
using
a
single
represen
tativ
e
to
stand
for
a
set
of
v
alues,
from
whic
h
a
non-deterministic
c
hoice
is
made,
is
based
on
an
old
pap
er
b
y
Hughes
and
O'Donnell
[
].
Our
con
tribution
is
to
apply
this
idea
in
the
setting
of
exception
handling.
The
k
ey
observ
ation
is
that
non-determinism
in
the
exc
eptions
can
b
e
k
ept
separate
from
non-determinism
in
the
normal
values
of
a
program.

Seman
tics
So
far
w
e
ha
v
e
reasoned
informally
.
In
this
section
w
e
giv
e
a
precise
seman
tics
to
(a
fragmen
t
of
)
Hask
ell
augmen
ted
with
exceptions.
Here
are
t
w
o
diculties.

Consider
loop
+
error
"Urk"
Here,
loop
is
an
y
expression
whose
ev
aluation
di-
v
erges.
It
migh
t
b
e
declared
lik
e
this:
loop
=
f
True
where
f
x
=
f
(not
x)
So,
do
es
(loop
+
error
"Urk")
lo
op
forev
er,
or
do
es
it
return
an
exceptional
v
alue?
Answ
er:
it
all
dep
ends
on
the
ev
aluation
order
of
+.
As
is
often
the
case,
b
ottom
m
uddies
the
w
aters.

Is
the
follo
wing
equation
true?
case
x
of
(a,b)
->
case
y
of
(p,q)
->
e
=
case
y
of
(p,q)
->
case
x
of
(a,b)
->
e


In
Hask
ell
the
answ
er
is
\y
es";
since
w
e
are
going
to
ev
aluate
b
oth
x
and
y,
it
do
esn't
matter
whic
h
order
w
e
ev
aluate
them
in.
Indeed,
the
whole
p
oin
t
of
strict-
ness
analysis
is
to
gure
out
whic
h
things
are
sure
to
b
e
ev
aluated
in
the
end,
so
that
they
can
b
e
ev
aluated
in
adv
ance
[
].
But
if
x
and
y
are
b
oth
b
ound
to
ex-
ceptional
v
alues,
then
the
order
of
the
cases
clearly
determines
whic
h
exception
will
b
e
encoun
tered.
Un-
lik
e
the
+
case,
it
is
far
from
ob
vious
ho
w
to
com
bine
the
exceptional
v
alue
sets
for
x
and
y:
in
general
the
righ
t
hand
side
of
a
case
alternativ
e
migh
t
dep
end
on
the
v
ariables
b
ound
in
the
pattern,
and
it
w
ould
b
e
unpleasan
t
for
the
seman
tics
to
dep
end
on
that.
The
rest
of
this
section
giv
es
a
denotational
seman
tics
for
Hask
ell
extended
with
exceptions,
that
addresses
b
oth
of
these
problems.
W
e
solv
e
the
rst
b
y
iden
tifying
?
with
the
set
of
all
p
ossible
exceptions;
w
e
solv
e
the
latter
b
y
(seman
ti-
cally)
ev
aluating
the
case
alternativ
es
in
\exception-nding
mo
de".
.
Domains
First
w
e
describ
e
the
domain
[
[
]
]
that
is
asso
ciated
with
eac
h
Hask
ell
t
yp
e

.
W
e
use
a
rather
standard
monadic
translation,
for
a
monad
M,
dened
th
us:
M
t
=
t
?
+
P
(E
)
?
E
=
fDivideByZero
;
Overflow
;
UserError
;
:
:
:
g
The
\+"
in
this
equation
is
coalesced
sum;
that
is,
the
b
ot-
tom
elemen
t
of
[
[

]
]
?
is
coalesced
with
the
b
ottom
elemen
t
of
P
(E
)
?
.
The
set
E
is
the
set
of
all
the
p
ossible
sync
hronous
exceptions;
to
simplify
the
seman
tics
w
e
neglect
the
String
argumen
t
to
UserError
.
P
(E
)
is
the
lattice
of
all
subsets
of
E
,
under
the
ordering
s

v
s


s


s

That
is,
the
b
ottom
elemen
t
is
the
set
E
,
and
the
top
ele-
men
t
is
the
empt
y
set.
This
corresp
onds
to
the
idea
that
the
few
er
exceptions
that
are
in
the
exceptional
v
alue,
the
more
information
the
v
alue
con
tains.
The
least
informativ
e
v
alue
con
tains
all
exceptions.
This
en
tire
lattice
is
lifted,
b
y
adding
an
extra
b
ottom
elemen
t,
whic
h
w
e
also
iden
tify
with
a
set
of
exceptions:
?
=
E
[
fNonTermination
g
A
t
rst
w
e
distinguished
?
from
the
set
of
all
exceptions,
but
that
turns
out
not
to
w
ork.
Instead,
w
e
iden
tify
?
with
the
set
of
all
exceptions,
adding
one
new
constructor,
NonTermination
,
to
the
Exception
t
yp
e:
data
Exception
=
...
--
(as
before)
|
NonTermination
This
construction
of
P
(E
)
?
is
a
v
ery
standard
seman
tic
co
d-
ing
tric
k;
it
is
closely
analogous
to
a
canonical
represen
tation
of
the
Sm
yth
p
o
w
erdomain
o
v
er
a
at
domain,
giv
en
b
y
[
].
Here
is
an
alternativ
e,
and
p
erhaps
more
p
erspicuous,
w
a
y
to
dene
M,
in
whic
h
w
e
tag
\normal"
v
alues
with
O
k
,
and
e
::=
x
v
ariable
j
k
constan
t
j
e

e

application
j
x:e
abstraction
j
C
e

:
:
:
e
n
constructors
j
case
e
of
{
:
:
:
p
i
->r
i
;
:
:
:
}
matc
hing
j
raise
e
raise
exception
j
e

+
e

primitiv
es
j
fix
e
xp
oin
t
p
::=
C
x

:
:
:
x
n
pattern
Figure
:
Syn
tax
of
a
tin
y
language
\exceptional"
v
alues
(including
?)
with
B
ad:
M
t
=
fO
k
v
j
v

tg
[
fB
ad
s
j
s

E
g
[
fB
ad
(E
[
fNonTermination
g)g
One
migh
t
w
onder
what
sort
of
a
v
alue
B
ad
fg
is:
what
is
an
exceptional
v
alue
con
taining
the
empt
y
set
of
exceptions?
Indeed,
suc
h
a
v
alue
cannot
b
e
the
denotation
of
an
y
term,
but
w
e
will
see
shortly
that
it
is
nev
ertheless
a
v
ery
useful
v
alue
for
dening
the
seman
tics
of
case
and
for
reasoning
ab
out
it
(Section
.).
No
w
that
w
e
ha
v
e
constructed
the
exception
monad,
w
e
can
translate
Hask
ell
t
yp
es
in
to
domains
in
the
usual
w
a
y:
[
[
Int
]
]
=
M
Z
[
[


->

]
]
=
M
([
[


]
]
!
[
[

]
]
)
[
[
(

,

)
]
]
=
M
([
[


]
]

[
[


]
]
)
.
.
.
etc
.
.
.
W
e
refrain
from
giving
the
complete
enco
ding
for
arbitrary
recursiv
e
data
t
yp
es,
whic
h
is
complicated.
The
p
oin
t
is
that
w
e
simply
replace
the
normal
Hask
ell
monad,
namely
lifting,
with
our
new
monad
M.
.
Com
binators
Next,
w
e
m
ust
giv
e
the
denotation,
or
meaning,
of
eac
h
form
of
language
expression.
Figure

giv
es
the
syn
tax
of
the
small
language
w
e
treat
here.
The
denotation
of
an
expres-
sion
e
in
an
en
vironmen
t

is
written
[
[
e]
]
.
W
e
start
with
+:
[
[
e

+
e

]
]

=
v


v

if
O
k
v

=
[
[
e

]
]

and
O
k
v

=
[
[
e

]
]

=
B
ad
(S
([
[e

]
]
)
[
S
([
[e

]
]
))
otherwise
The
rst
equation
is
used
if
b
oth
argumen
ts
are
normal
v
al-
ues.
The
second
is
used
if
either
argumen
t
is
an
exceptional
v
alue,
in
whic
h
case
the
exceptions
from
the
t
w
o
argumen
ts
are
unioned.
W
e
use
the
auxiliary
function
S
(),
whic
h
re-
turns
the
empt
y
set
for
a
normal
v
alue,
and
the
set
of
ex-
ceptions
for
an
exceptional
v
alue:
S
(O
k
v
)
=
;
S
(B
ad
s)
=
s


The
auxiliary
function

simply
do
es
addition,
c
hec
king
for
o
v
ero
w:
v


v

=
O
k
(v

+
v

)
if
 

h
(v

+
v

)
h


=
B
ad
fOverflow
g
otherwise
The
denition
of
[
[
+]
]
is
monotonic
with
resp
ect
to
v,
as
it
m
ust
b
e.
The
fact
that
+
is
strict
in
b
oth
argumen
ts
is
a
consequence
of
the
fact
that
?
is
the
set
of
all
exceptions;
a
momen
t's
though
t
should
con
vince
y
ou
that
if
either
argu-
men
t
is
?
then
so
is
the
result.
Next,
w
e
deal
with
raise:
[
[
raise
e]
]
=
B
ad
s
if
B
ad
s
=
[
[
e]
]
=
B
ad
fC
g
if
O
k
C
=
[
[
e]
]
Th
us
equipp
ed,
w
e
can
no
w
understand
the
seman
tics
of
the
problematic
expression
giv
en
ab
o
v
e:
loop
+
error
"Urk"
Its
meaning
is
the
union
of
the
set
of
all
exceptions
(whic
h
is
the
v
alue
of
loop),
and
the
singleton
set
UserError
"Urk",
whic
h
is
of
course
just
?,
the
set
of
all
exceptions.
The
rules
for
function
abstraction
and
application
are:
[
[
x:e]
]
=
O
k
(y
:[
[
e]
][y
=x])
[
[
e

e

]
]
=
f
([
[
e

]
]
)
if
O
k
f
=
[
[
e

]
]

=
B
ad(s
[
S
([
[e

]
]
)
if
B
ad
s
=
[
[
e

]
]

A
lam
b
da
abstraction
is
a
normal
v
alue;
that
is
x:?
=
?.
The
(more
purist)
iden
tication
of
these
t
w
o
v
alues
is
imp
ossible
to
implemen
t:
ho
w
can
getException
distinguish
x:?
from
x:v
,
where
v
=
??
F
ortunately
,
in
Hask
ell
x:?
and
?
are
indeed
distinct
v
alues.
Applying
a
normal
function
to
a
v
alue
is
straigh
tforw
ard,
but
matters
are
more
in
teresting
if
the
function
is
an
ex-
ceptional
v
alue.
In
this
case
we
must
union
its
exc
eption
set
with
that
of
its
ar
gument,
b
ecause
under
some
circum-
stances
(notably
if
the
function
is
strict)
w
e
migh
t
legiti-
mately
ev
aluate
the
argumen
t
rst;
if
w
e
neglected
to
union
in
the
argumen
t's
exceptions,
the
seman
tics
w
ould
not
allo
w
this
standard
optimisation.
That
is
wh
y
w
e
do
not
use
the
simpler
denition:
[
[
e

e

]
]

=
f
([
[
e

]
]
)
if
O
k
f
=
[
[
e

]
]

=
B
ad
s
if
B
ad
s
=
[
[
e

]
]

W
e
ha
v
e
traded
transformations
for
precision.
Notice,
ho
w-
ev
er,
that
w
e
m
ust
not
union
in
the
argumen
t's
exceptions
if
the
function
is
a
normal
v
alue,
or
else
w
e
w
ould
lose

reduction;
consider
(x:
)(/0)
The
rules
for
constan
ts
and
constructor
applications
are
sim-
ple;
they
b
oth
return
normal
v
alues.
Constructors
are
non-
strict,
and
hence
do
not
propagate
exceptions
in
their
argu-
men
ts.
V
ariables
and
xp
oin
ts
are
also
easy
.
[
[
k
]
]

=
O
k
k
[
[
C
e

:
:
:
e
n
]
]

=
O
k
(C
([
[e

]
]
)
:
:
:
([
[
e
n
]
]
))
[
[
x]
]
=
(x)
[
[
fix
e]
]

=

G
k
=0
([
[e]
]
)
k
(?)
.
case
expressions
Hask
ell
con
tains
case
expressions,
so
w
e
m
ust
giv
e
them
a
seman
tics.
Here
is
the
sligh
tly
surprising
rule:
[
[
case
e
of
{p
i
->
r
i
}]
]

=
[
[
r
i
]
]
[v
=p
i
]
if
O
k
v
=
[
[
e]
]
and
v
matc
hes
p
i
=
B
ad
(s
[
(
S
i
S
([
[r
i
]
]
[B
ad
fg=p
i
])))
if
B
ad
s
=
[
[
e]
]
The
rst
case
is
the
usual
one:
if
the
case
scrutinee
ev
alu-
ates
to
a
\normal"
v
alue
v
,
then
select
the
appropriate
case
alternativ
e.
The
notation
is
a
little
informal:
[v
=p
i
]
means
the
en
vironmen
t

with
the
free
v
ariables
of
the
pattern
p
i
b
ound
to
the
appropriate
comp
onen
ts
of
v
.
The
second
equation
is
the
in
teresting
one.
If
the
scrutinee
turns
out
to
b
e
a
set
of
exceptions
(whic
h,
recall,
includes
?),
the
ob
vious
thing
to
do
is
to
return
just
that
set
|
but
doing
so
w
ould
in
v
alidate
the
case
-switc
hing
transfor-
mation.
In
tuitiv
ely
,
the
seman
tics
m
ust
explore
all
the
w
a
ys
in
whic
h
the
implemen
tation
migh
t
deliv
er
an
exception,
so
it
m
ust
\ev
aluate"
all
the
branc
hes
an
yw
a
y
,
in
\exception-
nding
mo
de".
W
e
mo
del
this
b
y
taking
the
denotations
of
all
the
righ
t
hand
sides,
binding
eac
h
of
the
pattern-b
ound
v
ariables
to
the
strange
v
alue
B
ad
fg.
Then
w
e
union
to-
gether
all
the
exception
sets
that
result,
along
with
the
ex-
ception
set
from
the
scrutinee.
The
idea
is
exactly
the
same
as
in
the
sp
ecial
case
of
+,
and
function
application:
if
the
rst
argumen
t
of
+
raises
an
exception
w
e
still
union
in
the
exceptions
from
the
second
argumen
t.
Here,
if
the
case
scru-
tinee
raises
an
exception,
w
e
still
union
in
the
exceptions
from
the
alternativ
es.
Remem
b
er
that
there
is
no
implication
that
an
implemen-
tation
will
do
an
ything
other
than
return
the
rst
exception
that
happ
ens
to
b
e
encoun
tered.
The
rather
curious
seman-
tics
is
necesary
,
though,
to
v
alidate
transformations
that
c
hange
the
order
of
ev
aluation,
suc
h
as
that
giv
en
at
the
b
eginning
of
Section
.
.
Seman
tics
of
getException
So
far
w
e
ha
v
e
not
men
tioned
getException
.
The
seman-
tics
of
op
erations
in
the
IO
monad,
suc
h
as
getException
,
ma
y
in
v
olv
e
input/output
or
non-determinism.
The
most
straigh
tforw
ard
w
a
y
of
mo
delling
these
asp
ects
is
b
y
giv-
ing
an
op
er
ational
seman
tics
for
the
IO
la
y
er,
in
con
trast
to
the
denotational
seman
tics
w
e
ha
v
e
giv
en
for
the
purely-
functional
la
y
er.
W
e
giv
e
the
op
erational
seman
tics
as
follo
ws.
F
rom
a
seman-
tic
p
oin
t
of
view
w
e
regard
IO
as
an
algebraic
data
t
yp
e
with
constructors
return
,
>>=,
putChar
,
getChar
,
getException
.
The
b
eha
viour
of
a
program
is
the
set
of
traces
obtained
from
the
follo
wing
lab
elled
transition
system,
whic
h
acts
on
the
denotation
of
the
program.
One
adv
an
tage
of
this
presen-
tation
is
that
it
scales
to
other
extensions,
suc
h
as
adding
concurrency
to
the
language
[
].


Here
are
the
structural
transition
rules:
v

!
v

(v

>>=
k
)
!
(v

>>=
k
)
((return
v
)
>>=
k
)
!
(k
v
)
The
rst
ensures
that
transitions
can
o
ccur
inside
the
rst
op
erand
of
the
>>=
constructor;
the
second
explains
that
a
return
constructor
just
passes
its
v
alue
to
the
second
argu-
men
t
of
the
enclosing
>>=.
The
rules
for
input/output
are
no
w
quite
simple:
getChar
?c
!
return
c
putChar
c
!c
!
return
()
The
\?c"
on
top
of
the
arro
w
indicates
that
the
transition
tak
es
place
b
y
reading
a
c
haracter
c
from
the
en
vironmen
t;
and
in
v
ersely
for
\!c".
No
w
w
e
can
get
to
the
seman
tics
of
exceptions.
The
rules
are:
getException
(O
k
v
)
!
return
(OK
(O
k
v
))
getException
(B
ad
s)
!
return
(Bad
x)
if
x

s
getException
(B
ad
s)
!
getException
(B
ad
s)
if
NonTermination

s
If
getException
scrutinises
a
\normal"
v
alue,
it
just
returns
it,
wrapp
ed
in
an
OK
constructor.
F
or
\exceptional"
v
alues,
there
are
t
w
o
c
hoices:
either

pic
k
an
arbitrary
mem
b
er
of
the
set
of
exceptions
and
return
it,
or

if
NonTermination
is
in
the
set
of
exceptions,
then
mak
e
a
transition
to
the
same
state.
The
transition
rules
for
getException
are
delib
erately
non-
deterministic.
In
particular,
if
the
argumen
t
to
getException
is
?,
then
getException
ma
y
div
erge,
or
it
ma
y
return
an
arbitrary
exception.
T
o
execute
a
Hask
ell
program,
one
p
erforms
the
computa-
tion
main
,
whic
h
has
t
yp
e
IO
().
In
the
presence
of
excep-
tions,
the
v
alue
returned
migh
t
no
w
b
e
B
ad
x,
rather
than
O
k
().
This
simply
corresp
onds
to
an
uncaugh
t
exception,
whic
h
the
implemen
tation
should
rep
ort.
.
T
ransformations
Our
o
v
erall
goal
is
to
add
exceptions
to
Hask
ell
without
losing
useful
transformations.
Y
et
it
cannot
b
e
true
that
w
e
lose
no
transformations.
F
or
example,
in
Hask
ell
as
it
stands,
the
follo
wing
equation
holds:
error
"This"
=
error
"That"
Wh
y?
Because
b
oth
are
seman
tically
equal
to
?.
In
our
seman
tics
this
equalit
y
no
longer
holds
|
and
righ
tly
not!
So
our
seman
tics
correctly
distinguishes
some
expressions
that
Hask
ell
curren
tly
iden
ties.
Some
transformations
that
are
iden
tities
in
Hask
ell
b
ecome
renemen
ts
in
our
new
system.
Consider:
l
hs
=
(case
e
of
{
True
->
f;
False
->
g
})
x
r
hs
=
case
e
of
{
True
->
(f
x);
False
->
(g
x)
}
Using
e
=
raise
E
,
x
=
raise
X,
and
f
=
g
=
v:,
w
e
get
[
[l
hs]
]

=
B
ad
fE
;
X
g
but
[
[
r
hs]
]

=
B
ad
fE
g.
Hence,
l
hs
v
r
hs,
but
not
l
hs
=
r
hs.
W
e
argue
that
it
is
legitimate
to
p
erform
a
transformation
that
increases
information
|
in
this
case,
c
hanging
l
hs
to
r
hs
reduces
uncertain
t
y
ab
out
whic
h
exceptions
can
b
e
raised.
W
e
curren
tly
lac
k
a
systematic
w
a
y
to
sa
y
whic
h
iden
tities
con
tin
ue
to
hold,
whic
h
turn
in
to
renemen
ts,
and
whic
h
no
longer
hold.
W
e
conjecture
that
the
lost
la
ws
deserv
e
to
b
e
lost,
and
that
optimising
transformations
are
either
iden
tities
or
renemen
ts.
It
w
ould
b
e
in
teresting
to
try
to
formalise
and
pro
v
e
this
conjecture.

V
ariations
on
the
theme
.
Async
hronous
exceptions
All
the
exceptions
w
e
ha
v
e
discussed
so
far
are
sync
hronous
exceptions
(Section
).
If
the
ev
aluation
of
an
expression
yields
a
set
of
sync
hronous
exceptions,
then
another
ev
al-
uation
of
the
same
expression
will
yield
the
same
set.
But
what
ab
out
async
hronous
exceptions,
suc
h
as
in
terrupts
and
resource-related
failures
(e.g.
timeout,
stac
k
o
v
ero
w,
heap
exhaustion)?
They
dier
from
sync
hronous
exceptions
in
that
they
p
erhaps
will
not
recur
(at
all)
if
the
same
pro-
gram
is
run
again.
It
is
ob
viously
inappropriate
to
regard
suc
h
exceptions
as
part
of
the
denotation
of
an
expression.
F
ortunately
,
they
can
t
in
the
same
general
framew
ork.
W
e
ha
v
e
to
enric
h
the
Exception
t
yp
e
with
constructors
indicating
the
cause
of
the
exception.
Then
w
e
simply
add
to
getException's
abilities.
Since
getException
is
in
the
IO
monad,
it
can
easily
sa
y
\if
the
ev
aluation
of
m
y
argumen
t
go
es
on
for
to
o
long,
I
will
terminate
ev
aluation
and
return
Bad
TimeOut",
and
similarly
for
in
terrupts
and
so
on.
W
e
express
this
formally
as
follo
ws:
getException
v
|x
!
return
(Bad
x)
if
x
is
an
async
hronous
exception
The
|x
ab
o
v
e
the
arro
w
indicates
that
the
transition
ma
y
tak
e
place
only
when
an
async
hronous
ev
en
t
x
is
receiv
ed
b
y
the
ev
aluator.
Notice
that
v
migh
t
not
b
e
an
exceptional
v
alue
|
it
migh
t
b
e
sa
y
,

|
but
if
the
ev
en
t
x
is
receiv
ed,
getException
is
nev
ertheless
free
to
discard
v
and
return
the
async
hronous
exception
instead.
In
the
case
of
a
k
ey-
b
oard
in
terrupt,
the
ev
en
t
ControlC
is
injected;
in
the
case
of
timeout,
some
presumed
external
monitoring
system
in-
jects
the
ev
en
t
TimeOut
if
ev
aluation
tak
es
to
o
long;
and
so
on.
There
is
a
fascinating
wrinkle
in
the
implemen
tation
of
asyn-
c
hronous
exceptions:
when
trimming
the
stac
k,
w
e
m
ust
o
v
erwrite
eac
h
th
unk
under
ev
aluation
with
a
kind
of
\re-
sumable
con
tin
uation",
rather
than
a
computation
whic
h
raises
the
exception
again.
The
details
are
in
[
].
	

.
Detectable
b
ottoms
There
are
some
sorts
of
div
ergence
that
are
detectable
b
y
a
compiler
or
its
run
time
system.
F
or
example,
supp
ose
that
black
w
as
declared
lik
e
this:
black
=
black
+

Here,
black
is
readily
detected
as
a
so-called
\blac
k
hole"
b
y
man
y
graph
reduction
implemen
tations.
Under
these
cir-
cumstances,
getException
black
is
p
ermitted,
but
not
re-
quired,
to
return
Bad
NonTermination
instead
of
going
in
to
a
lo
op!
Whether
or
not
it
do
es
so
is
an
implemen
tation
c
hoice
|
p
erhaps
implemen
tations
will
comp
ete
on
the
skill
with
whic
h
they
detect
suc
h
errors.
.
Fictitious
exceptions
There
is
actually
a
con
tin
uum
b
et
w
een
our
seman
tics
and
the
\xed
ev
aluation
order"
seman
tics,
whic
h
fully
deter-
mines
whic
h
exception
is
raised.
As
one
mo
v
es
along
the
sp
ectrum
to
w
ards
our
prop
osal,
more
compiler
transforma-
tions
b
ecome
v
alid
|
but
there
is
a
price
to
pa
y
.
That
price
is
that
the
seman
tics
b
ecomes
v
aguer
ab
out
whic
h
ex-
ceptions
can
b
e
raised,
and
ab
out
when
non-termination
can
o
ccur.
Our
view
is
that
w
e
should
optimise
for
the
no-
exception
case,
accepting
that
if
something
do
es
go
wrong
in
the
program,
then
the
seman
tics
do
es
not
guaran
tee
v
ery
precisely
what
exception
will
sho
w
up.
An
extreme,
and
sligh
tly
troubling,
case
is
this:
getException
loop
Since
loop
has
v
alue
?,
getException
is,
according
to
our
seman
tics,
justied
in
returning
Bad
DivideByZero,
or
some
other
quite
ctitious
exception
|
and
in
principle
a
compiler
renemen
t
migh
t
do
the
same.
W
e
sough
t
a
w
a
y
to
giv
e
loop
the
denotation
B
ad
fNonTermination
g
rather
than
(the
less
informativ
e)
?,
but
w
e
kno
w
of
no
consisten
t
w
a
y
to
do
so.
The
mo
delling
of
non-termination
to
include
all
other
b
eha
viours
is
c
haracteristic
of
the
de-
notational
seman
tics
of
non-determinism.
It
means
that
set
inclusion
giv
es
a
simple
in
terpretation
of
program
correct-
ness,
encompassing
b
oth
safet
y
and
liv
eness
prop
erties.
It
ensures
that
recursion
can
b
e
dened
as
the
w
eak
est
xed
p
oin
t
of
a
monotonic
function,
and
that
this
xed
p
oin
t
can
b
e
computed
as
the
limit
of
a
(set-wise)
descending
c
hain
of
appro
ximations.
But
what
is
more
imp
ortan
t
for
our
pur-
p
oses
is
that
it
gives
maximal
fr
e
e
dom
to
the
c
ompiler,
by
assuming
that
non-termination
is
never
what
the
pr
o
gr
am-
mer
intends

.
An
op
erational
seman
tics
w
ould
mo
del
more
precisely
what
happ
ens,
and
hence
w
ould
not
suer
from
the
problem
of

Indeed,
there
are
a
n
um
b
er
of
situations
in
whic
h
it
is
useful
to
b
e
able
to
assume
that
a
v
alue
is
not
?.
F
or
example,
if
v
is
not
?,
then
the
follo
wing
la
w
holds:
case
v
of
{
True
->
e;
False
->
e
}
=
e
Our
compiler
has
a
ag
-fno-pedantic-bottoms
that
enables
suc
h
transformations,
in
exc
hange
for
the
programmer
undertaking
the
pro
of
obligation
that
no
sub-expression
in
the
program
has
v
alue
?.
ctitious
exceptions.
Arguably
,
for
reasoning
ab
out
div
er-
gen
t
programs,
the
programmer
should
use
an
op
erational
seman
tics
an
yw
a
y
.
Because,
in
the
end,
it
seems
unlik
ely
that
a
compiler
will
gratuitously
rep
ort
a
ctitious
excep-
tion
when
the
program
gets
in
to
a
lo
op,
so
this
seman
tic
tec
hnicalit
y
is
unlik
ely
to
ha
v
e
practical
consequences.
.
Pure
functions
on
exceptional
v
alues
Is
it
p
ossible
to
do
an
ything
with
an
exceptional
v
alue
other
than
c
ho
ose
an
exception
from
it
with
getException?
F
ol-
lo
wing
[
],
one
p
ossibilit
y
suggests
itself
as
a
new
primitiv
e
function
(i.e.
one
not
denable
with
the
primitiv
es
so
far
describ
ed):
mapException
::
(Exception
->
Exception)
->
a
->
a
Seman
tically
,
mapException
applies
its
functional
argumen
t
to
eac
h
mem
b
er
of
the
set
of
exceptions
(if
an
y)
in
its
sec-
ond
argumen
t;
it
do
es
nothing
to
normal
v
alues.
F
rom
an
implemen
tation
p
oin
t
of
view,
it
applies
the
function
to
the
sole
represen
tativ
e
(if
an
y)
of
that
set.
Here's
an
example
of
using
mapException
to
catc
h
all
exceptions
in
e
and
raise
UserError
"Urk"
instead:
mapException
(\x
->
UserError
"Urk")
e
Notice
that
mapException
do
es
not
need
to
b
e
in
the
IO
monad
to
preserv
e
determinism.
In
short,
mapException
raises
no
new
tec
hnical
diculties,
although
its
usefulness
and
desirabilit
y
migh
t
b
e
debatable.
mapException
maps
one
kind
of
exception
to
another,
but
it
do
esn't
let
us
get
from
exceptions
bac
k
in
to
normal
v
alues.
Is
it
p
ossible
to
go
further?
Is
it
p
ossible,
for
example,
to
ask
\is
this
an
exceptional
v
alue"?
isException
::
a
->
Bool
(It
w
ould
b
e
easy
to
dene
isException
with
a
monadic
t
yp
e
a
->
IO
Bool;
the
question
is
whether
it
can
ha
v
e
a
pure,
non-monadic,
t
yp
e.)
A
t
rst
isException
lo
oks
reasonable,
b
ecause
it
hides
just
whic
h
exception
is
b
eing
raised
|
but
it
turns
out
to
b
e
rather
problematic.
What
is
the
v
alue
of
the
follo
wing
expression?
isException
((/0)
+
loop)
If
the
compiler
ev
aluates
the
rst
argumen
t
of
+
rst,
the
result
will
b
e
True
;
but
if
the
compiler
ev
aluates
the
sec-
ond
argumen
t
of
+
rst,
the
computation
will
not
terminate.
Tw
o
dieren
t
implemen
tations
ha
v
e
deliv
ered
t
w
o
dieren
t
v
alues!
It
is
quite
p
ossible
to
giv
e
a
p
erfectly
resp
ectable
denota-
tional
seman
tics
for
isException
|
in
fact
there
are
t
w
o
dieren
t
suc
h
seman
tics
that
w
e
migh
t
use,
the
\optimistic"
one
isException
(B
ad
s)
=
True
isException
(O
k
v
)
=
False
or
the
\p
essimistic"
one
isException
(B
ad
s)
=
?
if
NonTermination

s
isException
(B
ad
s)
=
True
if
NonTermination

s
isException
(O
k
v
)
=
False
0

The
trouble
is
that
neither
of
these
seman
tics
are
ecien
tly
implemen
table,
b
ecause
they
require
the
implemen
tation
to
detect
non
termination.
Consider
our
example
isException
((/0)
+
loop)
An
implemen
tation
that
ev
aluates
the
argumen
ts
of
+
righ
t-
to-left
w
ould
ev
aluate
loop
b
efore
/0
;
hence,
the
call
to
isException
w
ould
lo
op,
i.e.
ev
aluate
to
?,
rather
than
returning
True
as
the
\optimistic"
seman
tics
requires.
But
con
v
ersely
,
an
implemen
tation
that
ev
aluates
the
argumen
ts
of
+
left-to-righ
t
w
ould
ev
aluate
/0
b
efore
loop
;
hence,
the
call
to
isException
w
ould
return
True
,
rather
than
?
as
the
\p
essimistic"
seman
tics
requires.
Since
w
e
w
an
t
implemen-
tations
to
b
e
able
to
ev
aluate
argumen
ts
in
an
y
order,
nei-
ther
the
optimistic
nor
the
p
essimistic
seman
tics
will
w
ork.
There
are
a
n
um
b
er
of
p
ossible
things
w
e
could
sa
y:
.
Because
isException
is
unimplemen
table,
it
should
b
e
banned.
.
Programmers
ma
y
use
isException
,
but
when
they
do
so
they
undertak
e
a
pro
of
obligation
that
its
argumen
t
is
not
?.
If
this
can
b
e
assumed,
the
implemen
tation
is
in
no
dicult
y
(c.f.
Section
.).
.
The
denotational
seman
tics
for
isException
should
b
e
the
p
essimistic
one;
to
mak
e
it
implemen
table,
the
language
seman
tics
should
b
e
c
hanged
so
that
result
of
the
program
is
dened
to
b
e
an
y
v
alue
that
is
the
same
as
or
mor
e
dene
d
than
the
program's
denotation.
If
the
program
yields
?,
then
an
y
v
alue
at
all
could
b
e
deliv
ered.
This
alternativ
e
has
the
undesirable
prop
ert
y
that
a
program
that
go
es
in
to
an
innite
lo
op
w
ould
b
e
justi-
ed
in
returning
an
IO
computation
that
(sa
y)
deleted
y
our
en
tire
lestore.
.
The
denotational
seman
tics
for
isException
should
b
e
the
optimistic
one;
to
mak
e
it
implemen
table,
the
language
seman
tics
should
b
e
c
hanged
so
that
result
of
the
program
is
dened
to
b
e
an
y
v
alue
that
is
the
same
as
or
less
dene
d
than
the
program's
denotation.
?
w
ould
always
b
e
a
v
alid
result.
This
alternativ
e
has
the
undesirable
prop
ert
y
that
an
implemen
tation
could,
in
theory
,
ab
ort
with
an
error
message
or
fail
to
terminate
for
an
y
program
at
all,
including
programs
that
do
not
use
isException
.
Still,
in
comparison
to
the
previous
alternativ
e,
at
least
the
failure
mo
de
is
m
uc
h
less
sev
ere:
the
seman
tics
w
ould
only
allo
w
the
implemen
tation
w
ould
to
lo
op
or
ab
ort,
not
to
p
erform
arbitrary
I/O
op
erations.
The
latter
t
w
o
options
w
ould
b
oth
require
a
signican
t
global
c
hange
to
Hask
ell's
seman
tics,
and
ev
en
then,
nei-
ther
of
them
really
captures
the
in
tended
b
eha
viour
with
sucien
t
precision.
It
w
ould
b
e
p
ossible
to
rene
these
ap-
proac
hes
to
giv
e
more
precision,
but
only
at
the
cost
of
some
additional
seman
tic
complexit
y
.
Therefore
w
e
prefer
the
sec-
ond
option,
renaming
isException
to
unsafeIsException
to
highligh
t
the
pro
of
obligation.
Other
declarativ
e
languages,
particularly
logic
programming
languages
suc
h
as
G
odel
and
Mercury
already
mak
e
a
dis-
tinction
b
et
w
een
the
declarativ
e
(i.e.
denotational)
seman-
tics
and
the
op
erational
seman
tics
similar
to
that
men-
tioned
in
the
fourth
p
ossibilit
y
ab
o
v
e
[].
In
Mercury
,
for
example,
the
op
erational
seman
tics
allo
ws
non-termination
in
some
situations
ev
en
though
the
declarativ
e
seman
tics
sp
ecies
that
the
program
should
ha
v
e
a
result
other
than
non-termination.
So
if
our
prop
osal
for
Hask
ell
w
ere
to
b
e
adopted
to
other
languages
for
whic
h
the
op
erational
seman-
tics
is
already
incomplete
(in
the
ab
o
v
e
sense)
with
resp
ect
to
the
declarativ
e
seman
tics,
then
a
renemen
t
of
the
fourth
alternativ
e
migh
t
w
ell
b
e
the
b
est
approac
h.

Other
languages
W
e
ha
v
e
describ
ed
a
design
for
incorp
orating
exceptions
in
to
Hask
ell.
In
this
section
w
e
briey
relate
our
design
to
that
in
other
languages.
First,
it
is
clear
that
our
design
is
somewhat
less
expressiv
e
than
that
in
other
languages;
w
e
will
tak
e
ML
as
a
t
ypical
example.
In
ML
it
is
p
osssible
to
completely
encapsulate
a
function
that
mak
es
use
of
exceptions:
one
can
declare
an
exception
lo
cally
,
raise
it,
and
handle
it,
all
without
this
implemen
tation
b
ecoming
visible
to
the
function's
caller.
In
our
design,
one
cannot
handle
an
exception
without
using
the
IO
monad.
F
urthermore,
the
IO
monad
is
(b
y
design)
lik
e
a
trap
do
or:
y
ou
cannot
encapsulate
an
I/O
p
erforming
computation
inside
a
pure
function
|
and
righ
tly
not!
Though
w
e
do
not
y
et
ha
v
e
m
uc
h
exp
erience
of
using
exceptions
in
Hask
ell,
w
e
sp
eculate
that
the
fact
that
getException
is
in
the
IO
monad
will
not
pro
v
e
a
wkw
ard
in
practice,
for
sev
eral
reasons:

Only
exception
hand
ling,
using
getException
,
is
af-
fected.
One
can
r
aise
an
exception
without
in
v
olving
the
IO
monad
at
all.

Most
disaster-reco
v
ery
exception
handling
is
done
near
the
top
of
the
program,
where
all
other
input/output
is
in
an
y
case
p
erformed.

Muc
h
lo
cal
exception
handling
can
b
e
done
b
y
enco
d-
ing
exceptions
as
explicit
v
alues
(Section
.).
No
doubt
there
will
remain
situations
where
the
lac
k
of
a
\pure"
getException
will
pro
v
e
anno
ying.
One
alterna-
tiv
e
w
ould
b
e
to
pro
vide
an
unsafeGetException
(analogous
to
unsafeIsException
;
Section
.),
with
asso
ciated
pro
of
obligations
for
the
programmer.
Second,
the
big
pa
y
o
of
our
approac
h
is
that
w
e
lose
no
(useful)
transformations
compared
to
a
guaran
teed-
exception-free
program.
Could
the
same
tec
hnique
b
e
used
in
other
languages,
suc
h
as
ML
or
Ja
v
a?
It
is
hard
to
see
ho
w
it
could
apply
directly;
our
approac
h
dep
ends
crucially
on
distinguishing
computations
in
the
IO
monad
(whose
transformations
are
restricted
b
y
the
p
ossibilit
y
of
side
ef-
fects
and
non-determinism)
from
purely-functional
expres-
sions
(whose
transformations
are
unrestricted).
Nev
ertheless,
standard
eect
analyses
for
ML
and
Ja
v
a
seek
to
nd
whic
h
p
ortions
of
the
program
cannot
r
aise
an
ex-
ception,
whereas
in
our
system
transformations
are
limited


only
for
those
parts
of
the
program
that
hand
le
exceptions.
W
e
sp
eculate
that
an
eect
system
that
fo
cused
instead
on
the
latter
instead
of
the
former
migh
t
yield
more
scop
e
for
optimisation.
Our
w
ork
do
es
not
directly
address
the
question
of
ho
w
the
exception-raising
b
eha
viour
of
a
function
should
b
e
mani-
fested
in
its
t
yp
e.
Ja
v
a
requires
metho
ds
to
declare
whic
h
(c
hec
k
ed)
exceptions
they
ma
y
thro
w,
but
this
approac
h
do
es
not
seem
to
scale
w
ell
to
higher-order
languages
[
].
In
our
design,
explicitly-enco
ded
exceptions
are
certainly
man-
ifested
in
the
function's
t
yp
e,
but
exceptions
generated
b
y
raise
are
not.

Conclusion
As
usual,
implemen
tation
is
ahead
of
theory:
the
Glas-
go
w
Hask
ell
Compiler
(.0
and
later)
implemen
ts
raise
and
getException
just
as
describ
ed
ab
o
v
e.
If
nothing
else,
this
reassures
us
that
there
are
no
hidden
implemen
tation
traps.
A
useful
practical
outcome
of
writing
this
pap
er
w
as
a
clear
idea
ab
out
what
is,
and
what
is
not,
seman
tically
justiable
in
the
programming
in
terface.
F
or
example,
w
e
originally
implemen
ted
a
v
ersion
of
isException,
without
fully
un-
derstanding
the
impact
on
the
seman
tics.
W
e
no
w
kno
w
that
this
feature
w
ould
require
a
signican
t
lib
eralisation
of
Hask
ell's
seman
tics,
one
that
ma
y
not
b
e
acceptable
to
all
Hask
ell
programmers,
so
it
should
not
b
e
added
without
due
consideration.
Inciden
tally
,
exceptions
in
the
IO
monad
itself
are
also
no
w
handled
in
the
same
w
a
y
,
whic
h
mak
es
the
implemen
tation
of
the
IO
monad
v
ery
m
uc
h
more
ecien
t,
and
v
ery
m
uc
h
less
greedy
on
co
de
space.
Previously
,
ev
ery
>>=
op
eration
had
to
test
for,
and
propagate,
exceptions.
W
e
do
not
y
et
ha
v
e
m
uc
h
exp
erience
with
using
exceptions
in
Hask
ell.
The
pro
of
of
the
pudding
is
in
the
eating.
Bon
app
etit.
Ac
kno
wledgemen
t.
W
e
gratefully
ac
kno
wledge
helpful
feedbac
k
from
Cedric
F
ournet,
Corin
Pitc
her,
Nic
k
Ben
ton,
and
the
PLDI
referees.
References
[]
L.
Augustsson,
M.
Rittri,
and
D.
Synek.
On
generat-
ing
unique
names.
Journal
of
F
unctional
Pr
o
gr
amming,
:{,
Jan
uary
		.
[]
C.
Dornan
and
K.
Hammond.
Exception
handling
in
lazy
functional
languages.
T
ec
hnical
Rep
ort
CS	0/R,
Departmen
t
of
Computing
Science,
Univ
ersit
y
of
Glas-
go
w,
Jan
		0.
[]
F.
Henderson.
Non-deterministic
exceptions.
Electronic
mail
to
the
haskell
mailing
list,
June
		.
[]
F.
Henderson,
T.
Con
w
a
y
,
Z.
Somogyi,
and
D.
Jef-
fery
.
The
Mercury
language
reference
man
ual.
T
ec
h-
nical
Rep
ort
	/0,
Departmen
t
of
Computer
Sci-
ence,
Univ
ersit
y
of
Melb
ourne,
Melb
ourne,
Aus-
tralia,
		.
A
more
recen
t
v
ersion
is
a
v
ailable
via
<http://www.cs.mu.oz.au/mercu
ry/in
form
ation
/doc
umentation.html>.
[]
R.
Jones.
T
ail
recursion
without
space
leaks.
Journal
of
F
unctional
Pr
o
gr
amming,
():{0,
Jan.
		.
[]
E.
Moggi.
Computational
lam
b
da
calculus
and
mon-
ads.
In
IEEE
Symp
osium
on
L
o
gic
in
Computer
Sci-
enc
e,
June
		.
[]
A.
Mycroft.
The
theory
and
practice
of
transform-
ing
call-b
y-need
in
to
call-b
y-v
alue.
In
Pr
o
c
th
Inter-
national
Symp
osium
on
Pr
o
gr
amming,
pages
	{.
Springer
V
erlag
LNCS
,
	.
[]
F.
P
essaux
and
X.
Lero
y
.
T
yp
e-based
analysis
of
un-
caugh
t
exceptions.
In
Pr
o
c
Principles
of
Pr
o
gr
amming
L
anguages
(POPL'		),
San
A
ntonio,
Jan
			.
[	]
PL
W
adler.
Comprehending
monads.
Mathematic
al
Structur
es
in
Computer
Scienc
e,
:{	,
		.
[0]
PL
W
adler.
Ho
w
to
replace
failure
b
y
a
list
of
successes.
In
Pr
o
c
F
unctional
Pr
o
gr
amming
L
anguages
and
Com-
puter
A
r
chite
ctur
e,
L
a
Jol
la.
A
CM,
June
		.
[]
G.
Plotkin.
Domains.
T
ec
hnical
rep
ort,
Departmen
t
of
Computer
Science,
Univ
ersit
y
of
Edin
burgh,
	.
[]
A.
Reid.
Handling
Exceptions
in
Hask
ell.
Researc
h
Re-
p
ort
Y
ALEU/DCS/RR{,
Y
ale
Univ
ersit
y
,
August
		.
[]
A.
Reid.
Putting
the
spine
bac
k
in
the
Spineless
T
ag-
less
G-mac
hine:
an
implemen
tation
of
resumable
blac
k
holes.
In
Pr
o
c
Implementation
of
F
unctional
L
anguages
Workshop
		
(IFL'	).
Springer
V
erlag
LNCS
(to
ap-
p
ear
			),
Sept
		.
[]
RJM
Hughes.
Wh
y
functional
programming
matters.
Computer
Journal,
():	{0,
April
		.
[]
RJM
Hughes
and
JT
O'Donnell.
Expressing
and
reasoning
ab
out
non-deterministic
functional
pro-
grams.
In
K.
Da
vis
and
R.
Hughes,
editors,
Glas-
gow
F
unctional
Pr
o
gr
amming
Workshop,
pages
0{
.
Springer
W
orkshops
in
Computing,
		.
[]
SL
P
eyton
Jones,
AJ
Gordon,
and
SO
Finne.
Concur-
ren
t
Hask
ell.
In
r
d
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages,
St
Petersbur
g
Be
ach,
Florida,
pages
	{0.
A
CM,
Jan
		.
[]
SL
P
eyton
Jones
and
PL
W
adler.
Imp
erativ
e
functional
programming.
In
0th
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages
(POPL'	),
Charleston,
pages
{.
A
CM,
Jan
		.
[]
J.
Spiv
ey
.
A
functional
theory
of
exceptions.
Scienc
e
of
Computer
Pr
o
gr
amming,
:{,
Jul
		0.
[	]
J.
William,
A.
Aik
en,
and
E.
Wimmers.
Program
trans-
formation
in
the
presence
of
errors.
In
Pr
o
c
Principles
of
Pr
o
gr
amming
L
anguages
(POPL'	0),
San
F
r
ancisc
o,
pages
0{.
A
CM,
Jan
		0.
[0]
WJ
Co
dy
et
al.
A
prop
osed
radix-
and
w
ord-length
in-
dep
enden
t
standard
for
oating
p
oin
t
arithmetic.
IEEE
Micr
o,
():{00,
Aug.
	.


