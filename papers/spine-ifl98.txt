Putting
the
Spine
bac
k
in
the
Spineless
T
agless
G-Mac
hine:
An
Implemen
tation
of
Resumable
Blac
k-Holes
Alastair
Reid
Departmen
t
of
Computer
Science,
Y
ale
Univ
ersit
y
reid-alastair@cs.yale.edu
Abstract.
In
terrupt
handling
is
a
tric
ky
business
in
lazy
functional
lan-
guages:
w
e
ha
v
e
to
mak
e
sure
that
th
unks
that
are
b
eing
ev
aluated
can
b
e
halted
and
later
restarted
if
and
when
they
are
required.
This
is
a
partic-
ular
problem
for
implemen
tations
whic
h
use
blac
k-holing.
Blac
k-Holing
delib
erately
mak
es
it
imp
ossible
to
rev
ert
suc
h
th
unks
to
their
original
state
to
a
v
oid
a
serious
space
leak.
In
teractiv
e
Hask
ell
implemen
tations
suc
h
as
Hugs
and
h
bi
catc
h
in
terrupts
and
a
v
oid
the
problem
b
y
omitting
or
disabling
blac
k-holing.
Batc
h
mo
de
Hask
ell
implemen
tations
suc
h
as
HBC
and
the
Glasgo
w
Hask
ell
Compiler
(GHC)
a
v
oid
this
problem
b
y
disabling
blac
k-holing
or
b
y
pro
viding
no
w
a
y
to
catc
h
in
terrupts.
This
pap
er
describ
es
a
mo
dication
to
GHC's
abstract
mac
hine
(the
Spineless
T
agless
G-Mac
hine)
whic
h
sim
ultaneously
supp
orts
b
oth
in
terrupts
and
blac
k-holing.

In
tro
duction
Blac
k-Holing
[]
is
an
imp
ortan
t
tec
hnique
for
a
v
oiding
space
leaks
in
lazy
func-
tional
languages.
When
a
program
starts
to
ev
aluate
an
unev
aluated
th
unk,
it
copies
the
con
ten
ts
of
the
th
unk
on
to
the
stac
k
(or
in
to
registers)
and
o
v
erwrites
the
th
unk
with
an
ob
ject
kno
wn
as
a
\blac
k-hole."
When
the
program
completes
ev
aluation
of
the
unev
aluated
th
unk,
the
th
unk
is
o
v
erwritten
a
second
time
with
the
v
alue
of
the
th
unk.
If
the
program
tries
to
ev
aluate
a
th
unk
whic
h
is
already
b
eing
ev
aluated,
it
rep
orts
an
error.
This
is
the
correct
b
eha
viour
in
a
sequen-
tial
ev
aluator:
it
can
only
happ
en
if
the
v
alue
of
the
original
th
unk
dep
ends
on
itself
and
w
ould
ha
v
e
caused
an
innite
lo
op
in
a
system
whic
h
did
not
supp
ort
blac
k-holes.
(Concurren
t
ev
aluation
requires
dieren
t
b
eha
viour
and
is
discussed
in
section
..)
Blac
k-Holing
a
th
unk
is
imp
ortan
t
b
ecause
it
remo
v
es
references
to
the
free
v
ariables
of
the
th
unk;
if
one
of
these
references
is
the
last
reference
to
the
v
ariable,
the
v
ariable
can
b
e
garbage
collected
immediately
|
reducing
the
heap
usage
of
the
program.
Jones
[]
sho
ws
that
simple
tail-recursiv
e
functions
suc
h
as
last
can
run
in
constan
t
space
with
blac
k-holing
but
require
linear
space
without
blac
k-holing.
The
problem
with
blac
k-holing
is
that
it
assumes
that
ev
aluation
of
a
th
unk
will
not
stop
un
til
the
v
alue
of
the
th
unk
has
b
een
found.
This
is
a
problem
if

w
e
wish
to
pause
ev
aluation
of
a
th
unk
to
handle
an
in
terrupt
or
if
w
e
wish
to
sp
eculativ
ely
ev
aluate
a
th
unk
while
w
aiting
for
user
input
and
pause
ev
aluation
when
user
input
arriv
es.
In
b
oth
circumstances,
blac
k-holed
th
unks
are
left
in
the
heap
and
incorrectly
rep
ort
errors
if
they
are
subsequen
tly
ev
aluated.
An
ob
vious
x
is
to
rev
ert
blac
k-holes
to
their
original
form
when
an
in
terrupt
o
ccurs.
There
are
t
w
o
problems
with
this:
.
T
o
rev
ert
a
blac
k-hole
to
its
original
form,
w
e
ha
v
e
to
preserv
e
the
con
ten
ts
of
the
original
th
unk
un
til
ev
aluation
of
that
th
unk
completes
(i.e.,
un
til
w
e're
certain
it
will
not
need
to
b
e
rev
erted).
Doing
so
retains
references
to
the
th
unk's
free
v
ariables
restoring
the
space
leak
that
blac
k-holing
is
designed
to
x.
.
Rev
erting
the
blac
k-hole
to
its
original
form
causes
us
to
discard
a
lot
of
the
w
ork
w
e
p
erformed
in
partially
ev
aluating
the
ob
ject.
This
is
con
trary
to
one
of
the
primary
prop
erties
of
lazy
ev
aluation:
ev
ery
th
unk
is
ev
aluated
at
most
once.
Our
solution
to
these
problems
is
not
to
rev
ert
the
blac
k-hole
to
its
original
form
but
to
rev
ert
the
blac
k-hole
to
(a
represen
tation
of
)
its
curren
t
partially
ev
aluated
state.
On
the
Spineless
T
agless
Graph-reduction
Mac
hine
(STG
mac
hine)
[],
the
state
of
a
partially
ev
aluated
th
unk
is
stored
on
the
stac
k;
na

v
e
implemen
tations
of
graph
reduction
do
not
use
the
stac
k
in
this
w
a
y:
they
store
the
en
tire
state
of
a
th
unk
on
the
\spine"
of
the
th
unk.
W
e
therefore
dub
our
tec
hnique
\Putting
the
Spine
bac
k
in
the
Spineless
T
agless
G-Mac
hine."

Up
dates
in
the
STG
mac
hine
The
STG
mac
hine
is
describ
ed
in
detail
b
y
Simon
P
eyton-Jones
[];
here
w
e
pro
vide
an
o
v
erview
of
the
most
imp
ortan
t
parts
of
the
ev
aluation
and
up
date
mac
hinery
.
On
a
na

v
e
implemen
tation
of
graph
reduction,
an
up
date
is
p
erformed
on
eac
h
reduction
step.
F
or
example,
in
reducing
let
x
=
compose
id
id

in
x
to
,
a
na

v
e
implemen
tation
w
ould
up
date
x
three
times
with
id
(id
)
then
with
id

and
nally
with
.
This
is
inecien
t
b
ecause
it
requires
the
allo
cation
of
man
y
in
termediate
v
alues
and
b
ecause
it
requires
a
large
n
um
b
er
of
writes
in
to
the
heap.
The
STG
mac
hine
a
v
oids
these
costs
b
y
dela
ying
up
dates
un
til
an
expression
has
b
een
reduced
to
w
eak
head
normal
form:
eac
h
th
unk
is
ev
aluated
at
most
once.

T
o
do
this,
the
STG
mac
hine
main
tains
a
list
of
th
unks
whic
h
are
in
the

The
STG
mac
hine
also
allo
ws
th
unks
to
b
e
mark
ed
as
b
eing
non-up
datable
if
they
are
not
shared.
Blac
k-Holing
causes
no
problems
for
non-up
datable
th
unks
so
they
are
ignored
in
this
pap
er.

pro
cess
of
b
eing
ev
aluated.
This
list
is
threaded
through
the
ev
aluation
stac
k
and
is
manipulated
as
follo
ws:
{
When
an
(up
datable)
th
unk
is
\en
tered"
(i.e.,
ev
aluation
starts),
the
STG
mac
hine
do
es
four
things:
.
a
p
oin
ter
to
the
th
unk
is
pushed
on
to
the
up
date
list
(this
th
unk
is
kno
wn
as
the
\up
datee");
.
the
con
ten
ts
of
the
th
unk
are
pushed
on
to
the
stac
k;
.
the
th
unk
is
o
v
erwritten
with
a
blac
k-hole;

and
.
the
th
unk's
co
de
is
executed.
If
the
th
unk
is
an
application
no
de,
this
en
ters
the
ob
ject
on
top
of
the
stac
k.
{
When
ev
aluation
of
a
th
unk
completes,
the
top
of
the
stac
k
con
tains
one
of
t
w
o
things:

A
return
address:
the
ev
aluator
simply
jumps
to
the
return
address.

An
en
try
in
the
up
date
list:
the
ev
aluator
o
v
erwrites
the
up
datee
with
the
v
alue
of
the
th
unk,
remo
v
es
the
up
date
frame
from
the
list
and
tries
to
return
the
v
alue
again.

Rev
erting
Blac
k-Holes
As
w
e
noted
in
the
in
tro
duction,
blac
k-holing
causes
problems
if
w
e
in
terrupt
ex-
ecution
b
ecause
it
is
neither
p
ossible
nor
en
tirely
desirable
to
rev
ert
a
blac
k-hole
to
its
original
form.
The
solution
is
simple
and,
with
the
aid
of
0-0
hindsigh
t,
v
ery
ob
vious:
instead
of
rev
erting
the
blac
k-hole
to
its
original
form,
w
e
o
v
er-
write
blac
k-holes
with
that
part
of
the
stac
k
required
to
complete
ev
aluation
of
the
th
unk.
That
is,
w
e
rev
ert
eac
h
blac
k-hole
on
the
up
date
list
as
follo
ws:
.
The
blac
k-hole
is
o
v
erwritten
with
a
\resumable
blac
k-hole"
con
taining
the
con
ten
ts
of
the
stac
k
ab
o
v
e
the
up
date
frame.
If,
as
is
usually
the
case,
the
blac
k-hole
is
to
o
small
to
hold
the
resumable
blac
k-hole,
a
fresh
resumable
blac
k-hole
is
created
and
the
blac
k-hole
is
o
v
erwritten
with
an
indirection
to
the
resumable
blac
k-hole.
.
The
up
date
frame
is
remo
v
ed
from
the
head
of
the
up
date
list.
.
A
p
oin
ter
to
the
blac
k-hole
is
pushed
on
to
the
stac
k.
When
the
up
date
list
is
empt
y
,
the
remainder
of
the
stac
k
is
discarded.
When
the
STG
mac
hine
en
ters
a
resumable
blac
k-hole,
it
do
es
exactly
the
same
as
when
it
en
ters
an
up
datable
application
no
de.
That
is:
.
a
p
oin
ter
to
the
resumable
blac
k-hole
is
pushed
on
to
the
up
date
list;
.
the
con
ten
ts
of
the
resumable
blac
k-hole
are
pushed
on
to
the
stac
k;
.
the
resumable
blac
k-hole
is
o
v
erwritten
with
a
blac
k-hole;
and
.
the
ob
ject
on
top
of
the
stac
k
is
en
tered.

An
optimisation
kno
wn
as
\lazy
blac
k-holing"
allo
ws
this
step
to
b
e
dela
y
ed
un
til
garbage
collection
time
and
is
discussed
in
section
..

The
only
dierence
b
et
w
een
resumable
blac
k-holes
and
application
no
des
lies
in
ho
w
they
are
garbage
collected:
since
w
e
create
resumable
blac
k-holes
b
y
cop
ying
data
o
the
stac
k,
they
ha
v
e
to
b
e
garbage
collected
lik
e
miniature
stac
ks.
Figure

sho
ws
ho
w
this
w
orks
while
ev
aluating
this
expression
let
a
=
enumFromTo

00
b
=
tail
a
c
=
head
b
in
c
Initially
(gure
.i),
the
heap
con
tains
three
up
datable
application
no
des
a,
b
and
c
(represen
ting
the
v
ariables
a,
b
and
c
resp
ectiv
ely),
the
stac
k
(sho
wn
with
the
\top"
to
w
ards
the
b
ottom
of
the
page)
con
tains
some
data
D
and
the
top
of
the
stac
k
con
tains
a
p
oin
ter
to
c.
(One
of
the
strengths
of
our
tec
hnique
is
that
it
oblivious
to
what
data
(if
an
y)
o
ccurs
b
et
w
een
up
date
frames.
It
is
therefore
sucien
t
to
lab
el
the
areas
b
et
w
een
up
date
frames
A
.
.
.
D;
w
e
need
not
w
orry
ab
out
the
con
ten
ts
or
sizes
of
these
areas.)
Figures
.ii
to
.iv
sho
w
ho
w
the
spine
of
the
graph
is
un
w
ound
during
ev
al-
uation
of
c.
As
eac
h
application
no
de
is
en
tered,
an
up
date
frame
is
pushed
on
to
the
stac
k
and
added
to
the
head
of
the
up
date
list,
the
con
ten
ts
of
the
no
de
are
copied
on
to
the
stac
k
and
the
no
de
is
blac
k-holed.
Let
us
supp
ose
that
an
in
terrupt
o
ccurs
just
after
a
is
en
tered.
The
next
time
a
th
unk
is
en
tered
(i.e.,
when
enumFromTo
is
en
tered),
the
ev
aluator
detects
that
the
thread
is
to
b
e
killed
and
start
to
rev
ert
all
the
blac
k-holes
on
the
up
date
list.
Figures
.v
to
.viii
sho
w
ho
w
the
spine
of
the
graph
is
reconstructed
from
the
stac
k
while
rev
erting
blac
k-holes.
As
eac
h
blac
k-hole
is
rev
erted,
the
blac
k-
hole
is
o
v
erwritten
with
a
resumable
blac
k-hole
con
taining
the
con
ten
ts
of
the
stac
k
ab
o
v
e
the
up
date
frame,
the
up
date
frame
is
remo
v
ed
from
the
head
of
the
up
date
list
and
a
p
oin
ter
to
the
blac
k-hole
is
pushed
on
to
the
stac
k.
When
the
up
date
list
is
empt
y
,
the
remainder
of
the
stac
k
is
discarded.
Supp
ose
no
w
that
w
e
start
ev
aluating
something
else
and,
in
the
course
of
that
expression,
w
e
en
ter
th
unk
c.
The
b
eha
viour
of
the
STG
mac
hine
on
en-
tering
a
resumable
blac
k-hole
rev
erses
the
sequence
of
steps
from
gure
.viii
to
gure
.v.
That
is:
.
Since
c
is
a
resumable
blac
k-hole,
the
ev
aluator
adds
an
up
date
frame
to
the
list,
pushes
the
data
C
on
the
stac
k,
pushes
b
on
the
stac
k,
blac
k-holes
c
and
en
ters
b
resulting
in
gure
.vii.
.
On
en
tering
b,
the
ev
aluator
adds
an
up
date
frame
to
the
list,
pushes
the
data
B
on
the
stac
k,
pushes
a
on
the
stac
k,
blac
k-holes
b
and
en
ters
a
resulting
in
gure
.vi.
.
On
en
tering
a,
the
ev
aluator
adds
an
up
date
frame
to
the
list,
pushes
p
oin
ters
to
00,

and
enumFromTo
on
the
stac
k,
blac
k-holes
a
and
en
ters
enumFromTo
resulting
in
gure
.v.

RBH
enumFromTo
tail
1
100
AP
AP
D
BH
head
b
a
c
enumFromTo
1
100
AP
a
D
BH
b
c
BH
C
tail
tail
AP
b
head
AP
c
enumFromTo
1
100
AP
D
a
1
100
D
BH
b
a
c
BH
C
enum..
BH
B
i)
ii)
iii)
iv)
v)
vi)
vii)
viii)
D
BH
b
a
c
BH
C
B
D
C
D
a
enumFromTo
1
100
a
c
b
a
1
100
enumFromTo
C
B
a
c
b
a
1
100
enumFromTo
C
B
BH
a
c
b
a
B
1
100
enumFromTo
BH
a
c
b
a
B
1
100
enumFromTo
RBH
RBH
RBH
RBH
RBH
RBH
RBH
RBH
Fig.
.
Rev
erting
Blac
k-Holes

The
stac
k
has
no
w
b
een
restored
to
its
original
state
prior
to
the
in
terrupt
and
execution
con
tin
ues
as
b
efore.
A
similar
sequence
unfolds
if
the
new
ev
aluation
en
ters
a
or
b.
An
ob
vious
concern
is
that
using
this
tec
hnique
will
someho
w
re-in
tro
duce
the
space
leak
that
blac
k-holing
is
supp
osed
to
remo
v
e.
This
clearly
do
es
not
happ
en:
{
Nothing
is
c
hanged
during
normal
ev
aluation.
W
e
use
exactly
the
same
rep-
resen
tation
and
store
exactly
the
same
data
as
in
the
original
STG
mac
hine
with
blac
k-holing.
{
The
resumable
blac
k-holes
generated
when
discarding
a
stac
k
require
almost
exactly
the
same
space
as
the
original
stac
k.
{
After
an
in
terrupt
o
ccurs,
ev
ery
resumable
blac
k-hole
con
tains
exactly
the
data
needed
to
ev
aluate
it
and
so
it
do
esn't
leak
space
unless
the
original
ev
aluation
mec
hanism
leak
ed
space.
Despite
this,
w
e
migh
t
still
nd
that
a
resumable
blac
k-hole
tak
es
more
space
than
the
original
up
dateable
th
unk
(a
th
unk
ma
y
tak
e
more
space
when
ev
alu-
ated).
W
e
migh
t
also
nd
that
a
resumable
blac
k-hole
tak
es
less
space
than
the
original
up
dateable
th
unk
(a
th
unk
ma
y
also
tak
e
less
space
when
ev
aluated).
This
is
a
fundamen
tal
prop
ert
y
of
lazy
ev
aluation
rather
than
a
sp
ecial
prop
ert
y
of
blac
k-holes
or
resumable
blac
k-holes:
it
also
happ
ens
in
na

v
e
graph
reducers
whic
h
ha
v
e
neither.
Another
concern
is
that
the
b
enets
of
using
this
tec
hnique
ma
y
come
at
a
signican
t
cost
in
p
erformance
or
in
complexit
y
of
the
run
time
system.
Again,
this
do
es
not
happ
en:
{
Since
nothing
is
c
hanged
during
normal
ev
aluation,
no
o
v
erhead
is
imp
osed
on
programs
that
are
not
in
terrupted.
{
When
a
program
is
in
terrupted,
w
e
cop
y
stac
k
segmen
ts
in
to
resumable
blac
k-hole
ob
jects
on
the
heap;
when
a
blac
k-hole
is
resumed,
w
e
cop
y
the
stac
k
segmen
ts
bac
k
on
to
the
stac
k.
These
costs
are
t
ypically
quite
small
(smaller
than
other
run
time
costs
suc
h
garbage
collection)
and
are
only
in-
curred
when
in
terrupts
o
ccur.
{
The
implemen
tation
is
as
simple
as
our
description:
it
consists
of
a
few
h
undred
lines
of
C
to
implemen
t
the
new
ob
ject
t
yp
e
and
to
cop
y
stac
k
segmen
ts
in
to
resumable
blac
k
holes.

Catc
hing
In
terrupts
The
previous
section
describ
es
ho
w
to
pause
ev
aluation
without
lea
ving
blac
k-
holes
in
the
heap
but
sa
ys
nothing
ab
out
what
to
do
after
ev
aluation
has
b
een
paused.
This
section
outlines
ho
w
to
catc
h
in
terrupts
in
a
programming
en
vi-
ronmen
t
(Hugs)
and
in
the
programming
language
itself.
Only
the
rst
one
has
b
een
implemen
ted
as
y
et.
Catc
hing
in
terrupts
is
absolutely
essen
tial
in
an
in
teractiv
e
system
suc
h
as
Gofer
[]
or
Hugs:
w
e
ha
v
e
to
b
e
able
to
terminate
long-running
programs
or

programs
that
ha
v
e
en
tered
innite
lo
ops
and
con
tin
ue.
W
e
ha
v
e
written
a
mo
d-
ied
v
ersion
of
Hugs
whic
h
uses
the
STG
mac
hine
for
ev
aluation.
When
the
user
in
terrupts
an
ev
aluation,
the
Hugs
user
in
terface
sets
a
ag
in
the
run
time
sys-
tem
to
indicate
that
an
in
terrupt
o
ccurred.
Ev
ery
time
the
ev
aluator
en
ters
a
no
de,
it
tests
this
ag
to
see
whether
it
should
terminate
the
curren
t
ev
aluation
b
y
rev
erting
all
blac
k-holes
on
the
up
date
list.
T
o
catc
h
in
terrupts
in
(Sequen
tial)
Hask
ell
w
e
need
to
add
a
function
lik
e
Hask
ell
.'s
catch
function:
catchInterrupt
::
IO
a
->
IO
a
->
IO
a
The
expression
e
`catchInterrupt`
h
executes
the
expression
e.
If
e
termi-
nates
b
efore
an
in
terrupt
o
ccurs,
the
result
of
e
is
returned;
if
an
in
terrupt
o
ccurs
b
efore
e
terminates,
the
hand
ler
h
is
executed
and
the
result
of
h
is
returned.
T
o
implemen
t
this,
w
e
dene
a
new
t
yp
e
of
frame
whic
h
can
b
e
inserted
in
the
up
date
list.
These
interrupt
hand
ler
frames
con
tain
a
p
oin
ter
to
a
handler
th
unk;
they
are
added
to
the
list
when
catchInterrupt
is
executed
and
remo
v
ed
from
the
list
when
catchInterrupt
completes.
When
an
in
terrupt
o
ccurs,
the
run
time
rev
erts
all
blac
k-holes
do
wn
to
the
topmost
in
terrupt
handler
frame,
remo
v
es
the
in
terrupt
handler
frame
and
en
ters
the
handler
th
unk.

V
ariations
The
STG
mac
hine
is
a
v
ery
exible
arc
hitecture
allo
wing
a
n
um
b
er
of
optimisa-
tions
and
extensions.
This
section
describ
es
ho
w
rev
erting
blac
k-holes
in
teracts
with
v
e
suc
h
optimisations
and
extensions.
.
Lazy
Blac
k-Holing
Section
	..
of
the
STG
pap
er
[]
describ
es
an
optimisation
of
blac
k-holing
kno
wn
as
\lazy
blac
k-holing"
whic
h
dela
ys
blac
k-holing
a
th
unk
un
til
the
next
garbage
collection.
When
garbage
collection
o
ccurs,
it
is
a
simple
matter
to
run
do
wn
the
up
date
list
and
blac
k-hole
an
y
th
unks
whic
h
are
not
already
blac
k-
holed.
This
do
es
not
aect
the
abilit
y
of
blac
k-holing
to
eliminate
space
leaks
b
ecause
the
space
leak
do
es
not
manifest
itself
un
til
the
next
garbage
collection
and
so
there
is
no
harm
in
dela
ying
blac
k-holing
un
til
then.
The
b
enet
of
lazy
blac
k-holing
is
that
it
a
v
oids
the
extra
eort
required
to
blac
k-hole
a
th
unk
whose
ev
aluation
completes
b
efore
a
garbage
collection
o
ccurs.
The
only
thing
that
c
hanges
when
rev
erting
blac
k-holes
if
w
e
use
lazy
blac
k-
holing
is
that
w
e
ma
y
ha
v
e
to
rev
ert
a
th
unk
on
the
up
date
list
whic
h
hasn't
b
een
blac
k-holed
y
et.
Tw
o
questions
arise:
should
w
e
rev
ert
the
th
unk;
and
c
an
w
e
rev
ert
the
th
unk.
The
answ
er
to
b
oth
questions
is
\y
es":
.
Nothing
go
es
drastically
wrong
if
w
e
don't
rev
ert
the
th
unk
but
w
e
lose
some
laziness.
That
is,
w
e
discard
the
result
of
partially
ev
aluating
the
th
unk
and
ha
v
e
to
rep
eat
that
eort
if
the
th
unk
is
re-en
tered.
W
orse
still,
w
e
lose

an
unpr
e
dictable
amoun
t
of
laziness
dep
ending
on
when
w
e
last
blac
k-holed
th
unks
on
the
up
date
list.
T
o
a
v
oid
these
problems,
w
e
c
ho
ose
to
rev
ert
all
th
unks
on
the
up
date
list
ev
en
if
they
ha
v
en't
b
een
blac
k-holed
y
et.
.
W
e
migh
t
w
orry
that
a
th
unk
on
the
up
date
list
could
b
e
smaller
than
a
blac
k-hole
making
it
imp
ossible
to
o
v
erwrite
with
either
a
resumable
blac
k-
hole
or
an
indirection
to
a
resumable
blac
k-hole.
F
ortunately
,
this
cannot
happ
en:
the
system
already
requires
that
all
up
datable
th
unks
are
big
enough
to
o
v
erwrite
with
a
blac
k-hole.
This
is
required
since
w
e
are
able
to
blac
k-hole
all
the
th
unks
on
the
up
date
list
b
efore
rev
erting
them.
.
The
seq
and
strict
functions
Hask
ell
.
added
the
abilit
y
to
force
ev
aluation
of
a
th
unk
using
the
(equiv
alen
t)
functions
seq
and
strict
instead
of
b
y
using
a
case
expression.
A
case
expres-
sion
w
ould
ha
v
e
pushed
a
return
address
on
to
the
stac
k
but,
b
ecause
seq
can
b
e
used
on
ob
jects
with
an
y
t
yp
e
(including
functions),
they
require
a
dieren
t
implemen
tation.
The
seq
function
is
implemen
ted
b
y
pushing
a
\con
tin
uation"
on
to
the
stac
k,
and
adding
a
\SEQ
frame"
to
the
up
date
list
so
that
the
ev
alu-
ator
en
ters
the
con
tin
uation
correctly
.
If
the
ev
aluator
nds
a
\SEQ
frame"
on
the
up
date
list
when
it
returns
a
v
alue,
it
remo
v
es
the
frame,
discards
the
v
alue
and
en
ters
the
con
tin
uation
on
top
of
the
stac
k.
This
requires
the
follo
wing
c
hange
to
our
rev
ertible
blac
k-holing
mec
hanism.
When
w
e
encoun
ter
an
exception
handling
frame
on
the
stac
k,
w
e
create
a
th
unk
whic
h
will
push
a
SEQ
frame
on
to
the
stac
k,
push
the
stac
k
con
ten
ts
and
resume
ev
aluation.
Since
the
STG
mac
hine
do
esn't
ha
v
e
no
de
t
yp
es
that
do
this
already
,
w
e
ha
v
e
to
add
SEQ
no
des
to
the
system.
When
a
SEQ
no
de
is
en
tered,
the
ev
aluator
adds
a
SEQ
frame
to
the
up
date
list,
pushes
the
no
de's
con
ten
ts
on
the
stac
k
and
en
ters
the
top
no
de.
Figure

sho
ws
ho
w
SEQ
frames
are
rev
erted
when
executing
the
expression
let
a
=

+

b
=
a
`seq`
x
in
b
RBH
b
BH
BH
a
+
1
2
A
U
U
+
1
2
a)
A
SEQ
b)
b
SEQ
a
RBH
Fig.
.
Rev
erting
SEQ
F
rames

Figure
a
sho
ws
the
state
of
the
stac
k
just
b
efore
en
tering
+.
Th
unks
a
and
b
ha
v
e
b
een
blac
k-holed
and
the
up
date
list
consists
of
an
up
date
frame
for
a,
a
SEQ
frame
and
an
up
date
frame
for
b.
F
rames
on
the
up
date
list
are
tagged
with
U
for
up
date
frames
and
SEQ
for
SEQ
frames.
Rev
erting
the
blac
k-holes
and
SEQ
frames
in
gure
a
yields
gure
b.
The
blac
k-holes
are
rev
erted
exactly
as
b
efore
and
the
SEQ
frame
has
b
een
turned
in
to
a
SEQ
no
de
con
taining
a
p
oin
ter
to
a.
This
isn't
the
only
p
ossible
w
a
y
of
dealing
with
SEQ
frames.
An
alternativ
e
is
to
allo
w
resumable
blac
k-holes
to
con
tain
lists
of
SEQ
frames
and
ll
in
resum-
able
blac
k-holes
with
ev
erything
on
the
stac
k
that
o
ccurs
b
et
w
een
t
w
o
up
date
frames:
p
ending
argumen
ts,
return
addresses,
en
vironmen
ts,
SEQ
frames,
etc.
This
a
v
oids
the
cost
of
in
tro
ducing
SEQ
no
des
at
the
exp
ense
of
making
resum-
able
blac
k-holes
more
complex.
This
extra
complexit
y
is
most
k
eenly
felt
in
the
garbage
collector
|
whic
h
is
already
quite
complex
enough!
.
Exception
handling
W
e
recen
tly
extended
the
STG
mac
hine
with
an
exception
handling
mec
ha-
nism
[0,
]
whic
h
uses
the
up
date
list
to
store
exception
handlers
as
w
ell
as
up
datees.
When
the
ev
aluator
nds
an
exception
handler
on
the
up
date
list
as
it
is
trying
to
return
a
v
alue,
it
remo
v
es
the
exception
handler
and
tries
again.
This
requires
the
follo
wing
c
hange
to
our
rev
ertible
blac
k-holing
mec
hanism.
When
w
e
encoun
ter
an
up
date
frame
on
the
up
date
list,
w
e
(already)
create
a
th
unk
to
push
an
up
date
frame
on
to
the
stac
k,
push
the
stac
k
con
ten
ts
and
con
tin
ue
ev
aluation
where
it
left
o.
Similarily
,
when
w
e
encoun
ter
an
exception
handling
frame
on
the
stac
k,
w
e
create
a
th
unk
to
push
an
exception
handling
frame
on
to
the
stac
k,
push
the
stac
k
con
ten
ts
and
resume
ev
aluation.
Since
the
STG
mac
hine
do
esn't
ha
v
e
no
de
t
yp
es
that
do
this
already
,
w
e
ha
v
e
to
add
CATCH
no
des
to
the
system.
When
a
CATCH
no
de
is
en
tered,
the
ev
aluator
adds
an
exception
handler
frame
to
the
up
date
list,
pushes
the
no
de's
con
ten
ts
on
the
stac
k
and
en
ters
the
top
no
de.
Figure

sho
ws
ho
w
exception
handlers
are
rev
erted
when
executing
the
ex-
pression

let
a
=
print

b
=
a
`catchException`
h
c
=
b
>>
x
in
y
Figure
a
sho
ws
the
state
of
the
stac
k
just
b
efore
en
tering
print.
Th
unks
a,
b
and
c
ha
v
e
b
een
blac
k-holed
and
the
up
date
list
consists
of
an
up
date
frame
for
a,
an
exception
handler
frame,
an
up
date
frame
for
b
and
an
up
date
frame

The
expression
a
`catchException`
h
ev
aluates
a
and
returns
its
result;
if
an
ex-
ception
is
thro
wn
while
ev
aluating
a,
then
the
handler
h
is
in
v
ok
ed
and
the
result
of
h
is
returned.

RBH
C
B
print 1
h
b
c
BH
BH
BH
C
B
A
D
print
1
U
U
E
U
a
a)
b)
c
b
a
h
A
CATCH
RBH
RBH
Fig.
.
Rev
erting
Exception
Handlers
for
c.
F
rames
on
the
up
date
list
are
tagged
with
U
for
up
date
frames
and
E
for
exception
handler
frames.
Rev
erting
the
blac
k-holes
and
exception
handlers
in
gure
a,
results
in
g-
ure
b.
The
blac
k-holes
are
rev
erted
exactly
as
b
efore
and
the
exception
handling
frame
has
b
een
turned
in
to
a
CATCH
no
de
con
taining
the
handler
h,
the
applica-
tion
no
de
a
and
the
data
A.
Again,
w
e
could
ha
v
e
added
supp
ort
for
exception
handling
b
y
enric
hing
the
structure
of
resumable
blac
k-holes.
The
tradeo
here
is
exactly
as
it
w
as
with
SEQ
frames
but
since
the
c
hoice
is
no
w
b
et
w
een
one
complex
ob
ject
and
three
simple
ob
jects
the
decision
to
in
tro
duce
a
new
no
de
t
yp
e
isn't
quite
so
clear.
.
Concurren
t
Hask
ell
The
STG
mac
hine
has
b
een
extended
to
supp
ort
concurren
t
threads
[	].
In
a
concurren
t
system,
blac
k-holing
is
mo
died
as
follo
ws.
W
e
add
a
queue
of
threads
to
ev
ery
blac
k-hole
|
the
\blo
c
king
queue"
of
the
blac
k-hole.
The
rst
time
a
th
unk
is
en
tered,
it
is
o
v
erwritten
with
a
blac
k-hole
with
an
empt
y
queue.
If
another
thread
tries
to
en
ter
a
blac
k-hole
that
thread
is
susp
ended
and
added
to
the
blo
c
king
queue.
When
ev
aluation
of
a
th
unk
completes,
its
blac
k-hole
is
o
v
erwritten
with
the
v
alue
of
the
th
unk
and
all
threads
in
the
blo
c
king
queue
are
added
to
the
(global)
queue
of
runnable
threads.
This
blo
c
king
b
eha
viour
requires
the
follo
wing
c
hange
when
rev
erting
blac
k-
holes:
when
a
blac
k-hole
is
rev
erted,
all
threads
in
the
blo
c
king
queue
are
added
to
the
(global)
queue
of
runnable
threads.
When
these
threads
next
try
to
exe-
cute,
the
rst
thread
will
en
ter
the
resumable
blac
k-hole
and
rebuild
the
stac
k
exactly
as
it
w
as
when
the
thread
w
as
in
terrupted
and
all
subsequen
t
threads
will
b
e
added
to
the
blo
c
king
queue
as
b
efore.
T
o
catc
h
in
terrupts
in
Concurren
t
Hask
ell
[	]
w
e
need
to
add
t
w
o
things:


A
full
threads
library
migh
t
add
further
features,
here
w
e
restrict
ourselv
es
to
the
minim
um
required
to
catc
h
in
terrupts.

.
The
abilit
y
to
terminate
a
thread;
and
.
The
abilit
y
to
w
ait
for
an
in
terrupt
to
o
ccur.
It
is
then
straigh
tforw
ard
to
create
threads
whic
h
w
ait
for
in
terrupts
and
kill
other
threads
when
they
o
ccur.
This
can
b
e
com
bined
with
functions
whic
h
w
ait
for
a
giv
en
time
p
erio
d
to
pro
vide
timeouts
as
w
ell.
T
o
terminate
a
thread,
w
e
need
to
add
thread
iden
tiers
and
a
function
to
kill
a
thread.
The
function
killThread
m
ust
rev
ert
all
blac
k-holes
on
the
thread's
up
date
list
b
efore
killing
the
thread.
data
ThreadId
--
abstract
forkIO
::
IO
a
->
IO
ThreadId
getThreadId
::
IO
ThreadId
killThread
::
ThreadId
->
IO
()
W
e
also
need
a
w
a
y
of
w
aiting
for
an
in
terrupt.
This
requires
a
small
c
hange
to
the
run
time
system
to
main
tain
a
list
of
threads
w
aiting
for
in
terrupts
and
add
the
threads
to
the
runnable
queue
when
an
in
terrupt
o
ccurs.
This
is
a
(simplied)
form
of
ho
w
timers
are
curren
tly
handled.
waitForInterrupt
::
IO
()
.
P
arallel
Hask
ell
The
STG
mac
hine
has
b
een
extended
to
run
on
parallel
arc
hitectures
[].
Blac
k-
holes
act
in
the
same
w
a
y
as
in
Concurren
t
Hask
ell
(i.e.,
threads
blo
c
k
on
th
unks
whic
h
are
already
b
eing
ev
aluated).
The
big
c
hange
from
Concurren
t
Hask
ell
is
that
eac
h
pro
cessor
only
has
access
to
a
small
part
of
the
global
heap;
if
a
pro
cessor
requires
an
ob
ject
stored
in
another
part
of
the
graph,
it
m
ust
ask
another
pro
cessor
to
send
it
the
ob
ject.
If
the
ob
ject
is
already
b
eing
ev
aluated
b
y
a
pro
cessor,
the
request
blo
c
ks
un
til
ev
aluation
terminates.
W
e
ha
v
e
not
implemen
ted
resumable
blac
k-holes
in
P
arallel
Hask
ell
but
w
e
b
eliev
e
that
it
should
b
e
straigh
tforw
ard
since
rev
erting
the
blac
k-holes
on
a
thread's
stac
k
is
a
lo
cal
op
eration.
When
a
thread
is
in
terrupted,
all
p
ending
up
dates
are
rev
erted
in
the
same
w
a
y
as
in
Concurren
t
Hask
ell.
Just
as
threads
blo
c
k
ed
on
a
blac
k-hole
are
mo
v
ed
to
the
queue
of
runnable
threads
in
Concurren
t
Hask
ell,
so
blo
c
k
ed
requests
(to
mo
v
e
an
ob
ject
to
another
pro
cessor)
are
mo
v
ed
to
the
queue
of
\runnable"
requests.
Note
that
it
is
v
ery
imp
ortan
t
that
an
ob
ject
cannot
b
e
mo
v
ed
while
it
is
b
eing
ev
aluated
since
w
e
m
ust
b
e
able
to
o
v
erwrite
the
original
ob
ject
with
a
resumable
blac
k-hole
when
a
thread
is
in
terrupted.
Being
able
to
in
terrupt
a
thread
is
particularily
imp
ortan
t
in
P
arallel
Hask
ell
since
it
mak
es
it
p
ossible
to
con
trol
sp
eculativ
e
ev
aluation
on
idle
pro
cessors
[].
When
resources
(CPU
and
memory)
are
abundan
t,
sp
eculativ
e
threads
can
b
e
created;
and
when
resources
are
scarce
or
p
o
orly
balanced
b
et
w
een
pro
cessors,
sp
eculativ
e
threads
can
b
e
terminated.
Using
our
rev
ertible
blac
k-holes,
termi-
nating
a
thread
has
the
eect
of
splitting
its
stac
k
in
to
man
y
small
parts
allo
wing
un
w
an
ted
parts
to
b
e
reclaimed
and
allo
wing
parts
required
b
y
other
pro
cessors
to
mo
v
e
to
the
other
pro
cessor.


Related
W
ork
Lazy
functional
programs
can
suer
from
a
v
ariet
y
of
space
leaks.
Whilst
man
y
of
these
problems
can
only
b
e
eliminated
b
y
mo
difying
y
our
program,
some
space
leaks
can
b
e
xed
in
the
ev
aluator
or
in
the
garbage
collector.
One
of
the
rst
suc
h
xes
w
as
the
\lazy
tuple
matc
hing"
space
leak
rep
orted
b
y
Hughes
[].
The
problem
is
that
extracting
a
comp
onen
t
of
a
data-structure
(ak
a
\tuple
matc
hing")
is
p
erformed
lazily
and
so
the
run
time
system
ma
y
hang
on
to
a
large
data
structure
of
whic
h
only
a
small
comp
onen
t
is
required.
W
adler
sho
w
ed
ho
w
this
could
b
e
xed
b
y
mo
difying
the
garbage
collector
[]
and,
more
recen
tly
,
Sparud
sho
w
ed
ho
w
this
could
b
e
solv
ed
b
y
mo
difying
the
ev
aluator
[].
Another
space
leak
whic
h
can
b
e
automatically
plugged
w
as
acciden
tally
in-
tro
duced
b
y
\optimising"
tail
calls
in
the
G-mac
hine.
This
problem
w
as
iden
tied
and
xed
b
y
Jones
with
the
in
tro
duction
of
blac
k-holing
[].
Shortly
after
the
in
tro
duction
of
blac
k-holing,
Runciman
and
W
ak
eling
found
a
baing
space
leak
using
their
heap
proling
to
ol
[].
They
susp
ected
a
prob-
lem
in
their
to
ol
un
til
they
realised
that
the
problem
w
as
the
same
one
rep
orted
b
y
Jones.
Adding
blac
k-holing
to
their
compiler
remo
v
ed
this
leak
and
resulted
in
a
factor
of
four
reduction
in
the
cost
of
running
a
b
enc
hmark.
The
com
bi-
nation
of
blac
k-holing,
W
adler's
x
for
the
\lazy
tuple
matc
h"
leak
and
xing
programming
problems
iden
tied
b
y
their
to
ol
reduced
the
space-time
cost
of
their
program
b
y
t
w
o
orders
of
magnitude.
Un
til
no
w,
the
ma
jor
problem
with
blac
k-holing
has
b
een
its
incompatabilit
y
with
in
terrupts
and
with
sp
eculativ
e
ev
aluation.
Mattson
and
Grisw
old
[]
use
\grey-holes"(a
kind
of
rev
ertible
blac
k-hole)
to
sync
hronize
threads
in
a
P
arallel
Hask
ell
implemen
tation
but,
unlik
e
resumable
blac
k-holes,
terminating
a
sp
ecu-
lativ
e
thread
rev
erts
grey-holes
to
their
original
form.
This
suers
from
the
t
w
o
problems
listed
in
the
in
tro
duction:
it
rein
tro
duces
the
space
leak;
and
it
discards
w
ork.
They
suggest
that
discarding
w
ork
is
b
enecial
since
the
unev
aluated
form
of
the
th
unk
is
often
smaller
than
the
ev
aluated
form
but
Hughes
[]
suggests
that
the
opp
osite
is
sometimes
true.
T
rinder
et
al.[]
use
blac
k-holes
when
mo
ving
ob
jects
from
one
pro
cessor
to
another.
While
the
ob
ject
is
in
transit,
it
is
o
v
erwritten
with
a
\rev
ertible
blac
k-
hole."
If
the
ob
ject
is
rejected
(p
erhaps
b
ecause
the
receiv
er
runs
out
of
heap
space),
the
blac
k-hole
is
rev
erted
to
its
original
form;
otherwise,
the
rev
ertible
blac
k-hole
acts
lik
e
a
normal
blac
k-hole
and
is
up
dated
with
an
indirection
to
the
(as
y
eat
still
unev
aluated)
th
unk
on
the
remote
pro
cessor.
Lik
e
Mattson
and
Grisw
old,
the
blac
k-hole
ma
y
b
e
rev
erted
to
its
original
form,
but
this
do
esn't
cause
the
same
problems
since
rev
ertible
blac
k-holes
only
last
long
enough
to
successfully
transfer
an
ob
ject
from
one
pro
cessor
to
another.
Their
system
has
no
need
for
resumable
blac
k-holes
since
it
do
es
not
supp
ort
in
terrupt
catc
hing
and
it
pro
vides
task
migration
in
preference
to
sp
eculativ
e
ev
aluation.
More
recen
tly
,
Chakra
v
art
y
uses
a
similar
tec
hnique
to
co
v
er
comm
unication
latencies
in
his
massiv
ely
parallel
STG
mac
hine
[].
Besides
his
dieren
t
motiv
a-
tion
(Chakra
v
art
y
do
es
not
men
tion
in
terrupts,
killing
threads
or
blac
k-holing),
there
are
some
imp
ortan
t
tec
hnical
dierences:

{
Chakra
v
art
y
susp
ends
closures
(using
ob
jects
lik
e
our
resumable
blac
k-holes)
while
w
aiting
for
a
v
alue
to
b
e
receiv
ed
from
a
remote
pro
cessor
and
resumes
the
closure
when
the
v
alue
arriv
es.
Since
eac
h
closure
requires
dieren
t
sets
of
v
alues
from
other
pro
cessors,
Chakra
v
art
y
only
susp
ends
the
topmost
closure
instead
of
rev
erting
all
closures
curren
tly
under
ev
aluation.
If
the
program
terminates
successfully
,
all
susp
ended
closures
will
ha
v
e
b
een
restarted.
{
In
con
trast,
w
e
are
concerned
with
in
terrupting
normal
sequen
tial
ev
aluation:
closures
are
susp
ended
when
an
in
terrupt
is
receiv
ed
and
restarted
only
if
and
when
they
are
needed
b
y
the
in
terrupt
handler.
Since
in
terrupts
aect
the
en
tire
execution,
w
e
susp
end
all
closures
whic
h
are
curren
tly
under
ev
aluation
b
y
w
alking
do
wn
the
up
date
list.
Most
resumable
blac
k-holes
are
not
required
b
y
the
in
terrupt
handler
and
are
quic
kly
garbage
collected.
In
short,
Chakra
v
art
y
susp
ends
closures
whic
h
are
w
aiting
to
b
e
sen
t
input
while
w
e
susp
end
closures
whic
h
are
w
aiting
for
their
output
to
b
e
(re)demanded.
Lo
oking
farther
aeld,
similar
problems
and
similar
solutions
are
found
when-
ev
er
computer
scien
tists
w
an
t
to
cancel
sp
eculativ
e
ev
aluation
or
handle
excep-
tions.
{
The
most
imp
ortan
t
feature
of
exception
and
in
terrupt
handling
mec
ha-
nisms
is
the
abilit
y
to
sp
ecify
ho
w
to
clean
up
shared
state.
In
imp
erativ
e
languages,
is
necessary
to
write
y
our
o
wn
clean
up
co
de
since
the
language
cannot
b
e
exp
ected
to
kno
w
ho
w
to
restore
y
our
program
to
a
consisten
t
state.
This
is
not
necessary
in
the
pure
subset
of
Hask
ell
(i.e.,
the
part
of
Hask
ell
where
blac
k-holing
is
used)
b
ecause
the
the
lac
k
of
side-eects
limits
the
problems
to
those
in
tro
duced
b
y
the
implemen
tation.
In
the
imp
erativ
e
subset
of
Hask
ell,
the
programmer
m
ust
write
their
o
wn
clean
up
co
de
|
w
e
recen
tly
added
exception-handling
to
Hask
ell
for
this
purp
ose
[0,
].
{
Multiscalar
pro
cessors
p
erform
a
considerable
amoun
t
of
sp
eculativ
e
ev
alu-
ation
and
m
ust
clean
up
their
in
ternal
state
when
a
sp
eculativ
e
ev
aluation
is
terminated.
F
or
example,
Breac
h
et
al.
[]
describ
e
an
arc
hitecture
whic
h
trac
ks
dep
endencies
b
et
w
een
dieren
t
stages
of
the
pro
cessor.
T
erminating
one
stage
automatically
terminates
those
stages
whic
h
ha
v
e
used
v
alues
pro-
duced
b
y
the
terminating
stage.
Lik
e
our
tec
hnique,
clean
up
is
p
erformed
automatically;
unlik
e
our
approac
h
w
ork
done
b
y
the
stage
is
discarded
to
undo
side-eects
(and
also
to
conserv
e
resources).

Conclusions
The
Spineless
T
agless
G-Mac
hine
is
an
ecien
t
graph-reduction
mac
hine
whic
h
stores
the
spine
of
the
graph
on
the
stac
k
(rather
than
storing
it
on
the
heap)
and
whic
h
uses
blac
k-holing
to
a
v
oid
the
resulting
space
leak.
This
optimisation
comes
at
a
cost:
w
e
can't
resume
in
terrupted
ev
aluations
b
ecause
blac
k-holing
assumes
that
th
unks
are
only
en
tered
once.
W
e
ha
v
e
sho
wn
that
this
problem
can
b
e
resolv
ed
ecien
tly
b
y
restoring
the
spine
of
the
graph
to
the
heap
and
w
e
ha
v
e
outlined
ho
w
it
in
teracts
with
a
range
of
extensions
to
the
language
and
to
the
implemen
tation.

Ac
kno
wledgemen
ts
W
e
are
grateful
to
Simon
P
eyton
Jones,
Simon
Marlo
w
and
John
P
eterson
for
commen
ts
on
our
approac
h
and
on
this
pap
er
and
to
P
aul
Hudak
and
Greg
Hager
whose
in
terest
in
programming
rob
ots
in
Hask
ell
help
ed
motiv
ate
this
w
ork.
W
e
are
also
grateful
to
the
anon
ymous
referees
for
their
in
teresting
and
useful
feedbac
k
|
w
e
found
the
p
oin
ters
to
related
w
ork
outside
the
Hask
ell
comm
unit
y
particularily
in
triguing.
References
.
S.
Breac
h,
T.
N.
Vija
ykumar,
and
G.
S.
Sohi.
The
anatom
y
of
the
register
le
in
a
m
ultiscalar
pro
cessor.
In
th
A
nnual
International
Symp
osium
on
Micr
o
ar
chi-
te
ctur
e
(MICR
O-),
pages
{	0.
A
CM
press,
		.
.
M.
Chakra
v
art
y
.
Lazy
thread
and
task
creation
in
parallel
graph-reduction.
In
Pr
o
c
e
e
dings
of
IFL'	,
v
olume

of
Le
ctur
e
Notes
in
Computer
Scienc
e,
pages
{	.
Springer
V
erlag,
Septem
b
er
		.
.
R.
J.
M.
Hughes.
The
Design
and
Implementation
of
Pr
o
gr
amming
L
anguages.
PhD
thesis,
Oxford
Univ
ersit
y
,
	.
.
R.
J.
M.
Hughes.
P
arallel
functional
languages
use
less
space.
In
Symp
osium
on
Lisp
and
F
unctional
Pr
o
gr
amming,
Austin,
	.
.
M.
Jones.
The
implemen
tation
of
the
Gofer
functional
programming
system.
Re-
searc
h
Rep
ort
Y
ALEU/DCS/RR-00,
Y
ale
Univ
ersit
y
,
Ma
y
		.
.
R.
E.
Jones.
T
ail
recursion
without
space
leaks.
Journal
of
F
unctional
Pr
o
gr
am-
ming,
():{	,
Jan
uary
		.
.
J.
S.
Mattson
Jr.
and
W.
G.
Grisw
old.
Sp
eculativ
e
ev
aluation
for
parallel
graph
reduction.
In
Par
al
lel
A
r
chite
ctur
es
and
Compilation
T
e
chniques,
pages
{.
North-Holland,
August
		.
.
S.
P
eyton
Jones.
Implemen
ting
lazy
functional
languages
on
sto
c
k
hardw
are:
the
Spineless
Tagless
G-mac
hine.
Journal
of
F
unctional
Pr
o
gr
amming,
():{0,
April
		.
	.
S.
P
eyton
Jones,
A.
Gordon,
and
S.
Finne.
Concurren
t
Hask
ell.
In
Principles
of
Pr
o
gr
amming
Languages,
pages
	{0.
A
CM
press,
Jan
uary
		.
0.
S.
P
eyton
Jones,
A.
Reid,
T.
Hoare,
S.
Marlo
w,
and
F.
Henderson.
A
seman
tics
for
imprecise
exceptions.
In
Pr
o
gr
amming
L
anguages
Design
and
Implementation.
A
CM
press,
Ma
y
			.
.
A.
Reid.
Handling
Exceptions
in
Hask
ell.
Researc
h
Rep
ort
Y
ALEU/DCS/RR-
,
Y
ale
Univ
ersit
y
,
Departmen
t
of
Computer
Science,
August
		.
.
C.
Runciman
and
D.
W
ak
eling.
Heap
proling
of
lazy
functional
programs.
Journal
of
F
unctional
Pr
o
gr
amming,
():{,
April
		.
.
J.
Sparud.
Fixing
some
space
leaks
without
a
garbage
collector.
In
Pr
o
c.
Confer
enc
e
on
F
unctional
Pr
o
gr
amming
L
anguages
and
Computer
A
r
chite
ctur
e.
A
CM,
		.
.
P
.
T
rinder,
K.
Hammond,
J.
Mattson
Jr,
A.
P
artridge,
and
S.
P
eyton
Jones.
GUM:
a
p
ortable
parallel
implemen
tation
of
Hask
ell.
In
Pr
o
gr
amming
L
anguages
Design
and
Implementation,
pages
	{.
A
CM
press,
		.
.
P
.
L.
W
adler.
Fixing
a
space
leak
with
a
garbage
collector.
Softwar
e
|
Pr
actic
e
and
Exp
erienc
e,
(	):	{0,
	.

