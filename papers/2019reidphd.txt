Deﬁning interfaces between hardware and software:
Quality and performance
Alastair David Reid
M.Sc. (University of Glasgow) 1994
B.Sc. (University of Strathclyde) 1988
Submitted in fulﬁlment of the requirements for the
Degree of Doctor of Philosophy
School of Computing Science
College of Science and Engineering
University of Glasgow
March 2019


i
To Edye Hoffmann
Wife, best friend and tireless cheerleader.

ii
c⃝Copyright
Alastair David Reid
All rights reserved
2019

Abstract
One of the most important interfaces in a computer system is the interface between hardware
and software. This interface is the contract between the hardware designer and the programmer
that deﬁnes the functional behaviour of the hardware. This thesis examines two critical aspects
of deﬁning the hardware-software interface: quality and performance.
The ﬁrst aspect is creating a high quality speciﬁcation of the interface as conventionally de-
ﬁned in an instruction set architecture. The majority of this thesis is concerned with creating a
speciﬁcation that covers the full scope of the interface; that is applicable to all current imple-
mentations of the architecture; and that can be trusted to accurately describe the behaviour of
implementations of the architecture. We describe the development of a formal speciﬁcation of
the two major types of Arm processors: A-class (for mobile devices such as phones and tablets)
and M-class (for micro-controllers). These speciﬁcations are unparalleled in their scope, ap-
plicability and trustworthiness. This thesis identiﬁes and illustrates what we consider the key
ingredient in achieving this goal: creating a speciﬁcation that is used by many different user
groups. Supporting many different groups leads to improved quality as each group ﬁnds dif-
ferent problems in the speciﬁcation; and, by providing value to each different group, it helps
justify the considerable effort required to create a high quality speciﬁcation of a major processor
architecture. The work described in this thesis led to a step change in Arm's ability to use formal
veriﬁcation techniques to detect errors in their processors; enabled extensive testing of the spec-
iﬁcation against Arm's ofﬁcial architecture conformance suite; improved the quality of Arm's
architecture conformance suite based on measuring the architectural coverage of the tests; sup-
ported earlier, faster development of architecture extensions by enabling animation of changes
as they are being made; and enabled early detection of problems created from architecture ex-
tensions by performing formal validation of the speciﬁcation against semi-structured natural
language speciﬁcations. As far as we are aware, no other mainstream processor architecture has
this capability. The formal speciﬁcations are included in Arm's publicly released architecture
reference manuals and the A-class speciﬁcation is also released in machine-readable form.
The second aspect is creating a high performance interface by deﬁning the hardware-software
interface of a software-deﬁned radio subsystem using a programming language. That is, an in-
terface that allows software to exploit the potential performance of the underlying hardware.
While the hardware-software interface is normally deﬁned in terms of machine code, periph-
iii

iv
ABSTRACT
eral control registers and memory maps, we deﬁne it using a programming language instead.
This higher level interface provides the opportunity for compilers to hide some of the low-level
differences between different systems from the programmer: a potentially very efﬁcient way
of providing a stable, portable interface without having to add hardware to provide portability
between different hardware platforms. We describe the design and implementation of a set of
extensions to the C programming language to support programming high performance, energy
efﬁcient, software deﬁned radio systems. The language extensions enable the programmer to
exploit the pipeline parallelism typically present in digital signal processing applications and to
make efﬁcient use of the asymmetric multiprocessor systems designed to support such applica-
tions. The extensions consist primarily of annotations that can be checked for consistency and
that support annotation inference in order to reduce the number of annotations required. Reduc-
ing the number of annotations does not just save programmer effort, it also improves portability
by reducing the number of annotations that need to be changed when porting an application from
one platform to another. This work formed part of a project that developed a high-performance,
energy-efﬁcient, software deﬁned radio capable of implementing the physical layers of the 4G
cellphone standard (LTE), 802.11a WiFi and Digital Video Broadcast (DVB) with a power and
silicon area budget that was competitive with a conventional custom ASIC solution.
The Arm architecture is the largest computer architecture by volume in the world. It be-
hooves us to ensure that the interface it describes is appropriately deﬁned.

Contents
Abstract
iii
Contents
v
List of Figures
vii
Acknowledgements
ix
Preface and Declaration
xi
1
Deﬁning interfaces between hardware and software
1
1.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1.1
Organisation
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.2
Creating high quality deﬁnitions of hardware-software interfaces . . . . . . . .
2
1.2.1
Literature survey . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.2.2
Overview of published work . . . . . . . . . . . . . . . . . . . . . . .
10
1.2.3
Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
1.2.4
Limitations and further work . . . . . . . . . . . . . . . . . . . . . . .
13
1.2.5
Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
1.3
Deﬁning high performance hardware-software interfaces . . . . . . . . . . . .
15
1.3.1
Literature survey . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
1.3.2
Overview of published work . . . . . . . . . . . . . . . . . . . . . . .
19
1.3.3
Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
1.3.4
Limitations and further work . . . . . . . . . . . . . . . . . . . . . . .
22
1.3.5
Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
1.4
Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
1.4.1
Limitations and further work . . . . . . . . . . . . . . . . . . . . . . .
24
v

vi
CONTENTS
I
Creating high quality deﬁnitions of the hardware-software interface 25
2
Trustworthy Speciﬁcations of ARM v8-A and v8-M System Level Architecture (Pa-
per I)
29
3
End-to-End Veriﬁcation of ARM Processors with ISA-Formal (Paper II)
39
4
Who guards the guards? Formal Validation of the ARM v8-M Architecture Speci-
ﬁcation (Paper III)
59
II
Creating high performance hardware-software interfaces
85
5
SoC-C: efﬁcient programming abstractions for heterogeneous multicore systems on
chip (Paper IV)
89
6
Reducing inter-task latency in a multiprocessor system (Patent I)
101
Appendices
131
Bibliography
131

List of Figures
1.1
Virtuous cycle created by multiple users sharing a common speciﬁcation . . . .
4
1.2
Overview of speciﬁcations, tools, veriﬁcation IP and testing. Adapted from Fig-
ure 1 of Paper I with addition of more recent ﬂows. The contents of the dashed
box is the result of a collaboration with Cambridge University on their Sail ISA
speciﬁcation language and tools [8]. A machine-readable version of the Archi-
tecture Speciﬁcation has been publicly released by Arm Limited on the Arm
website [5] and the translation of that speciﬁcation to Sail has been publicly
released by the REMS group at Cambridge University [104]. . . . . . . . . . .
5
1.3
The architecture of a communication-processing subsystem. This system con-
sists of one RISC processor, ﬁve processing elements and six DMA engines
(highlighted in grey), ﬁve private memories and one shared memory. Repro-
duced from Paper IV. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
1.4
Illustration of the effect of optimization of task invocations. The control proces-
sor (CP) and each data engine (DE0, P, Q and R) are on the vertical axis and
time is on the horizontal axis. These ﬁgures are reproduced from Figures 5a, 5c
and 7 in Patent I.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
vii

viii

Acknowledgements
This thesis was written in the middle of my research career and I have beneﬁted enormously
from people at different institutions along the way. At the University of Glasgow, Muffy Calder
gave me a solid grounding in the techniques of research. At Yale University, Paul Hudak and
John Peterson taught me the importance of publishing and of applying my research to other
ﬁelds. At the University of Utah, Jay Lepreau gave me the conﬁdence to start forming my
own research agenda while Matthew Flatt and John Regehr taught me how to ﬁnd interesting
problems and how to explain my work. At Arm, Kris Flautner had the insight that my work
on stream computation and accelerators would form a critical part of the "Ardbeg" Software
Deﬁned Radio project; his talent for forming strong teams and of providing a clear vision, both
internally and externally, has inspired a lot of how I try to work today. At the University of
Cambridge, Peter Sewell has encouraged me to raise my game and to make my work more
open. Finally, Simon Gay at the University of Glasgow helped me to navigate the process of
submitting a PhD by published work.
I would like to thank my managers and coworkers at Arm Limited for their help and support.
On the Ardbeg project, I would like to thank Mladen Wilder and Kate Kneebone for their support
and their friendship during a project with many highs and lows. My managers Stephen Hill and
Eric Van Hensbergen provided strong support during the early days of developing Architecture
Explorer when others could not see the value of executable speciﬁcations. The processor teams
persuaded me that the complexity of modern processors was beyond the capability of traditional
test-based veriﬁcation: we had to ﬁnd a way to use formal veriﬁcation. David Seal created the
original pseudocode speciﬁcation of the Arm architecture. If I had not had David's speciﬁcation
as a starting point, I would probably not have started working on Arm speciﬁcations. Sadly,
David left Arm before the Architecture Explorer project started so he never saw his speciﬁcation
run. While I was busy formalizing the Arm speciﬁcation, David Gilday was ﬁnding ways to
use formal veriﬁcation tools and techniques to verify processors: David was a constant source
of enthusiasm, encouragement and ideas. I also beneﬁted enormously from working with Will
Keen, Anastasios Deligiannis, Lewis Russell, Erin Shepherd and the Teal team while developing
ISA-Formal — it was an honour to work with the entire ISA-Formal team.
I would like to thank my fellow "Sailors" in the REMS group at the University of Cambridge
and especially Peter Sewell, Alasdair Armstrong, and Kathy Gray. They have taught me many
ix

x
ACKNOWLEDGEMENTS
things but I especially value their commitment to creating formal speciﬁcations of major, real-
world artifacts (e.g., ISAs, TCP/IP, etc.) and the many things I learned by reﬂecting on Sail's
design and implementation choices.
Users are of tremendous importance in systems research. I would like to thank Danny Ker-
shaw and the Nokia LTE Research group for their feedback on the SoC-C language. I would
especially like to thank Tom Grocutt and François Botman at Arm for their enthusiastic adoption
of the Architecture Explorer tool and their patience with its limitations.
I would like to thank my friends Nathan Chong and John Regehr who helped me with advice,
suggestions and encouragement and gave feedback on early drafts of this thesis.
I wish that my dear friend John Peterson was here to mock me for engaging in this foolish
quest. He was probably kidding about carrying his climbing pack and the threat of cannibalism
if benighted near the summit; but I am glad that I now qualify for an exemption.
I will be forever grateful to my parents John and Anne Reid for their love and for helping
me to get the education that has opened so many doors for me. I love you both very much and
wish you were here to see what you helped me to achieve and how the words you wrote when I
left Glasgow turned out.
— William Shakespeare

Preface and Declaration
The portfolio of publications in this submission represents a selection of the applicant's aca-
demic papers and patents since 2004 while employed in the Research Department of Arm Lim-
ited. Arm has two primary businesses: the design of high-performance, low-energy micropro-
cessors; and the creation of the Arm architecture speciﬁcation that is licensed to more than
15 other companies who create compatible implementations of the same architecture speciﬁca-
tion. In the year 2017, 21.3 billion chips containing Arm compatible processors were manufac-
tured [6] making Arm the largest processor architecture on the planet by a signiﬁcant margin.
This thesis presents four peer-reviewed papers and one granted US patent. The papers are
published in the high impact international journal PACMPL and in the proceedings of high
impact international conferences CAV, FMCAD and CASES.
Alastair David Reid is the lead author and corresponding author on all four of the papers.
Alastair David Reid is the sole inventor of the patented invention. The patented invention
was initially considered by Arm's internal Patent Review Committee to determine whether the
invention was patentable and of sufﬁcient value to Arm. As is customary, the patent ﬁling was
prepared by a patent attorney based on the inventor's description of the invention and detailed
discussion with the inventor; the ﬁnal ﬁling was reviewed by the inventor; and the inventor
worked with the patent attorney to respond to any objections raised by the patent examiner.
Before being granted, the patent submission was examined by an examiner in the United States
Patent and Trademark Ofﬁce (USPTO) and found to meet the requirements of being novel, useful
and non-obvious.
All work in this thesis was carried out by the author unless otherwise explicitly stated.
Submission
The work is presented in two parts that examine key aspects of deﬁning the hardware-software
interface.
xi

xii
PREFACE AND DECLARATION
Creating trustworthy deﬁnitions of the hardware-software interface
This part is concerned with the creation of trustworthy formal speciﬁcations of the Arm v8-A
and v8-M processor architectures and consists of three papers.
Paper I "Trustworthy Speciﬁcations of ARM v8-A and v8-M System Level Architecture"
[98] describes the process of creating a speciﬁcation with a particular focus on scope, applica-
bility and trustworthiness.
Paper II "End-to-End Veriﬁcation of ARM Processors with ISA-Formal" [101] describes a
collaboration with formal veriﬁcation engineers in Arm's Processor Design Division to ﬁnd a
way to formally validate the pipeline of Arm processors against the formal speciﬁcation.
Paper III "Who guards the guards? Formal Validation of the ARM v8-M Architecture Spec-
iﬁcation" [100] describes the use of formal veriﬁcation tools to formally validate the formal
speciﬁcation described in Papers I and II.
I am the sole author of Paper I and Paper III. Paper II is the result of a collaboration with
a group of nine very talented and committed hardware veriﬁcation engineers working in Arm's
processor division: Rick Chen, Anastasios Deligiannis, David Gilday, David Hoyes, Will Keen,
Ashan Pathirane, Erin Shepherd, Peter Vrabel, and Ali Zaidi. I am the sole writer of the paper
although the other authors provided useful feedback about whether the paper accurately de-
scribed the hardware aspects of the project and they provided several suggestions for improving
the writing. When I started working with these veriﬁcation engineers, a manual version of the
ISA-Formal method of using model checkers to detect a challenging class of bugs had already
been developed and demonstrated on two of Arm's micro-controllers. The challenge was that the
method would require the creation and maintenance of a speciﬁcation of Arm's entire instruc-
tion set written in Verilog. My contribution to the project was the formal Arm speciﬁcation that
I had been creating; the development of a series of transformations that convert the executable
speciﬁcation into readable, synthesizable Verilog that would be accepted by the bounded model
checker being used; and the initial version of the Arm Formal Veriﬁcation Interface that proces-
sors must support to enable the ISA-Formal process. During the course of the project, I worked
with the hardware engineers to design extensions to this veriﬁcation interface such as support for
verifying memory operations and to generalise it for use with other processors. The veriﬁcation
engineers worked on multiple processor projects and created veriﬁcation code (not included in
the ﬁnal chips) that would extract information about each processor's state, inputs and outputs
— a task requiring considerable skill and ingenuity on their part. The veriﬁcation engineers also
had the task of running the model checker each week, sifting through failures, generating bug
reports for designers to deal with, checking whether proposed bug ﬁxes eliminated problems
and setting up for the next week's veriﬁcation run.

xiii
Deﬁning high performance hardware-software interfaces
This part is concerned with deﬁning the hardware-software interface in a way that allows the
software to exploit the potential performance of the underlying hardware.
This part consists of one paper and one patent.
Paper IV "SoC-C: efﬁcient programming abstractions for heterogeneous multi-core systems
on chip" [102] describes the design and implementation of a set of extensions to the C program-
ming language that direct the mapping of that program to different parts of a heterogeneous
multiprocessor system.
Patent I "Reducing inter-task latency in a multiprocessor system" [103] describes an exten-
sion of the ideas in Paper IV that is able to exploit a broad range of different kinds of task
triggering/sequencing hardware to reduce the latency between tasks running on the different
processors within the system.
I am the sole inventor of Patent I. Paper IV has four authors: myself (Arm), Krisztián Flaut-
ner (Arm), Edmund Grimley-Evans (Arm) and Yuan Lin (University of Michigan). I am the
sole writer of the paper although Krisztián provided some useful suggestions for improving the
opening section. Krisztián Flautner lead the Ardbeg project and identiﬁed that the transforma-
tion I had developed was related to the decoupling transform used with decoupled access/execute
computer architectures [112]. Edmund Grimley-Evans joined the SoC-C team once most of the
compiler was in place and was responsible for extending and maintaining the compiler. Yuan
Lin was working on the sister project "SODA" [120] at the University of Michigan under the
supervision of Professor Trevor Mudge. Yuan identiﬁed the challenge of performance portable
programming but we proposed completely different approaches to programming the system:
Yuan Lin proposed the SPEX language [74] that is based on stream programming and I pro-
posed the SoC-C language described in Paper IV that is based on imperative programming. We
each listed the other as an author on our papers about our different languages to acknowledge
the role of the other in forming our ideas.

xiv

Chapter 1
Deﬁning interfaces between hardware and
software
1.1
Introduction
Computer systems consist of large stacks of different kinds of technology: from chemical and
lithographic processes used to manufacture silicon chips at the bottom of the stack; through
pipelining and out-of-order execution in microprocessors; through programming languages and
operating systems; all the way up to applications and user-interfaces at the top of the stack.
Between each of these layers is an interface that abstracts away some of the details of the layer
below to insulate the layer above from changes in the layer below.
This thesis is concerned with one of the most fundamental of these interfaces: the interface
between hardware and software. This interface is important because it is used by many different
groups: processor designers; tool creators writing assemblers, compilers, JITs and debuggers;
operating system writers; creators of processor simulators; veriﬁcation engineers creating test
suites for processors and simulators; library writers; etc. Given its importance, it is essential that
this interface is well deﬁned and that it is designed in a way that enables efﬁcient implementation
of the interface.
This thesis explores two key aspects of this interface that are of critical importance to indus-
try:
Creating high quality deﬁnitions of the hardware-software interface The ﬁrst and primary
aspect is creating high quality speciﬁcations of microprocessors that are complete enough
and accurate enough that they can be used for formal veriﬁcation. Section 1.2 describes
the development of formal, executable speciﬁcations of the Arm v8-A and v8-M processor
architectures; steps taken to test the speciﬁcations; use of the speciﬁcations to formally
validate commercial Arm processors against the speciﬁcation; and formal validation of
the speciﬁcations.
1

2
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
This speciﬁcation is now part of Arm's ofﬁcial speciﬁcation and it has been released pub-
licly in Arm's Architecture Reference Manuals [3,4] and in machine readable form [5,99].
As far as we are aware, the resulting speciﬁcation is the most complete and most trust-
worthy speciﬁcation of any mainstream processor architecture. The formal speciﬁcation
and the validation methodology we developed led to a step change in Arm's ability to
formally validate the processors they design. The methodology has been deployed on ﬁve
commercial processors developed by Arm and is being rolled out onto the next generation
of Arm processors and to Arm's other design centres in France and the USA.
Deﬁning high performance hardware-software interfaces The second aspect of the hardware
software interface considered in this thesis is deﬁning an interface that allows software to
exploit the potential performance of the underlying hardware. Section 1.3 describes the
use of programming language extensions and compiler technology that allow complex
parallel hardware to be programmed in a simple, portable way without sacriﬁcing perfor-
mance.
We demonstrate how raising the boundary between software and hardware can expose the
potential performance of the hardware to the programmer while allowing the hardware
designer to use a broad variety of techniques to provide an efﬁcient, high-performance
system.
The SoC-C language and compiler were signiﬁcant components of Arm's Ardbeg project:
a project that developed hardware, software and tools for creating software deﬁned ra-
dios [120].
1.1.1
Organisation
The remainder of this thesis is structured as follows: Sections 1.2 and 1.3 describe each aspect
of deﬁning the hardware-software interface: the related work, contributions, limitations and
potential future work. Section 1.4 concludes and considers limitations that apply to the entire
body of work. Parts I and Part II contain the published work consisting of four peer-reviewed
papers and one granted US patent.
1.2
Creating high quality deﬁnitions of hardware-software in-
terfaces
The main aspect of deﬁning the hardware-software interface considered in this thesis is the cre-
ation of trustworthy formal speciﬁcations of processor architectures. The three publications ex-
ploring this aspect develop, extend and apply techniques to create, test, use and formally validate
formal speciﬁcations of complex, real-world artefacts. Besides these technical contributions, the

1.2. QUALITY DEFINITIONS OF HARDWARE-SOFTWARE INTERFACES
3
papers also describe and form part of the social process of building trust and consensus around
the speciﬁcation.
Three key properties of a processor speciﬁcation are its scope, its applicability and its trust-
worthiness.
The scope of a speciﬁcation is the set of features that one can reason about. For example,
a certiﬁed compiler such as CompCert [72] only requires a speciﬁcation of those instructions
that the compiler could generate. But in order to reason about arbitrary user-mode binaries, one
would need a speciﬁcation of the entire instruction set. And to reason about Operating System
code, the scope of the speciﬁcation is dramatically increased and includes a speciﬁcation of
instructions for changing execution mode (e.g., entering/leaving supervisor mode), interrupt
handling mechanisms, page faults, mechanisms for changing memory protection, etc. Prior to
our work, all formal speciﬁcations of the Arm architecture were targeted at reasoning about the
behaviour of instructions with no support for system-level features such as memory protection
or taking an exception in response to a page fault.
The applicability of a processor speciﬁcation is whether the speciﬁcation applies to the target
processor. Most changes to architecture speciﬁcations are backward compatible extensions and
so most proofs about code for one architecture version are valid when executing that code on
a processor implementing a later architecture version. But architecture revisions also remove
instructions, add restrictions or change functionality so proofs based on the ARMv6 speciﬁcation
(1996) or the ARMv7-A speciﬁcation (2007) are not necessarily sound for ARMv8-A (2013).
This is especially true for Arm's micro-controller architecture that has a completely different
exception model from Arm's mainstream architecture.
The trustworthiness of a processor speciﬁcation is whether the speciﬁcation can be trusted
to reﬂect the behaviour of all processors implementing the speciﬁcation. The Arm HOL speciﬁ-
cation of Fox and Myreen [46] is noteworthy for the degree of testing performed: systematically
testing all user-mode, integer instructions against three actual processors. This is a critical step
and must be repeated against as many expressions of the architecture as possible (processors,
implementations, test suites, etc.) and must go beyond simply testing user-mode instructions
and test the full scope of the speciﬁcation: ﬂoating point and vector instructions, exceptions,
interrupts, privilege checks, virtual memory, etc.
The effort required to create a speciﬁcation increases with the desired scope, applicability
and trustworthiness of the speciﬁcation. Worse, since Arm regularly releases extensions and cor-
rections to the architecture, the challenge of retaining applicability to current processors is more
of a continuous process than a one-off sprint. Our solution to this problem has been to change
Arm's existing architecture speciﬁcation process so that machine-readable, executable speciﬁ-
cations can be automatically generated from the same materials used to generate conventional
documentation. These changes required not just technical solutions but also the development of
a process for agreeing on and building trust in the speciﬁcations.

4
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
A key aspect of this process was the decision to create a single speciﬁcation that is shared
between multiple groups. We found that doing this creates a virtuous cycle where each time
one group ﬁnds and ﬁxes a bug in the speciﬁcation, it improves the utility of the speciﬁcation
for other groups and, over time, enables more demanding groups to make use of the speciﬁca-
tion (Figure 1.1). For example, the "ISA-Formal" team (Paper II) required that each instruction
speciﬁcation that they used be correct and required clariﬁcations about the intended priority of
different forms of underspeciﬁcation while those creating testsuites required that the exception
model be correct since many architectural tests revolve around checking that the correct ex-
ception is generated at the right time and is accompanied by the correct exception syndrome
information. In addition, the sharing of a speciﬁcation created an understanding across the
different user groups of which parts of the speciﬁcation were trustworthy and which required
further work before they could be trusted.
Figure 1.1: Virtuous cycle created by multiple users sharing a common speciﬁcation
Supporting multiple groups is also essential to build the business case for the consider-
able cost of creating, debugging and maintaining a large speciﬁcation. Figure 1.2 provides
an overview of the variety of different uses that our speciﬁcation currently supports.
These beneﬁts are not without a cost: the speciﬁcation language is a compromise between
all the different user groups. Some groups would ﬁnd it more convenient if the speciﬁcation was
written in some other language and they require tools to translate the speciﬁcation into the form
their tools require but the advantages of having a single speciﬁcation outweigh the costs.

1.2. QUALITY DEFINITIONS OF HARDWARE-SOFTWARE INTERFACES
5
Architecture
Explorer
Properties/Invariants
Instruction Encodings
Instruction ASL
System ASL
ASL
Architecture Speciﬁcation
Test Monitor ASL
Directed Tests
Architecture Conformance Tests
System Registers
Callgraph
Abstract Syntax Tree
Sail
OCaml
Coq
HOL
Software Validation
Arm CPU RTL
Verilog codegen
Veriﬁcation Testbench
Bounded Model Checker
CPU Validation
SMT
Interpreter
C++ codegen
Z3
Information Flow
Speciﬁcation Validation
Test Coverage
Trace Comparison
Testsuite Development
Figure 1.2: Overview of speciﬁcations, tools, veriﬁcation IP and testing.
Adapted from Figure 1 of Paper I with addition of more recent ﬂows. The contents of the dashed box is the result of a collaboration with
Cambridge University on their Sail ISA speciﬁcation language and tools [8]. A machine-readable version of the Architecture Speciﬁcation has
been publicly released by Arm Limited on the Arm website [5] and the translation of that speciﬁcation to Sail has been publicly released by the
REMS group at Cambridge University [104].

6
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
1.2.1
Literature survey
Some of the earliest formal speciﬁcations of computer architecture were Falkoff et al.'s use of
APL to describe the IBM System/360 [37] and Bell and Newell's "Instruction Set Processor"
(ISP) notation [14] that was used to write speciﬁcations for 14 systems including the PDP-8,
PDP-11 and CDC 6600 and that later gave rise to Barbacci's machine readable "Instruction Set
Processor Semantics" (ISPS) [11] that targets compiler-related uses. ISP followed in the Al-
gol language tradition and is similar to the less formal pseudocode notations typically used in
ISA deﬁnitions in the present day. ISP was used during design of the PDP-11 and included
in the manufacturer's processor handbook [28]. Some of the earliest uses of formal seman-
tics were for automatic reasoning about programs such as Samet's development of Translation
Validation [106, 107] (later reinvented and reﬁned by Pnuelli [94] and Necula [87]) and auto-
matic derivation of compiler code generators by Fraser [48] (based on ISP speciﬁcations of the
IBM-360 and PDP-10) and Cattell [24] (based on ISPS speciﬁcations of the IBM-360, PDP-8,
PDP-10, PDP-11, Intel 8080, and Motorola 6800).
Since those early days, many other uses of formal speciﬁcations have been found includ-
ing verifying compilers [70, 72, 86]; verifying assembly language functions against a speciﬁ-
cation [80]; verifying operating systems [31, 53, 68, 110]; discovery, veriﬁcation and synthesis
of peephole optimisations [9, 66, 78]; automatic generation of binary translations between ar-
chitectures [10]; verifying processor pipelines [17, 42, 64, 101]; automatic generation of test
cases [51,79]; decompilation of binaries [85,89]; and abstract interpretation of binaries [95,96].
Creating a speciﬁcation that can support this broad range of potential uses affects how the
speciﬁcation is written. If a formal speciﬁcation is being used to mechanically verify hardware
or software in a theorem prover, it is common to write the speciﬁcation using the language of the
theorem prover using either a deep or shallow embedding [21]. If a shallow embedding is used,
it is also necessary to overcome mismatches between the semantic features of the speciﬁcation
using the theorem prover's language. For example Goel et al. [54, 55] use abstract stobjs to
encode state and constrained functions to encode undeﬁned behaviour, Fox and Myreen [46] use
monads to encode state and exceptions.
A signiﬁcant limitation of embedding a speciﬁcation in a theorem prover is that it limits
reuse of the speciﬁcation: it is hard to use the same speciﬁcation with other theorem provers
or for non-proof purposes. This is a signiﬁcant problem because it fragments efforts at creat-
ing speciﬁcations between the user communities of the major interactive theorem provers (e.g.,
ACL2 [67], Coq [27], HOL [57], Isabelle-HOL [88]), model checkers (e.g., JasperGold
R
⃝[23]
and SymbiYosys [121]) and SMT solvers (e.g., Z3 [33] and CVC4 [13]). Embedding a spec-
iﬁcation in a theorem prover also has the problem of impacting readability: the speciﬁcation
is only really usable to those familiar with a particular theorem prover. This almost certainly
necessitates the creation of multiple speciﬁcations: one for each tool one wishes to use plus an-
other for humans to read. Having multiple separate speciﬁcations leads to a further problem of

1.2. QUALITY DEFINITIONS OF HARDWARE-SOFTWARE INTERFACES
7
trust: how can one trust that the different versions of the speciﬁcation are consistent with each
other? To address these limitations, we follow the common approach of writing the speciﬁca-
tion in an external Domain Speciﬁc Language (DSL) speciﬁcally designed for writing processor
speciﬁcations [11,25,38,45,124] and mechanically translate the speciﬁcation into the languages
of different formal veriﬁcation tools. In Mishra and Dutt's taxonomy [83], the DSL described
in this thesis would be classiﬁed as a "Behavioural Architecture Description Language." That
is, it describes the externally visible behaviour of a processor without necessarily reﬂecting the
hardware structures that might implement it. In contrast, a "Structural Architecture Description
Language" closely reﬂects the hardware structure they describe and are primarily used to gener-
ate and verify hardware designs. Structural speciﬁcations reveal implementations details mak-
ing them suited to specifying microarchitecture while behavioural speciﬁcations abstract away
inessential differences between different implementations making them best suited to specifying
processor architecture.
A major challenge tackled in the papers in this section is how to create a trustworthy formal
speciﬁcation of the entire architecture that includes all instructions, address translation, memory
protection, interrupts, exceptions, etc. Most processor speciﬁcations in existence are for sim-
pler architectures such as the IBM/360 [37] or are for a subset of the architecture such as the
instruction set [40,46] or are only for outdated (and smaller) architectures such as the ARMv6
architecture [111].
Fonseca et al.'s empirical study of the correctness of formally veriﬁed systems found bugs in
speciﬁcations [41]. One way of establishing trust in a speciﬁcation is by testing speciﬁcations
against existing implementations [8, 40, 46, 56, 98, 111]. The quality of testing depends on the
accuracy of the test oracle [12] and on the completeness of the tests used. Formal veriﬁcation of
a processor against a speciﬁcation [42,64,101] has the desirable side-effect of detecting bugs in
the speciﬁcation and ensuring compatibility.
Creating a fully veriﬁed stack of hardware and software eliminates the need to trust the pro-
cessor speciﬁcation. Notable steps in this direction are: the "CLI stack" of Computational Logic
Inc. [16] that consisted of FM8502 processor, the Piton assembler and a code generator for the
micro-Gypsy language (a Pascal derivative); and the Verisoft project that produced the VAMP
out-of-order processor implementing the DLX ISA [17] and PikeOS hypervisor [109]. More re-
cently, the CakeML project succeeded in creating a formally veriﬁed processor "Silver" [77] and
a formally veriﬁed compiler for a dialect of ML [70] that can compile itself and so the compiler
can both generate code for Silver and the compiler can run on Silver itself.
There are two main classes of formal ISA speciﬁcations: speciﬁcations of the system-level
features such as address translation or taking an exception and speciﬁcations of the instruction
set.

8
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
System-Level Speciﬁcations
A major milestone for an executable processor speciﬁcation is demonstrating that it can boot
an operating system up to the ﬁrst command prompt: demonstrating the ability to take inter-
rupts, implement virtual memory, etc. Fox's MIPS speciﬁcation [45] written in L3 has been
shown to boot FreeBSD. Fox's Arm speciﬁcations [45] contains some system features but lack
memory protection and address translation or the ability to take an exception in response to a
failed permission check. Our speciﬁcation is more complete (the v8-A architecture speciﬁca-
tion includes all 1280 instructions, all four privilege levels, both secure and non-secure modes,
address translation, reset, interrupts and exceptions) and has been more thoroughly tested (we
test all four levels and both security modes and we test that privilege checks deny access when
appropriate). Armstrong et al. [8] develop formal speciﬁcations of Arm v8-A, RISC-V, MIPS
and CHERI-MIPS written in Sail that have been shown to boot Linux, seL4 or FreeBSD. The
Arm v8-A model is a translation of our ASL speciﬁcation implying that our speciﬁcation can
also boot Linux.1
Goel's x86-64 speciﬁcation [56] is embedded in ACL2 and includes key parts of the system
architecture including paging, segmentation and both user/supervisor levels. The speciﬁcation
has been used to verify both user-mode code and system-mode code: a "zero-copy" program that
duplicates memory by manipulating the page table to create aliases in the virtual address space.
Instead of embedding the speciﬁcation inside any particular theorem prover (such as ACL2),
our speciﬁcation is written in a simple, imperative speciﬁcation language and different backends
translate it into the languages required by different users: C++, Verilog, SMT2 and Sail [8,59].
We believe that using a DSL and actively pursuing and supporting different user groups is critical
to creating a trustworthy speciﬁcation: each different use stresses the speciﬁcations in different
ways and ﬁnds different classes of bugs in the speciﬁcation.
The Verisoft-XT project developed a substantial speciﬁcation of x86 processors encompass-
ing the concurrency model, 140 general-purpose and system programming instructions and se-
curity mechanisms such as memory protection and hypervisor support [34]. Their goal was to
enable the formal veriﬁcation of low level software (hypervisors). Like our work, the Verisoft-
XT speciﬁcation is written in a domain speciﬁc language in order to keep the speciﬁcation read-
able and compact. The speciﬁcation differs in having a different scope: it adds a concurrency
model and parts of the platform architecture such as the APIC interrupt controller but it supports
only a fraction of the full x86 instruction set. The more signiﬁcant difference lies in trustworthi-
ness. While Degenbaev [34, Chapter 19] describes techniques that they could potentially apply
to test their speciﬁcation; we developed and applied multiple approaches including testing using
Arm's architecture conformance suite, formal validation of processors against the speciﬁcation
and formal validation of the speciﬁcation itself. We consider this investment in trustworthiness
to be critical when creating a speciﬁcation that will be used for formal veriﬁcation purposes.
1This has since been conﬁrmed within Arm with assistance from Armstrong.

1.2. QUALITY DEFINITIONS OF HARDWARE-SOFTWARE INTERFACES
9
We are not aware of any x86 processor speciﬁcation that can boot an operating system.
Running an operating system on an x86 processor speciﬁcation would require not only the x86-
64 features needed to run an OS but, since x86 processors power up in a legacy mode, one would
also require support for legacy modes to support the boot process.
Instruction Set Speciﬁcations
Over a period of more than 18 years, Fox and others at the University of Cambridge have de-
veloped and used speciﬁcations of multiple versions of the Arm processor architecture starting
with an ARMv3 speciﬁcation written in HOL [47] that was used to formally verify the ARM6
processor microarchitecture [42,43], later updated to support the ARMv4-ARMv7 architecture
versions [46] and tested against actual hardware. This speciﬁcation was then converted to a
domain speciﬁc language L3 [44, 45] that can be translated to HOL and a speciﬁcation of the
integer AArch64 instructions from the ARMv8 architecture was added. For a long time, this
was the most complete and highest quality formal speciﬁcation of the Arm architecture and this
series of speciﬁcations has been used in the formal veriﬁcation of microkernels [110], hyper-
visors [31] and compilers [70, 86]. Our speciﬁcation is more complete (the v8-A architecture
speciﬁcation includes both AArch32 and AArch64 modes and all instructions); has been more
thoroughly tested; and, like the original Fox speciﬁcation, has been further validated through its
use in the formal validation of Arm processors.
There are a number of notable speciﬁcations of the x86 instruction set. RockSalt [84] is a
formally veriﬁed implementation of Software Fault Isolation that relies on the ability to perform
an analysis of (a subset of) x86 machine code. A key part of RockSalt is an x86 instruction
speciﬁcation that covers 130 instruction encodings with semantics for 70 instructions. This
speciﬁcation is written in an embedded DSL in Coq and has been validated by extensive testing
against executions of (compiled) randomly generated C programs and constrained random se-
quences of the implemented instructions. An important difference from our work is the reduced
scope: RockSalt only describes a small subset of the x86 instruction set and does not describe
system architecture features such as address translation.
Goel's x86-64 speciﬁcation [56] embedded in ACL2 includes 413 instructions (as well as
the system architecture features mentioned above) and has been veriﬁed against real proces-
sors using the Pin binary instrumentation tool. Both the ACL2 and RockSalt speciﬁcations are
embedding within a theorem prover enabling them to formally verify their reasoning about the
speciﬁcation including reasoning about any transformations/analysis they perform on the speci-
ﬁcation. This is a powerful capability that our Arm speciﬁcations lack.
Heule [62] used synthesis techniques to generate speciﬁcations of 1,795 variants out of 3,684
instruction variants in the x86-64 Haswell ISA. This speciﬁcation formed the basis for two
recent speciﬁcations that describe the complete x86-64 user-space instruction set: Roessle et
al.'s Chum speciﬁcation [105] to support decompilation of binaries using HOL; and Dasgupta

10
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
and Adve's speciﬁcation written using the K-framework [32]. Both speciﬁcations stand out for
the completeness of their support of the instruction set and the degree of testing performed on
their speciﬁcations.
Recently, Huang et al. have generalized the notion of Instruction Set Architecture (ISA) to an
"Instruction-Level Abstraction" (ILA) [63] that extends the familiar instruction model found in
programmable processors to semi-programmable accelerators. They have demonstrated that this
framework can be used to formally specify and verify both accelerators (for image processing,
machine learning and cryptography) and general-purpose processors (RISC-V). Zhang et al.
have further extended the ILA framework with a memory consistency model and associated
veriﬁcation tools [123].
An, apparently promising, alternative approach to creating a processor speciﬁcation is to
generate it automatically based on experiments run on particular processors [52, 62]. This ap-
proach can lead to overﬁtting: Godefroid identiﬁed a number of instructions whose functional
behaviour differed across the range of processors used in their experiments [52].
1.2.2
Overview of published work
The speciﬁcations described in this thesis are written using a Domain Speciﬁc Language called
the Arm Architecture Speciﬁcation Language (ASL).2 ASL is an executable, strongly-typed, im-
perative language with support for dependent types and for throwing and catching exceptions.
For the ﬁrst 20-25 years of Arm's history, speciﬁcations were created after the corresponding
implementation as documentation of what had been built. This pattern has changed as a re-
sult of the work described in this thesis and speciﬁcations are now written and tested before
implementation starts.
The ASL language was created by reverse engineering a speciﬁcation language from the
pseudocode notation used in Arm's existing documentation, ﬁxing the pseudocode in the doc-
umentation and evolving that pseudocode into a formal speciﬁcation. This choice of evolution,
not revolution enabled a smooth transition from the ofﬁcial, informal pseudocode to a formal
speciﬁcation with trust in the speciﬁcation gradually increasing as new user groups successfully
used the speciﬁcation. An earlier, more revolutionary, attempt to replace Arm's architecture
speciﬁcation with a more formal speciﬁcation had failed to gain traction and had been aban-
doned. We believe that a major factor was that replacing the speciﬁcation required buy in from
multiple groups at once whereas the slower, incremental process of submitting bugﬁxes and fo-
cussing on providing value to one group at a time deferred the need for Arm architects to make
a decision until after support had been built across the company. An early example of building
cross-company support is that a member of the validation team that writes architectural testsuites
asked if it was possible to measure coverage of their tests against the architecture. Measuring
coverage was not a high priority for me at the time but it helped people who had helped me, it
2There is no connection to the ASL speciﬁcation language that was the subject of the author's M.Sc. thesis [97].

1.2. QUALITY DEFINITIONS OF HARDWARE-SOFTWARE INTERFACES
11
took little effort to implement and it led both to the validation team championing the work and
to practical help from the validation team. Thereafter, I sought to repeat this experience with
other groups in order to establish the virtuous cycle of Figure 1.1.
This section presents three papers that tackle different aspects of creating, using and check-
ing this speciﬁcation.
Paper I "Trustworthy Speciﬁcations of ARM v8-A and v8-M System Level Architecture"
[98] describes the ﬁrst 5 years of the project to change Arm's existing architecture speciﬁcation
process so that machine-readable, executable speciﬁcations can be automatically generated from
the same materials used to generate Arm's conventional architecture documentation.
The focus of this paper is on the different methods (summarised in Figure 1.2) used to im-
prove our trust in the speciﬁcation and the various uses of the speciﬁcation.
A key contribution of this work was a scalable, sustainable methodology for creating high
quality formal speciﬁcations. To achieve the broad scope required, we developed methods for
deﬁning and testing the system architecture by extending the speciﬁcation with a programmable
monitor and stimulus generator. To the best of our knowledge, such testing has not previously
been applied to architecture speciﬁcations. A major output of this work was the creation of
formal speciﬁcations of Arm's v8-A and v8-M processor architectures — a critical prerequisite
for the formal veriﬁcation of Arm processors.3 The formal speciﬁcation now forms part of Arm's
ofﬁcial architecture speciﬁcation and has been publicly released in machine readable form [5].
Paper II "End-to-End Veriﬁcation of ARM Processors with ISA-Formal" [101] describes a
collaboration with formal veriﬁcation engineers in Arm's Processor Design Division to develop
a repeatable method of formally validating the instruction pipelines of Arm processors against
the Arm v8-A and v8-M speciﬁcations described in Paper I.
The ISA-Formal method described in the paper uses a bounded model checker that uses
symbolic techniques to validate sequences of instructions up to some bound. The approach was
tested on a small scale on three processors using hand-written System Verilog assertions that
implemented partial speciﬁcations of a few dozen instructions. To turn the approach from a
promising idea into a viable veriﬁcation ﬂow that could be broadly applied, two problems had
to be overcome:
Scaling The Arm v8-A speciﬁcation has over 1,280 instruction encodings; the Arm v8-M spec-
iﬁcation has over 380 instruction encodings. Each instruction has many potential effects:
writing registers, writing ﬂags, accessing memory, raising exceptions, etc. Manually writ-
ing properties to check each instruction for each possible effect would be a monumental
task and the result would inevitably contain bugs and divergences from Arm's ofﬁcial
speciﬁcation. The solution was to ﬁnd a way of automatically translating the speciﬁca-
tion from ASL to a language that commercial model checkers would accept (Verilog).
3Adaptations to the formal v8-A speciﬁcation to include the v8-R architecture are underway.

12
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
Deﬁning a standard veriﬁcation interface Arm designs large numbers of processors to target
different niches with radically different pipeline structures. Deﬁning a standard veriﬁ-
cation interface was critical to creating a veriﬁcation ﬂow that can be applied across the
entire range. This was created by refactoring the manual interface used with the System
Verilog assertions into a higher level interface that the machine-generated Verilog could
interface with.
Paper III "Who guards the guards? Formal Validation of the ARM v8-M Architecture Spec-
iﬁcation" [100] tackles a fundamental problem with executable architecture speciﬁcations: they
contain little or no redundancy. This lack of redundancy is especially problematic when extend-
ing the architecture because existing test suites do not cover any new extensions so testing is not
able to detect when an extension breaks cross-cutting properties involving security, the ability
to return from exceptions, etc. The paper describes the creation of a meta-speciﬁcation of the
architecture and tools to verify that the architecture speciﬁcation satisﬁes the meta-speciﬁcation.
Despite the high level of testing already performed on the speciﬁcation, this found a further
12 conﬁrmed bugs.
1.2.3
Contributions
The contributions of the published work in this section consist of both technical developments
and a signiﬁcant impact on the design and veriﬁcation practices of the world's largest processor
designer that affects both the creation of processor architecture speciﬁcations and the veriﬁcation
of processors.
• I created a methodology to develop high quality processor architecture speciﬁcations with
a particular focus on features of the system architecture (e.g., page table walks, memory
protection, privilege checks and system registers) [98, 100]. This methodology involves
reverse-engineering a language "hidden within" the pseudocode previously used, ﬁlling
gaps in the speciﬁcation, building tool chains to read and execute the speciﬁcation, build-
ing monitors and stimulus generators to support testing of system architecture, testing
the speciﬁcation, measuring the coverage of processor test suites, automatically translat-
ing the speciﬁcation to Verilog and to the SMT-Lib2 format and formal validation of the
speciﬁcation. In addition to these technical developments, I developed a process to build
consensus around the speciﬁcation and to create a virtuous cycle where multiple groups
share a common speciﬁcation such that bug reports and ﬁxes from one group beneﬁt all
other groups.
I applied the methodology to both the Arm A-class and M-class speciﬁcations and the
methodology has been adopted by the teams responsible for developing new architecture
extensions including TrustZone for M-class (TZM) [4] that added new privilege levels
to the micro-controller architecture; and the Scalable Vector Extension (SVE) [113] that

1.2. QUALITY DEFINITIONS OF HARDWARE-SOFTWARE INTERFACES
13
added 488 new instructions to the v8-A architecture. The executable speciﬁcation is used
within Arm as a "golden reference". The A-class speciﬁcation has been publicly released
in machine-readable form under a liberal license.
• I created a highly effective, repeatable, formal validation methodology [101] that could
be applied in an industrial setting to formally validate processors against the formal spec-
iﬁcation of the architecture. The methodology was applied to ﬁve commercial processors
(Arm's Cortex A32, A35, A55, R52 and M33). The methodology has proved to be very
effective at ﬁnding complex bugs that other techniques might have missed and also at ﬁnd-
ing simple bugs earlier in development than traditional test-based validation techniques.
This led to a step change in Arm's use of formal veriﬁcation techniques on its processors.
The methodology is being rolled out onto the next generation of processor development
projects. Beyond Arm, the ISA-Formal validation approach has already been adapted for
use on RISC-V processors in the "riscv-formal" ﬂow [122] and a company "Symbiotic
EDA" has been created to provide formal validation services to RISC-V implementers.
• There have been two signiﬁcant public releases of Arm's speciﬁcation. In 2017, Arm
publicly released around 90% of the v8.2-A speciﬁcation and subsequent public releases
included the v8.3, v8.4 and v8.5 extensions [5].
In addition, Arm has released the entire
v8.5-A speciﬁcation to the REMS group at Cambridge University. With my assistance,
they have created tools to (mostly) automatically translate the speciﬁcation from ASL
to their "Sail" ISA speciﬁcation language and they have created translators to convert
Sail to C, Isabelle and Coq [7, 8, 59]. The process of performing this translation lead to
several Sail language extensions that were necessary to handle the size and complexity
of a commercial processor architecture. The C code generated from their tools has been
tested using Arm's internal architecture conformance test suite; is able to boot the Linux
kernel; and the translated code has been used to prove properties about the virtual memory
system using Isabelle. Cambridge University has publicly released both the translated
speciﬁcation and their tools [104]. We hope that this will lead to many new uses of the
speciﬁcation. (This work is described in a recent POPL paper [8] that is not included in
this thesis.)
To our knowledge, no other major processor company has these capabilities or has chosen
to release a formal speciﬁcation of its architecture.
1.2.4
Limitations and further work
This work has transformed the use of formal speciﬁcation and veriﬁcation within Arm and has
created a single reference that those outside Arm can freely use.

14
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
Future work that is already underway includes: extending the range of uses by, for example,
using the speciﬁcation as a reference for traditional test-based veriﬁcation of processors; for-
mally specifying the ASL language used in the speciﬁcation; continuing the work reported in
Paper III to check more of the v8-M architecture and to start checking the v8-A architecture.
Future work that is still in the proposal stages includes improving the performance of simu-
lators perhaps using Pydgin [76].
The most signiﬁcant limitations of this work are associated with underspeciﬁcation: where
the speciﬁcation allows for a range of allowed behaviours. Forms of underspeciﬁcation found in
Arm speciﬁcations includes implementation deﬁned behaviour; unknown values4; unpredictable
behaviour; and non-determinism in exception raising. This is the subject of ongoing discussion
with Arm architects. The main challenge in clarifying underspeciﬁcation is in creating a deﬁni-
tion that is simultaneously useful to programmers; applicable to existing implementations; and
provides the desired degree of implementation freedom to hardware designers. For example, the
notion of unknown values is used both to describe the non-determinism of register values when
hardware is powered up and also to describe situations where different microarchitectural states
can lead to different values. Teasing apart these different notions of "unknown" apart would
enable each notion to have a narrower, more useful deﬁnition.
The interaction of underspeciﬁcation with security is especially important. Arm's Architec-
ture Reference Manual [3] says "An UNKNOWN value must not return information that cannot
be accessed at the current or a lower level of privilege ..." but such statements are hard to test.
In practice, individual processor implementations tend to choose a deterministic value such as a
zero value but that does not help those verifying the security of software that must run on any
implementation.
Some other limitations of the speciﬁcations in this work include: they do not capture the se-
mantics of weak memory [1,40,108]; they do not specify the assembly language syntax; limited
testing of multiprocessor, debug and performance monitoring features; they lack speciﬁcations
for interrupt controllers, I/O MMUs, Arm's "TrustZone" support in interconnect, and other fea-
tures needed to reason about low-level system software.
Architecture speciﬁcations have traditionally limited themselves to the functional behaviour
of processors. This traditional view excludes timing information and speculation induced ef-
fects since details such as the execution time of an instruction is viewed as a detail of a speciﬁc
implementation, not an architectural requirement. The growing awareness of microarchitectural
side-channel attacks [50] has lead to the notion of "data independent timing" in Arm v8.4-A
where the execution time of certain instructions is independent of the data being processed by
the instruction. The discovery of speculative side-channel attacks such as "Meltdown" [75],
and "Spectre" [69] lead to the further addition of speculation barrier instructions that control
speculative memory accesses. A critical next step will be ﬁnding a way to formally specify
4Other ISA speciﬁcations use the term "undeﬁned values" for what Arm calls "unknown" values.

1.3. DEFINING HIGH PERFORMANCE HARDWARE-SOFTWARE INTERFACES
15
the semantics of these extensions (and of existing features such as ﬂushing caches, branch pre-
dictors, etc.) in order to support reasoning about side channels in software. Cock et al. [26]
measured the impact of mitigations such as deterministic scheduling, scheduled delivery, cache
colouring and TLB ﬂushing on the channel capacity of known side channels. In addition to
measuring and mitigating high-level microarchitecture details, they found new channels caused
by the low-level implementation details such as an impact of branch mispredictions on the cy-
cle counter reinforcing the need for thorough veriﬁcation of processor implementations against
such a semantics. McIlroy et al. [81] is an early step towards such a semantics but their empha-
sis on determinism limits them to describing just one processor instead of the full envelope of
behaviour allowed by the architecture.
Finally, when we started this work, Arm relied on the fact that the deﬁnition of the archi-
tecture was, in effect, spread across several artefacts within Arm: the Architecture Reference
Manual, a "golden simulator," and a test suite. Our goal is to turn the formal speciﬁcation into
a "perfect" speciﬁcation against which these other artefacts are measured. This would automat-
ically guarantee consistency but, by reducing redundancy, it brings the risk of creating a single
point of failure. Our efforts in creating a meta-speciﬁcation in Paper III and in recruiting many
different user groups are intended to reduce this risk.
1.2.5
Conclusions
This section is concerned with creating complete speciﬁcations of commercially important pro-
cessor architectures and in establishing trust in those speciﬁcations. The central idea is of cre-
ating a single speciﬁcation that is used by many different teams in order to create a virtuous
cycle. This approach has proved effective in transforming the approach of the largest designer
of microprocessors in the world to formal speciﬁcation and veriﬁcation and has resulted in the
creation of a formal speciﬁcation of unparalleled scope, applicability and trustworthiness that
can be used both inside and outside the company.
1.3
Deﬁning high performance hardware-software interfaces
The previous section focuses on functional aspects of the interface but does not mention non-
functional aspects such as the timing or energy requirements of an instruction or the silicon area
required to implement an instruction.
In general purpose microprocessors, portability between different hardware designs is usu-
ally achieved by adding hardware such as pipeline interlocks to hide pipelining hazards and
register renaming to hide out of order execution from the programmer. This portability comes at
the cost of extra hardware to give the illusion of sequential execution and a signiﬁcant fraction
of the potential parallelism of the hardware is lost. One way to exploit the potential performance

16
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
is to expose all the hardware features to the programmer but that decreases portability because
programs will only work on systems providing the same features. Some Very Large Instruction
Word (VLIW) processors [39] tackle this problem by requiring programmers to program them
in a high level language such as LISP or C instead of using assembly level: tackling performance
portability with programming language extensions and compiler technology. This section ap-
plies a similar approach to the problem of programming asymmetric multiprocessing (AMP)
systems designed to handle Digital Signal Processing (DSP) pipelines.
The physical layer of the cell radio interface that lies at the heart of modern cellphones is
traditionally implemented using a combination of hardware blocks that provide little or no con-
ﬁgurability or programmability and are therefore limited to implementing a small number of
protocols and require modiﬁcations to the chip if a bug is found or the protocol speciﬁcation is
changed. Software Deﬁned Radio (SDR) aims to disrupt this model by replacing most of the
ﬁxed function blocks with programmable processors. SDR applications can have extremely high
processing requirements (in excess of 10Gops per second) and, to compete with conventional
ﬁxed-function hardware designs, they must operate on tight power budgets (a fraction of a Watt).
Achieving such extreme performance on such a small power budget requires that the hardware
platform exploits numerous techniques to save energy and boost performance: processors pro-
vide a high degree of data and instruction level parallelism; each processor is provided with
private data and instruction memories to which they have faster, more efﬁcient access; DMA
engines are provided to copy data from one processor's private memory to another's; some ﬁxed
function accelerators are provided for functionality that is required by a large number of different
protocols (e.g., an accelerator for error correction such as a Turbo decoder); and a simple RISC
control processor is charged with loading programs into each processor's instruction memories,
with sequencing different parts of the algorithm across the platform and with handling small, low
performance parts of the protocol. Figure 1.3 illustrates a communication-processing subsystem
that might be used in a Software Deﬁned Radio (SDR) system.
The approach explored in this section is to support porting software from a conventional
computer (e.g., a desktop computer) to such specialised architectures by adding a small number
of annotations to the program. These annotations guide the compiler to adapt the program to the
particular compute system. The goal of this work was not to completely automate the mapping
of software to such hardware but, rather, to provide the programmer with an interface that allows
them to use their insight into the trade-offs to unlock extremely high levels of performance by
making small changes in the annotations.
The language and compiler were developed as part of Arm's "Ardbeg" research project to
develop a Software Deﬁned Radio (SDR) platform. This project developed ﬁve co-designed
components: a DSP engine based on a 512-bit SIMD vector unit that could sustain over 10
billion multiplies per second at less than 300mW in 65nm technology [120]; a programming
model and tools for the DSP engine; a system architecture combining multiple DSP engines,

1.3. DEFINING HIGH PERFORMANCE HARDWARE-SOFTWARE INTERFACES
17
GPP
ADC
DAC
Host
I/F
Timers
IRQ
Ctrl
SIMD PE
Turbo PE
Mem
Global Mem
Mem
DMA
DMA
DMA
SIMD PE
Mem
SIMD PE
Mem
SIMD PE
Mem
Mem
M0
M1
M3
M2
CM3
PE0
PE1
PE2
PE3
Turbo
TM
Global
Local
IN
OUT
DMA3
DMA
DMA2
DMA
DMA1
DMA
DMA0
Figure 1.3: The architecture of a communication-processing subsystem. This system consists of
one RISC processor, ﬁve processing elements and six DMA engines (highlighted in grey), ﬁve
private memories and one shared memory. Reproduced from Paper IV.

18
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
accelerators, DMA engines, private memories and a control processor (see Figure 1.3); a pro-
gramming model and tools for the system architecture; and software to test and demonstrate the
capabilities of these components including implementations of the physical layer processing of
4G cellphones, 802.11a WiFi and DVB digital video broadcast. This section is concerned with
the system programming model and tools.
1.3.1
Literature survey
Programming DSP and SDR systems is conventionally performed in a very low-level way: code
uses numerous techniques such as double-buffering, DMA-transfers, interrupt handlers, etc. to
make efﬁcient use of the available hardware and achieve maximal parallelism. Programming
in this fashion results in software whose structure is determined by the hardware platform and
by the decision of which tasks to map to each part of the system. This need to match software
structure to hardware structure means that porting the application to different hardware or even
experimenting with a different mapping is a signiﬁcant and error prone effort.
Our solution to these problems is to draw on a number of techniques familiar in the program-
ming language, computer architecture and systems communities:
• The (synchronous) remote procedure call (RPC) [19] model simpliﬁes triggering code
execution on remote processors by making it look like a function call. Greater parallelism
can be achieved by sacriﬁcing some of this simplicity and using asynchronous RPCs [2].
• Software distributed shared memory [15,65,73] simpliﬁes a potentially complex memory
topology to look like a single shared address space by introducing data copies at the right
places to implement cache coherency.
• Providing efﬁcient compiler support for domain speciﬁc languages and library-speciﬁc
optimisations by annotating libraries with information to guide optimisation of applica-
tions using the library [61,93,118].
• "Decoupling" transformations to introduce pipeline parallelism into sequential programs
by splitting programs into independent threads communicating via FIFO queues [22, 30,
35, 90, 92, 112, 114, 114, 116]. The techniques used range from entirely manual, through
requiring some annotation to fully automatic.
• Double-buffering and other zero-copy interfaces efﬁciently implement FIFO queues by
queuing buffer pointers instead of copying data [117].
• There has been a long-running dispute over the relative merits of thread-based and event-
based systems [29, 71, 91, 119] based on their impact on programming, ease of program
analysis, and efﬁciency. Decoupling transformations introduces threads but, on resource-
constrained systems, event-based systems have compelling performance advantages [49].

1.3. DEFINING HIGH PERFORMANCE HARDWARE-SOFTWARE INTERFACES
19
Cooperatively threaded code can be transformed to event-based code using variations on
Duff's device [36,115] or equivalent compiler transforms.
• Type inference mechanisms such as that found in the Hindley-Milner type system [82]
provides a way of inferring annotations without sacriﬁcing signiﬁcant expressiveness.
1.3.2
Overview of published work
Paper IV draws on all these inﬂuences to provide a way of mapping software deﬁned radio ap-
plications onto heterogeneous multiprocessor systems. The paper describes the design and im-
plementation of a set of extensions to the C programming language that tackle the performance
portability problem by allowing the programmer to lightly annotate their program to indicate
the desired mapping of tasks and variables onto the system. The SoC-C model is of a program
running on a single control processor and performing remote procedure calls to accelerators,
DSP engines and DMA engines. The SoC-C compiler takes care of (radically) restructuring the
program to run efﬁciently.
SoC-C was a reaction against the dataﬂow-based stream programming model exempliﬁed by
StreamIt [58]. We chose a sequential communication language instead of a dataﬂow language
because we found it hard to express global control (i.e., conditionals that span multiple pipeline
stages) over pipeline stages that execute asynchronously with respect to each other. Using de-
coupling to introduce parallelism, gives the ease of expression of global control that imperative
languages provide combined with the pipeline parallelism that stream languages provide.
Several alternative approaches to decoupling programs exist [22, 30, 35, 90, 114, 116]. A
distinctive feature of our approach is that the annotations can indicate that a non-FIFO com-
munication mechanism should be used — we found that this was helpful in avoiding "loss of
decoupling" [18] where parallelism collapses because the start of the pipeline requires results
from the end of the pipeline.
Patent I [103] tackles a problem we identiﬁed after some experience of using SoC-C. We
realised that the control processor was becoming a bottleneck: when a task ﬁnished on one ac-
celerator, there was an unavoidable delay of 50-60 cycles before the next task in the sequence
was started. Figure 1.4a illustrates this with an example task invocation pattern where the com-
pletion of a ﬁrst task A triggers an interrupt that causes the control processor to conﬁgure and
start a second task B.
Patent I describes an extension of Paper IV that is able to exploit a variety of different sim-
ple task triggering hardware mechanisms to reduce this delay between tasks to a few cycles.
Figure 1.4b illustrates this with an improved invocation pattern where the completion of task A
directly triggers the start of a second task B that had been conﬁgured while task A was executing.
The "description of embodiments" section in columns 11-28 of Patent I describes how acceler-
ator interfaces can often be viewed as a FIFO task queue (typically with a modest capacity of

20
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
(a) Unoptimised execution: The Control Processor CP initiates tasks on the data engine DE0 and receives
interrupts when each task completes.
(b) Optimized execution: The Control Processor CP performs setup of task B while task A is running on
data engine DE0. The completion of task A directly triggers the start of task B without the intervention
of CP.
(c) Highly optimized execution of a multiprocessor example using inter-engine event triggering mecha-
nism. Edges between data engines are labelled with the event number that is sent when the source task
completes. The Control Processor CP performs setup of tasks (e)-(j) to run on data engines P, Q and R;
data engines use the event triggering mechanism to allow completion of tasks to directly trigger the start
of new tasks on other engines. The CP only receives one interrupt from the six tasks and the latency
between tasks is reduced to a few cycles (the latency of event signalling and of task startup/shutdown.
Figure 1.4: Illustration of the effect of optimization of task invocations. The control processor
(CP) and each data engine (DE0, P, Q and R) are on the vertical axis and time is on the horizontal
axis. These ﬁgures are reproduced from Figures 5a, 5c and 7 in Patent I.

1.3. DEFINING HIGH PERFORMANCE HARDWARE-SOFTWARE INTERFACES
21
0-3 pending tasks). Modeling these queues explicitly enables the data queue optimizations in
Paper IV to be adapted to the optimization of task queues.
A synchronous RPC can be viewed as putting an RPC request into a task queue and then
waiting for an RPC request from the accelerator (column 13). This model enables the compiler
to optimize a sequence of synchronous RPCs
by ﬁrst splitting the RPCs into a sequence of RPC-put/get pairs
then reordering the puts and gets to eliminate the inter-task latency
obtaining the beneﬁts of asynchronous RPCs without the usual programmer burden.
Even with these optimizations, the cost of creating a task queue entry can be signiﬁcant when
it occurs on the critical path. A further set of optimizations (columns 21-23) describe how the
zero-copy optimizations applied to data queues can also be applied to task queues by further
splitting each of the RPC-put/get operations into two parts.
This exposes the expensive task creation step (RPC_acquireRoom) providing opportunities
for the compiler to reschedule sequences of RPC operations to remove task creation from the
critical path. A key part of these transformations is tracking the data dependencies and the

22
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
number of pending tasks to determine which reorderings are safe to perform and to allow the
RPC sub-operations to be reordered with respect to non-RPC operations.
If accelerators are able to send events to each other when a task completes and to delay
task start until an event arrives, then it is possible to optimize more complex patterns of task
invocation involving multiple accelerators as illustrated in Figure 1.4c (columns 16-19).
The key to implementing such transforms was the realization that many different hardware
mechanisms for task conﬁguration and sequencing can be modelled as FIFOs; that this uniform
model allows extensive optimisation of task creation and task triggering; and that this enables
the use of a broad range of optimizations more normally used for instruction scheduling. One
of the main technical challenges is that the FIFOs are ﬁnite (and usually quite small) so it is
essential to reason about how full the FIFOs are relative to their individual capacity in order to
avoid introducing potential deadlock and other problems.
1.3.3
Contributions
The technical contributions of this section include a set of annotations and inference techniques
to deﬁne the mapping of an application onto a high-performance, energy-efﬁcient parallel sys-
tem, a set of compiler techniques to implement the annotations efﬁciently and a uniﬁed model
of hardware interfaces that enabled these techniques to be applied to a broad range of different
accelerators in such systems.
In addition to these technical contributions, the work played a key role as part of a commer-
cial system development. From an early stage in the Ardbeg project, the team recognised that
long-term success depended not just on the high performance DSP accelerators but also on the
ease with which the overall system could be programmed. The SoC-C compiler described in this
section was a key part of the overall project. The Ardbeg project was spun out of Arm in 2009
to create "Cognovo Ltd" that specialised in the creation of Software Deﬁned Modems although
SoC-C was not part of that spinout. Cognovo successfully manufactured a chip capable of im-
plementing the 4G LTE standard based on the Ardbeg reference design. Cognovo was acquired
by the Swiss wireless modem company "u-blox" for $16.5M in 2012.
1.3.4
Limitations and further work
One of the major limitations of our work is that SoC-C maintains a clear separation of the coor-
dination and control language (SoC-C) from the language used to program the DSP engines. In
a software deﬁned radio application, each DSP task typically contains considerable data paral-
lelism and may contain some potential pipeline parallelism but the only way for the programmer
to exploit this pipeline parallelism would be to split the tasks into subtasks to expose this poten-
tial to SoC-C. A more uniﬁed description of the control language with the DSP language would
expose more optimisation opportunities.

1.4. CONCLUSIONS
23
General Purpose Graphics Processing Units (GPGPUs) have similar characteristics to SDR
systems: they have complex memory hierarchies, multiple processors and are often programmed
using the same techniques of pipeline parallelism and double-buffering. At the time that we
performed the work (2006-2008), users of such systems often struggled with the quantity and
complexity of "boilerplate" code that had to be written to copy data from the main processor
over to the GPGPU, to invoke tasks on the GPU and to wait for the GPGPU to ﬁnish. In the-
ory, this is the problem that SoC-C is designed to handle although, in practice, we expect that
SoC-C would, at least, need extensions to express data parallelism to be useful. In the inter-
vening 10 years, OpenCL has been extended with explicit task queues and the SYCL embedded
domain-speciﬁc language (EDSL) [60] that enables the programmer to dynamically specify the
dependencies between tasks. Use of SYCL does not enable the rich set of compile-time trans-
formations performed by SoC-C but it has the advantage of not requiring a custom compiler.
Similarly, OpenMP has been extended with better support for expressing task-parallelism such
as explicit tasks and task synchronization [20]. This provides OpenMP with a lot of the expres-
sive power of SoC-C (in addition to the data-parallelism support it already provided) although it
would be useful to add the annotation checking and inference of SoC-C to OpenMP.
Finally, SoC-C is not a fully automatic solution: the programmer must choose the mapping of
tasks and data to the hardware platform. It would be interesting to add a proﬁle-driven mapping
algorithm on top of SoC-C to automatically discover efﬁcient mappings; this would beneﬁt from
SoC-C's ability to detect invalid mappings.
1.3.5
Conclusions
This section explores the deﬁnition of high performance hardware-software interfaces by raising
the level of the interface. The paper and patent in this section of the published work describe
programming language extensions and compiler technology that allow software to exploit the
potential performance of the hardware but, at the same time, provide a high degree of portability.
1.4
Conclusions
This thesis is concerned with deﬁning the hardware-software interface in modern microproces-
sors and makes contributions in two key aspects:
• Creating high quality deﬁnitions of the interface resulting in: a methodology for creating
a formal speciﬁcation of unparalleled scope, applicability and trustworthiness; a method-
ology for formally validating commercial processor pipelines against the formal speciﬁca-
tion; and the public release of the formal speciﬁcation of a major commercial architecture.
• Deﬁning high performance hardware-software interfaces resulting in a set of language
extensions and compiler techniques for tackling the performance portability problem in

24
CHAPTER 1. DEFINING INTERFACES BETWEEN HARDWARE AND SOFTWARE
high performance, energy efﬁcient asymmetric multiprocessor systems used for software
deﬁned radio.
1.4.1
Limitations and further work
The two individual parts of this thesis identiﬁed individual limitations. One common limitation
is that all this work was performed at a single company and that company inevitably has certain
preconceptions about the hardware-software interface based on its particular role in the computer
industry and on its business model. For example, a software team with no ambitions for formal
veriﬁcation might place more value on other aspects of the architecture speciﬁcation such as
the clarity of the English prose; and performance portability may be more important to the
hardware vendor wishing to sell an upgraded system than it is to a programmer who may be
perfectly content with the previous system.
There are also many other facets of the hardware-software interface that have not been ex-
plored in this thesis. Two key aspects for the future are security and supporting signiﬁcantly
more parallelism in the hardware-software interface.

Part I
Creating high quality deﬁnitions of the
hardware-software interface
25


27
Three papers are presented in this section.
Paper I "Trustworthy Speciﬁcations of ARM v8-A and v8-M System Level Architecture"
[98] describes the process of creating a speciﬁcation and of thoroughly testing the speciﬁcation.
Paper II "End-to-End Veriﬁcation of ARM Processors with ISA-Formal" [101] describes a
collaboration with formal veriﬁcation engineers in Arm's Processor Design Division to ﬁnd a
way to formally verify the pipeline of Arm processors against the formal speciﬁcation.
Paper III "Who guards the guards? Formal Validation of the ARM v8-M Architecture Spec-
iﬁcation" [100] describes the use of formal veriﬁcation tools to formally validate the formal
speciﬁcation described in Papers I and II.

28

Chapter 2
Trustworthy Speciﬁcations of ARM v8-A
and v8-M System Level Architecture
(Paper I)
Alastair Reid. Trustworthy speciﬁcations of ARM v8-A and v8-M system level architecture. In
Proceedings of Formal Methods in Computer-Aided Design, (FMCAD 2016), Mountain View,
CA, USA, pages 161-168, October 2016.
c⃝2016 Alastair David Reid and FMCAD, Inc.
doi: https://dx.doi.org/10.1109/FMCAD.2016.7886675
29

30
CHAPTER 2. TRUSTWORTHY SPECIFICATIONS

Trustworthy Speciﬁcations of ARM
R⃝v8-A and
v8-M System Level Architecture
Alastair Reid
Research, ARM Ltd.
ﬁrst.last@arm.com
Abstract—Processor speciﬁcations are of critical importance
for verifying programs, compilers, operating systems/hypervisors,
and, of course, for verifying microprocessors themselves. But to
be useful, the scope of these speciﬁcations must be sufﬁcient for
the task, the speciﬁcation must be applicable to processors of
interest and the speciﬁcation must be trustworthy.
This paper describes a 5 year project to change ARM's exist-
ing architecture speciﬁcation process so that machine-readable,
executable speciﬁcations can be automatically generated from the
same materials used to generate ARM's conventional architecture
documentation. We have developed executable speciﬁcations of
both ARM's A-class and M-class processor architectures that
are complete enough and trustworthy enough that we have
used them to formally verify ARM processors using bounded
model checking. In particular, our speciﬁcations include the
semantics of the most security sensitive parts of the processor: the
memory and register protection mechanisms and the exception
mechanisms that trigger transitions between different modes.
Most importantly, we have applied a diverse set of methods
including ARM's internal processor test suites to improve our
trust in the speciﬁcation using many other expressions of the
architectural speciﬁcation such as ARM's simulators, testsuites
and processors to defend against common-mode failure. In the
process, we have also found bugs in all those artifacts: testing
speciﬁcations is very much a two-way street.
While there have been previous speciﬁcations of ARM pro-
cessors, their scope has excluded the system architecture, their
applicability has excluded newer processors and M-class, and
their trustworthiness has not been established as thoroughly.
Our focus has been on enabling the formal veriﬁcation of
ARM processors but, recognising the value of this speciﬁcation
for verifying software, we are currently preparing a public release
of the machine-readable speciﬁcation.
I. INTRODUCTION
Recent years have seen an increasing focus on veriﬁcation of
machine-code programs [1], compilers [2], operating system
kernels [3], hypervisors [4] and processors [5]. These activ-
ities rely on having correct speciﬁcations of the meaning of
machine-code and one of the ﬁrst steps in such veriﬁcation
efforts is creating a speciﬁcation of the computer architecture
of interest.
Three key properties of a processor speciﬁcation are its
scope, its applicability and its trustworthiness.
The scope of a speciﬁcation is the set of features that
one can reason about. For example, a certiﬁed compiler
such as CompCert [2] only requires a speciﬁcation of those
instructions that the compiler could generate. But in order to
reason about arbitrary user-mode binaries, one would need
a speciﬁcation of the entire instruction set. And to reason
about Operating System code, the scope of the speciﬁcation
is dramatically increased and includes a speciﬁcation of in-
structions for changing execution mode (e.g., entering/leaving
supervisor mode), interrupt handling mechanisms, page faults,
mechanisms for changing memory protection, etc. To date,
all formal speciﬁcations of the ARM architecture have been
targetted at reasoning about user-mode programs and have not
included a speciﬁcation of these system-level features.
The applicability of a processor speciﬁcation is whether the
speciﬁcation applies to the target processor. Most changes to
architecture speciﬁcations are backward compatible extensions
and so most proofs about code for one architecture version are
valid when executing that code on a processor implementing
a later architecture version. But architecture revisions also
remove instructions, add restrictions or change functionality
so proofs based on the ARMv6 speciﬁcation (1996) or the
ARMv7-A speciﬁcation (2007) are not necessarily sound
for ARMv8-A (2013). This is especially true for ARM's
Microcontroller architecture which has a completely different
exception model from ARM's mainstream architecture.
The trustworthiness of a processor speciﬁcation is whether
the speciﬁcation can be trusted to reﬂect the behaviour of all
processors implementing the speciﬁcation. The ARMv7 HOL
speciﬁcation of Fox and Myreen [1] is noteworthy for the de-
gree of testing performed: systematically testing all user-mode,
integer instructions against three actual processors. This is a
critical step and must be repeated against as many expressions
of the architecture as possible (processors, implementations,
testsuites, etc.) and must be used to test the full scope of the
speciﬁcation.
The effort required to create a speciﬁcation increases with
the desired scope, applicability and trustworthiness of the
speciﬁcation. Worse, since ARM regularly releases extensions
and corrections to the architecture, the challenge of retaining
applicability to current processors is more of a continuous pro-
cess rather than a one-off sprint. Our solution to this problem
has been to change ARM's existing architecture speciﬁcation
process so that machine-readable, executable speciﬁcations
can be automatically generated from the same materials used
to generate conventional documentation.
This paper describes our work over the last 5 years on trans-
forming the ARM processor speciﬁcations from documents
intended for human consumption into trustworthy machine-
readable speciﬁcations.
Creating this speciﬁcation required understanding and cod-
161
ISBN: 978-0-9835678-6-8. Copyright owned jointly by the authors and FMCAD, Inc.
31

ifying the precise meaning of various notations used in the
documentation; inferring the lexical, syntax, type rules and
semantics from examples in the documentation; making the
speciﬁcation conform to these rules; ﬁlling gaps in the original
speciﬁcation; and creating a frontend and several backends to
allow the speciﬁcation to be executed.
Using ARM's speciﬁcations directly addresses the issues
of scope and applicability but the resulting formal part of
the speciﬁcation is just one part of the whole speciﬁcation
and, like any large speciﬁcation, may contain bugs wrt the
informal parts of the speciﬁcation or with the architects'
informal intent. To address the issue of trust, we have used
a diverse set of testing methodologies to compare against
as many different expressions of the speciﬁcation as possi-
ble: testsuites, simulators and processors. We have simulated
billions of instructions and used bounded model checking
to compare the RTL of ﬁve ARM processors currently in
development against the speciﬁcation [6]. Bugs found in the
process have been ﬁxed in the master copy of the speciﬁcation
from which ARM's architecture speciﬁcation documents are
generated. This process has the effect of distilling more of
the architectural intent into the formal part of ARM's ofﬁcial
speciﬁcation.
The structure of this paper is summarized in Figure 1 which
gives an overview of the speciﬁcations, tools, veriﬁcation IP,
and testing we created or used in the process of this project.
Section II gives a brief overview of the structure and content
of the different ARM Architectures. Sections III and IV
describe the steps we took to convert ARM's existing informal
documentation into machine-readable, executable, trustworthy
speciﬁcations of the ARM-v8A and ARM-v8-M architectures;
Section V discusses related work; and Section VI concludes.
This paper deals with the Instruction Set Architecture (ISA),
Exceptions, Memory Protection/Translation and Security. It
does not deal with multiprocessor features and, in particular,
the Memory Ordering Model [3], [7], [8]. And it does not deal
with debug or performance monitoring features.
II. ARM SPECIFICATIONS
ARM Architecture speciﬁcations have two main sections: Ap-
plication Level Architecture and System Level Architecture.
The Application Level Architecture (aka the Instruction
Set Architecture or ISA) consists of all instructions and all
user-mode registers (the integer and ﬂoating point register
ﬁles, condition ﬂags, stack pointer and program counter). ISA
speciﬁcations consist of instruction encodings, matching rules
to match encodings to opcodes and the semantics of instruction
execution.
The System Level Architecture deﬁnes Memory Translation
and Protection, Synchronous Exceptions (e.g., page faults
and system traps), Asynchronous Exceptions (e.g., interrupts),
Security (e.g., register banking and access protection of reg-
isters), and System Registers and System Operations (which
are used to control and read the status of all the system-
level features), In other words, the facilities needed to support
Operating Systems, Hypervisors and Secure Monitors.
The ARM architecture comprises three main processor
classes: "A-class" processors support Applications (character-
ized by having an operating system that uses address transla-
tion to provide virtual memory); "R-class" processors support
Real-Time systems that cannot handle the timing variability
associated with virtual memory and use memory protection
instead; and "M-class" microcontrollers are optimized for
programming interrupt-driven systems in the C language. The
A-class speciﬁcation consists of two parts: AArch32 supports
32-bit programs and is generally backward compatible with
ARM's traditional architecture; and AArch64 which supports
64-bit programs.
The A- and R-class architecture [9] share the same ISA and
exception model but have different memory protection/trans-
lation models. The M-class architecture [10] has a subset of
the A-class ISA but has signiﬁcant differences from A-class
at both the Application Level and System Level.
A. ISA Differences between A/R- and M-class
The M-class architecture only supports the Thumb R⃝(aka
"T32") variable-length instruction encodings whereas the A/R-
class architecture also supports the A32 and A64 encodings.
Much more signiﬁcantly though, the speciﬁcations identify
certain instruction encodings as UNPREDICTABLE for which
a processor is free to do anything that can be achieved at the
current or a lower level of privilege using instructions that
are not UNPREDICTABLE and that does not halt or hang the
processor or parts of the system.
In the M-class architecture, many of the instruction encod-
ings which access the stack pointer (R13) or the program
counter (R15) are UNPREDICTABLE but the same encodings
are well deﬁned in the A/R-class architecture. This is a
signiﬁcant difference — it would be unsound to use the
A-class speciﬁcation to reason about Thumb machine code
intended for an M-class processor.
More broadly, when performing formal veriﬁcation, it is
essential to ensure that the speciﬁcation version being used
matches the architecture version supported on the target pro-
cessor because later speciﬁcations are almost but not entirely
backward compatible. This is obvious but easily overlooked.
B. System Differences between A-, R- and M-class
The R/M-class architectures support memory protection based
on setting attributes and protection for a small number of
contiguous memory regions whereas the A-class architecture
supports both address translation and memory protection for
a large number of memory pages.
M-class processors automatically save the callee-save reg-
isters on the stack on taking an exception whereas A/R pro-
cessors require registers to be saved in software. This allows
M-class processors to respond more quickly to interrupts and
also allows exception handlers to be written in plain C with
no assembly language or special calling conventions. This
has a large impact on the architecture speciﬁcation since it
introduces many corner cases associated with the effect of
triggering memory faults while saving or restoring registers.
162
ISBN: 978-0-9835678-6-8. Copyright owned jointly by the authors and FMCAD, Inc.
32
CHAPTER 2. TRUSTWORTHY SPECIFICATIONS

Architecture
Explorer
§III-B
Instruction Encodings §II
Instruction ASL §II
System ASL §II
ASL
Test Monitor ASL §IV-A1
System
Registers §III-D
Abstract Syntax Tree §III-G
IP-XACT §III-G
Verilog codegen
Callgraph §III-G
Interpreter
C++ codegen §IV-A2
Directed Tests §IV-A
Random Tests §IV-B
Information Flow Analysis §IV-C
Test Coverage §IV-A4
Formal Spec §III-G
Trace Comparision §IV-B
Bounded Model Checker §IV-D
ARM CPU RTL
Fig. 1: Overview of speciﬁcations, tools, veriﬁcation IP and testing. This ﬂow was applied separately to the v8-A speciﬁcation
and to the v8-M speciﬁcation. Section numbers indicate which section primarily discusses each aspect.
M-class processors have an orthogonal set of 8 execu-
tion states composed of combinations of three properties:
privileged/unprivileged, secure/non-secure and handler/thread.
A/R-class processors have a more traditional set of nested
execution states EL0, EL1 (supervisor), EL2 (virtualization)
and EL3 (secure monitor) with increasing levels of privilege
at each level.
A consequence of these differences is that the M-class
system speciﬁcation is completely different from the A/R-class
system speciﬁcation.
III. EXECUTABLE SPECIFICATIONS
We
faced
ﬁve
major
challenges
in
turning
ARM's
documentation-based
speciﬁcation
into
an
executable
speciﬁcation:
(1)
Scale:
ARM
speciﬁcations
are
very
large; (2) Informality: ARM speciﬁcations are written in
"pseudocode"; (3) Gaps: key parts of the speciﬁcation only
existed in natural language speciﬁcation; (4) System Register
Speciﬁcations; and (5) Implementation Deﬁned Behaviour.
A. ARM Speciﬁcations Are Large
One of the main challenges in creating machine-readable
speciﬁcations of the ARM Architecture is the scale of the
problem. The A and M-class architectures together consist
of over 6,000 pages of documentation, 1,570 instruction en-
codings, over 50,000 lines of pseudocode, over 4,500 system
register ﬁelds grouped into 772 system register, and 112
system operations. To this speciﬁcation that ARM publishes,
we added an additional 8,190 lines of support pseudocode
which were required to make the execution executable. (A
more detailed breakdown of the size of the speciﬁcation is
given in table 2a and table 2b.)
B. Pseudocode
A secondary challenge in creating a machine readable spec-
iﬁcation was that the bulk of the speciﬁcation is written in
what the ARM documentation refers to as "pseudocode".
For example, the T32 CMP instruction is speciﬁed with the
following encoding diagram and pseudocode in the v8-A
architecture. (The same instruction is UNPREDICTABLE in
v8-M if "m == 13".)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7
6
5 4 3 2 1 0
1
1
1
0
1
0
1
1
1
0
1
1
Rn
(0)
imm3
1
1
1 1 imm2 type
Rm
CONDITIONAL
n = UInt(Rn); m = UInt(Rm);
(shift t, shift n) = DecodeImmShift(type, imm3:imm2);
if n == 15 || m == 15 then UNPREDICTABLE;
shifted = Shift(R[m], shift t, shift n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
PSTATE.<N,Z,C,V> = nzcv;
Fortunately for us, this "pseudocode" was fairly complete
and it appeared possible to implement a conventional parser,
typechecker and interpreter for pseudocode (a tool we call "Ar-
chitecture Explorer"). Through a process of experimentation,
discussion and negotiation with the architecture designers, we
were able to infer consistent indentation rules, precedence
rules, a type-system and semantics and to clean up the speciﬁ-
cations to use the resulting simpler, more consistent language
that is now internally referred to as ARM Speciﬁcation Lan-
guage (ASL).
At a high level, ASL is an indentation-sensitive, imperative,
strongly typed, ﬁrst-order language with dependent types (to
reason about length of bit vectors), type inference, exceptions,
enumerations, arrays, records, no pointers. Unusually for an
otherwise simple language, ASL allows overloading of array
syntax for function calls: the use of "R[m]" and "R[n]"
on lines 4 and 5 of the example above are both function
calls. This syntactic sugar provides an initial impression that
registers (and memory) are simple arrays, while allowing one
to dig deeper and understand register banking, virtual memory,
etc. We refer readers to Fox and Myreen [1] or to ARM's
speciﬁcation [9, Appendix G] for a more detailed description
of ASL.
The initial cleanup of syntax and type errors resulted in
changes to approximately 12% of the lines of code but,
163
ISBN: 978-0-9835678-6-8. Copyright owned jointly by the authors and FMCAD, Inc.
33

ARMv8-A
ARMv8-M
AArch32
AArch64
Shared
Support
Spec
Support
Instrs.
18318
5757
4998
Integer
23
352
246
Float Point
1179
953
76
Exceptions
1474
1611
235
781
Registers
310
446
398
2011
461
Memory
1584
1169
393
369
481
Debug
675
537
1103
Instr. Fetch
199
367
128
Test Monitor
-
-
-
1323
-
1893
Misc.
1647
1137
2984
1678
415
1434
Total
24315
10657
5489
3200
9898
4990
(a) Size of ASL speciﬁcation (lines of code)
v8-A
v8-M
Registers
586
186
Fields
3951
622
Constant
985
177
Reserved
940
208
Impl. Deﬁned
70
10
Passive
1888
165
Active
68
62
Operations
112
10
(b) Size of System Register speciﬁcation
Fig. 2: Size of ARM Speciﬁcations
since ARM speciﬁcations are extensively reviewed before
release, these were all fairly low-grade errors: they confused
automatic tools but few were likely to confuse a human reader.
The process of cleaning up the speciﬁcation also uncovered
a number of instances of "implement by comment" where
comments were used instead of pseudocode: these parts had to
be rewritten before the code could be executed. These simple
comments often turned out to be surprisingly complicated and
the process of writing code would identify corner cases or the
need to modify other parts of the speciﬁcation.
C. Gaps in the speciﬁcation
Some parts of the architecture were only deﬁned in English
and the information to implement them was typically scattered
throughout the documentation. An example is the speciﬁcation
of the "top-level" step of fetching an instruction, decoding
and executing it, and incrementing the program counter was
not written in ASL and the description was scattered across
the speciﬁcation document. The exact speciﬁcation of this
step took some time to develop as it includes details like
dealing with page faults that occur during instruction fetch, not
incrementing the PC after a branch instruction or exception,
conditional execution of instructions and its interaction with
UNDEFINED encodings, and testing for pending interrupts.
D. System Register Speciﬁcation
The major negative surprise of this project was how hard it
was to specify something as apparently simple as a register.
The A-class architecture speciﬁcation comprises 586 system
registers which are used to read the status of and to control
the behaviour of the processor (such as whether the MMU or
cache is turned on) and to perform operations such as ﬂushing
the cache or invalidating the TLB. The main properties of these
registers are captured in the architecture speciﬁcation by tables
specifying the opcode to access each register, its name, size
(32/64-bits) whether it is read-only and the reset value of the
register. For each register, there is a description consisting of a
register diagram which identiﬁes the name and extent of any
used bits in the register. And each such ﬁeld of contiguous
bits has a natural language speciﬁcation.
The challenge in creating a machine-readable speciﬁcation
for system registers is that different ﬁelds within the register
can behave in several different ways. After some experimen-
tation we settled on identifying ﬁve major types of ﬁeld.
i) Constant ﬁelds have an architecture deﬁned value and cannot
be changed.
ii) Reserved ﬁelds are not used in the current version of
the architecture but could be assigned a meaning in future
versions of the architecture. These are like constant ﬁelds but,
to maintain forward compatibility, software should not assume
that the ﬁeld is constant and should avoid changing the value
of that ﬁeld.
iii) Implementation Deﬁned ﬁelds have an implementation
deﬁned value that programs may read to determine whether
the processor has some ISA or system level feature.
iv) Passive ﬁelds behave like a global variable and simply store
the value last written to the ﬁeld. The value written often
has a signiﬁcant effect such as enabling address translation
but this effect is completely captured by the ASL functions
implementing the affected behaviour.
v) Active ﬁelds do not behave like a global variable: reading
the ﬁeld may not see the last value written to the ﬁeld; writing
to the ﬁeld may be disabled by the value of some other register;
etc. These are used for everything from system timer registers
(which decrement every cycle) to allowing a hypervisor to
intercept interrupts targetted at the guest operating system.
Fields that are Constant, Reserved, Implementation Deﬁned
or Passive are easy to describe completely and are described in
a simple table-based format but 68 of the ﬁelds of system reg-
isters are Active ﬁelds whose behaviour can only be captured
by writing ASL getter and setter functions to implement the
natural language speciﬁcation. The process of implementing
registers with active ﬁelds proved to be quite error prone as
the behaviour of the ﬁelds was rather subtle.
It was also hard to ﬁnd the correct design point. We chose
to identify just 5 classes of ﬁeld but we could have identiﬁed
further common patterns within the Active class. For example,
164
ISBN: 978-0-9835678-6-8. Copyright owned jointly by the authors and FMCAD, Inc.
34
CHAPTER 2. TRUSTWORTHY SPECIFICATIONS

there are some pairs of registers that have complementary ef-
fects such as enabling and disabling exceptions. If this pattern
is a one-off, it is probably best described as an Active register
but if the pattern occurs in several pairs of registers, then the
argument for recognizing it as a new class of ﬁeld becomes
stronger. As the number of tools using the system register
speciﬁcation grows, we expect that we will identify a number
of patterns that are useful to recognise explicitly because that
enables tools to make more use of the speciﬁcation without
having to embed the ASL parser/interpreter.
One signiﬁcant aspect of system registers not yet captured
in the executable speciﬁcation is what Lustig et al. [8] call a
memory transistency model which captures places where the
speciﬁcation allows reordering of writes to system registers
with respect to other instructions and requires insertion of
instruction barrier instructions (ISB) to restrict.
E. Implementation Deﬁned Behaviour
The speciﬁcation allows for some implementation deﬁned
behaviour such as whether a particular feature is implemented
or the number of memory protection regions supported. This
behaviour is often speciﬁed by "stub functions" returning
booleans or an enumerated value and with a natural language
deﬁnition. We had to implement these stub functions before
we could execute the speciﬁcation. In most cases, these feature
test functions could be implemented by testing a corresponding
implementation deﬁned ﬁeld.
F. Executable Speciﬁcation
After creating all the tooling, bugﬁxes, etc. described above,
there were some further steps required to make the speciﬁ-
cation executable so that it could be tested. We had to add
additional infrastructure such as generating decode trees for a
set of encodings to identify which instruction to execute; ELF
readers to load test programs into memory; a physical memory
implementation which allocates pages of memory on demand.
and breakpoint and trace facilities to use when debugging.
We also introduced a continuous integration ﬂow where ev-
ery speciﬁcation change runs regression tests. This was critical
for conﬁning new code to the ASL subset of pseudocode.
G. Machine Readable Speciﬁcations
Our primary goal in doing the above was not to make the
speciﬁcation executable but, rather, to improve its quality so
that the speciﬁcation is useful to many potential users. To
support these uses, we generate a variety of machine-readable
outputs.
i) IP-XACT is a standard XML-based format for describing
registers in a chip [11]. It is used by debuggers needing to
view or change the value of a register.
ii) Callgraph summaries are convenient summaries of the
function calls and variable accesses performed by each in-
struction and function in the speciﬁcation. One use of these
summaries is in generating a summary of the list of exceptions
that an instruction can raise — for inclusion in documentation.
iii) Abstract Syntax Trees are a complete dump of Architecture
Explorer's internal representation after typechecking. We have
provided these to the University of Cambridge REMS group
who are in the process of transforming them into a form
suitable for formal veriﬁcation of machine-code programs.
IV. TRUSTWORTHY SPECIFICATIONS
ARM spends considerable effort on reviewing speciﬁcations. It
also beneﬁts from feedback from users of the speciﬁcations:
processor designers, veriﬁcation engineers, implementers of
simulators, compiler writers, etc. Nevertheless, the sheer size
of the speciﬁcation made it unlikely that the speciﬁcations are
bug-free. This was especially true of the relatively fresh v8-M
speciﬁcation since it had not yet had the beneﬁt of feedback
from users of the speciﬁcation.
This Section describes the steps we have taken to test the v8-
A and v8-M speciﬁcations using testsuites, random instruction
sequences, information ﬂow analysis and using bounded model
checking to compare against the Verilog implementation of
processors. One of the recurring themes of this project was
that this testing process improves the speciﬁcation and our
trust in the speciﬁcation — but it also improves the tools,
veriﬁcation IP, etc. that is being used to test the speciﬁcation
which creates a virtuous cycle of improving any other uses of
those tools and artifacts.
A. Using ARM Processor testsuites
ARM performs extensive testing of its processors and simu-
lators (it is estimated that more than 80% of the engineering
effort of designing a new processor is spent on testing the
processor). One part of this testing process is use of ARM's
Architecture Validition Suite (AVS) which consists of pro-
grams that test the architectural conformance of individual
instructions, memory protection, exception handling and all
other aspects of the architecture. Excluding multiprocessor and
debug tests, the AArch64 AVS consists of over 11,000 test pro-
grams with a combined runtime of over 2.5 billion instructions;
the M-class AVS consists of over 3,500 test programs with a
combined runtime of over 250 million instructions. Almost all
of these tests were considered to be free of assumptions about
instruction timing or implementation deﬁned behaviour. (ARM
has a large number of other tests which were less appropriate
to run because they are aimed at testing micro-architectural
performance optimizations in particular processors.)
Using ARM's ofﬁcial Architecture Validition Suite has some
signiﬁcant advantages: the suite is very thorough, checks many
corner cases, and has good control and data coverage of
the architecture; the suite is self-checking: each test prints
"PASSED" or "FAILED" when it runs; and, since the purpose
of the tests is to test processors, it was possible to compare the
behaviour against actual processors for additional conﬁdence.
The primary disadvantage of using the AVS was that the
tests are "bare metal" tests that exercise the System Level
Architecture and require a large test harness to run.
As we started using Architecture Explorer to develop new
architecture extensions (such as the new security features of
v8-M), we encountered a chicken-and-egg problem: the AVS
165
ISBN: 978-0-9835678-6-8. Copyright owned jointly by the authors and FMCAD, Inc.
35

is extended with new tests only once the architecture speciﬁ-
cation is available but we were still writing the speciﬁcation.
Worse, v8-M is not entirely backward compatible with the
previous architecture version so we could not even run the old
tests. This led us to use a hybrid approach: we temporarily
created a modiﬁed speciﬁcation supporting the old memory
protection design so that we could use the old tests; and we
created a temporary test suite to test the new security features
of v8-M (see Section IV-C) before the ofﬁcial test suite was
developed. Once updated AVS tests became available, we
switched to using the ofﬁcial test suite.
1) Programmable Monitor and Stimulus Generator: Part
of the development of every ARM processor is creating a test
harness which allows the AVS to be run. This test harness
consists of a programmable monitor and stimulus generator
that allows programs to monitor their own behaviour at a very
low-level. The test monitor design dates back to the earliest
days of ARM and each successive architecture extension
typically adds new test features.
The monitor consists of 177 memory mapped registers of
which 45 are Active. The main features of the test monitor are
(i) Console FIFO for writing ASCII text to log ﬁle.
(ii) Memory attribute monitors which record the attributes of
memory accesses in a given range of addresses. This allows
test programs to verify that the MMU/MPU is correctly asso-
ciating attributes such as cacheability of an access with each
address. These checkers are repeated for each bus interface.
(iii) Memory abort generators to trigger a bus fault response
if the processor accesses a speciﬁed range of addresses.
(iv) Interrupt generators to test triggering, prioritization and
nesting of interrupts.
(v) Reset generators to schedule resets.
2) Optimizing the simulator: During this testing process,
we slowly built our capability from being able to execute
one instruction to being able to execute most usermode in-
structions, to being able to execute entire tests and then entire
testsuites. As we did so, we were increasingly limited by the
performance of our interpreter which initially ran at a few
hundred instructions per second. Over time, we have optimized
this in a variety of ways increasing performance to 5kHz (v8-
A) and 50kHz (v8-M). The main optimizations applied are: (i)
Memoizing a few critical functions associated with the current
conﬁguration or execution state (this has not been yet been
applied to v8-A); (ii) Implementing a few critical arithmetic
functions as builtin primitives even if they can be deﬁned
in ASL; (iii) Creating a C++ code generator and runtime
(including ELF reader, etc.).
3) Testing the speciﬁcation: One of the issues found while
testing the speciﬁcation initially manifested as a failing AVS
test. On closer inspection, we found a mismatch between
the English text and the pseudocode and that the test had
originally followed the pseudocode and ARM's reference
simulator followed the English text. This mismatch had been
"ﬁxed" by changing the test to match the simulator. Consulting
the architects, we learned that the pseudocode was correct and
the English text was wrong and so the English text, the test
and the simulator were ﬁxed to match the architects' intent.
The pass rate of our speciﬁcations on the AVS is summa-
rized in Table I. We have achieved a 100% pass rate for the
v8-A and v8-M ISA tests and for the v8-M System tests. For
the v8-A System tests, there remain some failing tests in areas
related to interprocessing (switching between 32-bit and 64-
bit modes) and prioritization of multiple exceptions within the
same instruction. These results omit debug and multiprocessor
tests which are just under 50% of the total number of tests.
ARMv8-A
ARMv8-M
ISA
Integer
100%
100%
Floating Point
100%
100%
SIMD
100%
100%
System
Exceptions
100%
100%
Memory
99%
100%
Interprocessing
98%
-
TABLE I: Pass rate for AVS testsuite
4) Testing the testsuite: Testing the speciﬁcation with a
testsuite has the side-effect of testing the testsuite. We found
two classes of problems in the process of diagnosing test
failures. The ﬁrst is that a test may depend on some property
not guaranteed by the architecture but which had been true in
every tested processor. For example, a test might check that a
reserved ﬁeld of a register is always zero and will then fail on
later versions of the architecture. Secondly, many of the M-
class AVS tests depended on UNPREDICTABLE behaviour
but this had not been observed before because, in practice,
UNPREDICTABLE behaviour can depend on the particular
pipeline state when an instruction runs.
To improve testing of the AVS, we extended the interpreter
to collect line coverage information as it executes. A rare
example of a coverage hole we found was in a ﬂoating point
test which tested with inputs that produced the result +0.0 but
did not test with inputs that produced the result −0.0 — with
the result that one of the branches associated with rounding
was not being exercised. The AVS development team now
routinely measure the architectural coverage of testsuites.
B. Random Instruction Sequence Testing
Random Instruction Sequence (RIS) testing is a complemen-
tary technique to the directed testing of using hand-written
tests based on generating random sequences of instructions.
ARM's RIS tool [12] uses templates that specify the desired
distribution of instructions, the likelihood of reuse of a given
register, etc. Automatically generating random tests is different
from hand-writing tests because it requires an accurate simula-
tor to deﬁne the correct behaviour of a test. Also, because RIS
generates random sequences of instructions, it is necessary to
run the same test on multiple systems (processors, simulators
or the speciﬁcation) and compare execution traces. So at least
two models are needed to develop RIS tests.
166
ISBN: 978-0-9835678-6-8. Copyright owned jointly by the authors and FMCAD, Inc.
36
CHAPTER 2. TRUSTWORTHY SPECIFICATIONS

We were able to use the executable speciﬁcation as part
of the process for testing new RIS tests by extending the
simulator to generate a trace and extending the existing trace
comparision script to accept those traces. This process was
especially useful for the v8-M speciﬁcation because the v8-M
support in ARM's reference simulator was new and had not
been fully debugged. Using RIS to test the simulator against
the executable speciﬁcation was an effective way of testing
the RIS tests, the simulator and the speciﬁcation.
This process was able to uncover subtle errors in the
speciﬁcation. For example, v8-M's new security features splits
some of the system registers into two banked registers -a
non-secure register and a secure register- and the appropriate
register is automatically accessed depending on the current
security mode. But instructions that switch between secure
and non-secure registers start in one mode and end in a
different mode and the normally convenient automatic banking
mechanism obscures exactly which of the two registers is
being accessed. RIS testing found an error in the speciﬁcation
of the Test Target (TT) instruction which queries the security
state and access permissions of a memory location.
C. Information Flow Analysis for v8-M
The most signiﬁcant new feature of the v8-M microcontroller
speciﬁcation is a set of security extensions to enable secure
Internet of Things applications.
To improve conﬁdence in both the extensions and in the way
they were expressed in the ASL speciﬁcation, we modiﬁed the
interpreter to generate dynamic dataﬂow graphs on which we
could perform information ﬂow analyses. Most of the analyses
performed can be characterized as a non-interference property:
ensuring that non-secure modes cannot see secure data and that
non-secure data can only inﬂuence secure code in safe ways.
An example scenario tested in this process involved in-
formation leaks via interrupts. Interrupts automatically save
integer registers on the stack of the interrupted code and zero
the integer registers but, in order to keep interrupt latency
low, ﬂoating point registers are lazily saved on the stack only
when/if the interrupt handler uses a ﬂoating point instruction.
We wanted to ensure that lazy FP state preservation did not
introduce security holes. We wrote tests that iterated over all
combinations of initial mode, ﬁnal mode, whether FP registers
had been modiﬁed and scanned the dynamic dataﬂow graph
for information leaks.
This form of testing caught two classes of bugs. First, it
caught bugs in how the architecture speciﬁcation implemented
the architectural intent — resulting in ﬁxes to how the speci-
ﬁcation was written. Second, and more importantly, it caught
bugs in the architectural intent by identifying potential security
attacks that had not been considered before.
D. Bounded Model Checking of Processors
We have been using both the v8-A and the v8-M architecture
speciﬁcations to perform bounded model checking of pipelines
for processors currently under development at ARM [6]. This
has primarily focused on verifying the ISA-implementation
parts of the processor, not the memory system, security
mechanisms or exception support. This process has been very
effective at detecting bugs in various stages of processor
development. But, besides verifying processors, it has another
important side-effect of performing a very thorough check
that the architecture speciﬁcation and our tooling agrees with
how the processor implementors interpret the speciﬁcation.
We found no errors in the published part of the speciﬁcation
in this process but we did ﬁnd a rather subtle bug in our
understanding of conditional UNDEFINED encodings and
UNPREDICTABLE encodings.
The M-class speciﬁcation requires that conditional execu-
tion of an UNDEFINED instruction behaves as a no-op if the
condition does not hold and we had assumed that the same was
true for UNPREDICTABLE instructions. During veriﬁcation
of a processor, the model checker detected an apparent bug
that involved a conditional UNPREDICTABLE encoding but,
through discussion between the processor designers and the
architects, we learned that there had been a recent clariﬁ-
cation of the architecture which said that conditional UN-
PREDICTABLE encodings are UNPREDICTABLE even if the
condition does not hold.
This error in our interpretation of the speciﬁcation had
not been detected by testing because it is very, very hard to
construct useful tests of the UNPREDICTABLE instructions
because they are almost entirely unconstrained and can branch,
change registers, trigger exceptions, etc.
E. Summary
Large speciﬁcations are as likely to contain errors as large
programs so we have used many different approaches to test
the speciﬁcations. In the process, we realized that although
ARM publishes an ofﬁcial speciﬁcation, the full requirements
are really distributed around many different places in the
company: the AVS suite, the reference simulator ARM uses
for processor veriﬁcation, and the processor implementations.
The act of testing all these different instantiations of the
speciﬁcation against each other has the effect of centralizing
this speciﬁcation in a single location.
V. RELATED WORK
The most closely related work is that of Goel et al. [13]
who have created an executable speciﬁcation of many key
parts of the x86-64 ISA and system architecture including
paging, segmentation and both user/supervisor levels. Their
model has been veriﬁed against real processors using the Pin
binary instrumentation tool and they have added a syscall
emulation layer to let them run real programs including
(amusingly) a SAT solver. This is a monumental piece of
work that sets the standard against which other architecture
speciﬁcations should be judged. Despite the similarities, our
different project priorities have led to many differences: (1)
They have a speciﬁcation of user and supervisor levels, we
also have a speciﬁcation of hypervisor and secure monitor
levels. (2) They have used their speciﬁcation to formally
verify software using theorem proving, we have used our
167
ISBN: 978-0-9835678-6-8. Copyright owned jointly by the authors and FMCAD, Inc.
37

speciﬁcation to formally verify hardware using bounded model
checking. (3) They have implemented syscall emulation to let
them use user-level programs as tests, we have implemented a
test monitor and debugged the EL2/EL3 levels to allow us to
run ARM's Architecture Conformance Suite which explores
the dark corners of the architecture by running bare-metal
programs. (4) They have focussed on modelling the x86-64
64-bit ISA, we have modelled the A64, A32 and T32 ISAs.
(5) They have consulted processor designers to understand
Intel's architecture speciﬁcation document, we have had all
our bugﬁxes and clariﬁcations reviewed by ARM's architects
and incorporated into ARM's ofﬁcial architecture speciﬁcation
document.
The most closely related ARM speciﬁcations are the
Fox/Myreen ARM v7-A ISA speciﬁcation in HOL [1] and
Flur et al.'s ISA and concurrency speciﬁcation in Sail [3] both
of which were tested against actual processors using random
and directed tests (8400 tests in Flur et al., 281,307 tests in
Fox/Myreen). In addition to user-mode instructions, our speci-
ﬁcation covers both the ARMv8-M architecture and the larger
ARMv8-A architecture, includes ﬂoating point, Advanced-
SIMD and the System Level Architecture. We have tested the
entire speciﬁcation in multiple ways and with a larger range
of values and simulated more than 2.5 billion instructions in
the process. And we have used a model checker to compare
the ISA speciﬁcation against actual implementations for all
instructions, all execution modes, all integer inputs and a
subset of ﬂoating point inputs [6].
Shi [14] extracted the ISA pseudocode from ARM's v6
Architecture Reference Manual, automatically translated the
code to Coq and used that to verify that the ARM model in
the SimSoC simulator written in C faithfully implemented the
Coq speciﬁcation. This is an impressive piece of work, and it
would be interesting to repeat their work using our new, more
trustworthy speciﬁcation or to extend their proof to cover the
system level architecture.
The other major ARM ISA speciﬁcation that we are aware
of is embedded in the CompCert compiler and is used in
the proof that the compiler faithfully translates the input C
program to ARM assembly code. This speciﬁcation is limited
to a subset of the user-mode ARMv6 speciﬁcation and there
is no published statement of how it was validated.
Hunt created a speciﬁcation of the FM8501 processor [5]
and used it to formally verify the processor. The process of
formal veriﬁcation greatly increases the trust we can place
in the corresponding parts of the speciﬁcation because it
ensures that all the corner cases in both the processor and
the speciﬁcation have been explored.
More broadly, anyone wrestling with a large speciﬁcation is
obligated to ﬁnd ways to verify that the formal speciﬁcation
captures the (informal) requirements.
VI. CONCLUSIONS
Historically, ARM's speciﬁcation efforts have focused on a
single set of products: the ARM Architecture Reference Man-
uals [9], [10]. However, there are many more potential uses of
the speciﬁcation if the speciﬁcation is delivered in a ﬂexible,
machine-readable format - for example, formal veriﬁcation
of hardware and software, tools that manipulate instruction
encodings, debug tools, creating hardware veriﬁcation tests.
Traditionally, all these other users manually transcribe parts of
the speciﬁcation into some other notation: HOL, C, Verilog,
spreadsheets, etc. This process is laborious and error-prone
but, worse, it is fragmented: bugﬁxes or clariﬁcation found by
one group are not necessarily propagated to other groups or
to the master speciﬁcation. Our primary goal in this project
was to enable formal veriﬁcation of ARM processors against
the speciﬁcation. But, by supporting as many of these uses
as possible, we created a virtuous cycle where bugﬁxes or
improvements were incorporated into the central speciﬁcation
so that all users beneﬁt from bugﬁxes as well as to amortize
the development effort across many uses.
This paper describes the steps required to create trustworthy
speciﬁcations of the full v8-M and v8-A architectures includ-
ing the instruction set architecture, memory protection and
translation, exceptions and system registers. While checking
that a formal speciﬁcation captures the architects' informal
intent is an unending process, we believe that our speciﬁcation
is the most trustworthy and complete system speciﬁcation of
any mainstream processor architecture.
We are currently working with Cambridge University on
a public release of our speciﬁcation suited to veriﬁcation of
machine code programs.
REFERENCES
[1] A. C. J. Fox and M. O. Myreen, "A trustworthy monadic formalization
of the ARMv7 instruction set architecture," in Proc. Interactive Theorem
Proving ITP 2010, ser. LNCS, vol. 6172.
Springer, 2010, pp. 243-258.
[2] X. Leroy, "Formal veriﬁcation of a realistic compiler," Commun. ACM,
vol. 52, no. 7, pp. 107-115, 2009.
[3] S. Flur et al., "Modelling the ARMv8 architecture, operationally:
concurrency and ISA," in Proc. Principles of Programming Languages,
POPL 2016, 2016, pp. 608-621.
[4] M. Dam, R. Guanciale, and H. Nemati, "Machine code veriﬁcation of
a tiny ARM hypervisor," in Proc. Workshop on Trustworthy Embedded
Devices, ser. TrustED '13.
ACM, 2013, pp. 3-12.
[5] W. A. Hunt, "FM8501: A veriﬁed microprocessor," ser. LNCS, vol. 795.
Springer, 1994.
[6] A. Reid et al., "End-to-end veriﬁcation of ARM R
⃝processors with ISA-
Formal," in Proc. Computer Aided Veriﬁcation (CAV), ser. LNCS, vol.
9780.
Springer-Verlag, 2016, pp. 42-58.
[7] J. Alglave, L. Maranget, and M. Tautschnig, "Herding cats: Modelling,
simulation, testing, and data mining for weak memory," ACM Trans.
Program. Lang. Syst., vol. 36, no. 2, pp. 7:1-7:74, 2014.
[8] D. Lustig et al., "Coatcheck: Verifying memory ordering at the
hardware-OS interface," in Architectural Support for Programming Lan-
guages and Operating Systems, ASPLOS.
ACM, 2016, pp. 233-247.
[9] ARM Ltd, ARM Architecture Reference Manual (ARMv8, for ARMv8-A
architecture proﬁle).
ARM Ltd, 2013.
[10] ——, ARM v7-M Architecture Reference Manual.
ARM Ltd, 2006.
[11] IEEE, "IP-XACT, standard structure for packaging, integrating, and
reusing IP within tool ﬂows," IEEE Standard 1685-2014, 2014.
[12] B.
Greene
and
M.
McDaniel,
The
Cortex-A15
Veriﬁcation
Story.
http://www.testandveriﬁcation.com/downloads/DVClub-
Jan-2012/Cortex-A15-Veriﬁcation-Story-DVclub-ﬁnal.pdf, 2011.
[13] S. Goel et al., "Simulation and formal veriﬁcation of x86 machine-code
programs that make system calls," in Formal Methods in Computer-
Aided Design, FMCAD, 2014, pp. 91-98.
[14] X. Shi, "Certiﬁcation of an instruction set simulator," Ph.D. dissertation,
University of Grenoble, July 2013.
168
ISBN: 978-0-9835678-6-8. Copyright owned jointly by the authors and FMCAD, Inc.
38
CHAPTER 2. TRUSTWORTHY SPECIFICATIONS

Chapter 3
End-to-End Veriﬁcation of ARM
Processors with ISA-Formal (Paper II)
Alastair Reid, Rick Chen, Anastasios Deligiannis, David Gilday, David Hoyes, Will Keen,
Ashan Pathirane, Erin Shepherd, Peter Vrabel, and Ali Zaidi. End-to-end veriﬁcation of ARM
processors with ISA-Formal. In S. Chaudhuri and A. Farzan, editors, Proceedings of the 2016
International Conference on Computer Aided Veriﬁcation (CAV'16), volume 9780 of LNCS,
pages 42-58. Springer Verlag, July 2016.
c⃝2016 Springer Verlag. Reprinted by permission. License number: 4296060618361.
doi: https://dx.doi.org/10.1007/978-3-319-41540-6_3.
39

40
CHAPTER 3. END-TO-END VERIFICATION OF ARM PROCESSORS

End-to-End Veriﬁcation of ARM
R
⃝Processors
with ISA-Formal
Alastair Reid(B), Rick Chen, Anastasios Deligiannis, David Gilday,
David Hoyes, Will Keen, Ashan Pathirane, Owen Shepherd, Peter Vrabel,
and Ali Zaidi
ARM Limited, 110 Fulbourn Road, Cambridge, UK
{alastair.reid,rick.chen,anastasios.deligiannis,david.gilday,david.hoyes,
will.keen,ashan.pathirane,owen.shepherd,peter.vrabel,ali.zaidi}@arm.com
Abstract. Despite 20+ years of research on processor veriﬁcation, it
remains hard to use formal veriﬁcation techniques in commercial proces-
sor development. There are two signiﬁcant factors: scaling issues and
return on investment. The scaling issues include the size of modern
processor speciﬁcations, the size/complexity of processor designs, the
size of design/veriﬁcation teams and the (non)availability of enough for-
mal veriﬁcation experts. The return on investment issues include the
need to start catching bugs early in development, the need to continue
catching bugs throughout development, and the need to be able to reuse
veriﬁcation IP, tools and techniques across a wide range of design styles.
This paper describes how ARM has overcome these issues in
our Instruction Set Architecture Formal Veriﬁcation framework "ISA-
Formal." This is an end-to-end framework to detect bugs in the data-
path, pipeline control and forwarding/stall logic of processors. A key
part of making the approach scale is use of a mechanical translation of
ARM's Architecture Reference Manuals to Verilog allowing the use of
commercial model-checkers. ISA-Formal has proven especially eﬀective
at ﬁnding micro-architecture speciﬁc bugs involving complex sequences
of instructions.
An essential feature of our work is that it is able to scale all the
way from simple 3-stage microcontrollers, through superscalar in-order
processors up to out-of-order processors. We have applied this method
to 8 diﬀerent ARM processors spanning all stages of development up to
release. In all processors, this has found bugs that would have been hard
for conventional simulation-based veriﬁcation to ﬁnd and ISA-Formal is
now a key part of ARM's formal veriﬁcation strategy.
To the best of our knowledge, this is the most broadly applicable
formal veriﬁcation technique for verifying processor pipeline control in
mainstream commercial use.
1
Introduction
Modern microprocessor designs apply many optimizations to improve perfor-
mance: pipelining, forwarding, issuing multiple instructions per cycle, multiple
c
⃝Springer International Publishing Switzerland 2016
S. Chaudhuri and A. Farzan (Eds.): CAV 2016, Part II, LNCS 9780, pp. 42-58, 2016.
DOI: 10.1007/978-3-319-41540-6 3
41

End-to-End Veriﬁcation of ARM
R
⃝Processors with ISA-Formal
43
independent pipelines, out-of-order instruction completion, out-of-order instruc-
tion issue, etc. All of these optimizations are supposed to be invisible to the
programmer in a uniprocessor context: the overall eﬀect should be the same as
executing instructions one at a time in program order. But each of these opti-
mizations introduces corner cases that potentially change the behaviour and the
diﬀerent optimizations interact with each other in complex ways.
For example, in a pre-release version of one of ARM's dual-issue processors,
there was a defect in the inter-pipeline forwarding control logic that resulted in
an instruction reading its input value from the wrong place if the instruction was
preceded by a conditional instruction whose condition did not hold (and whose
results should therefore not be used as inputs). The shortest instruction sequence
which could demonstrate this defect was 5 instructions long. The particular set
of instructions that could trigger the defect was fairly narrow because it was
necessary that the instructions used particular parts of the pipeline, and the
instruction sequence had to be aligned such that the ﬁrst of these instructions
executed in pipeline 0.
For traditional simulation-based veriﬁcation to detect this defect you would
need a detailed understanding of the micro-architecture of that particular proces-
sor, of the corner cases caused by the forwarding paths and of the kinds of errors
one is likely to make in implementing forwarding control logic. Creating such
tests is not only hard and unreliable, but it is also expensive because the tests
would be speciﬁc to the particular micro-architectural choices in a processor and
diﬀerent tests must be created for each processor.
This paper describes the "ISA-Formal" veriﬁcation technique that we have
developed at ARM for verifying that processors correctly implement the Instruc-
tion Set Architecture (ISA) part of the architecture speciﬁcation. Our method
uses bounded model checking to explore diﬀerent sequences of instructions and
was able to detect the above defect prior to release of the RTL to manufacturers.
The eﬀectiveness of ISA-Formal is important to its adoption within ARM
but it is not the most important requirement we had to satisfy in order to make
formal veriﬁcation a useful part of ARM's processor development ﬂow. Before
ISA-Formal could be deployed widely within ARM, we had make it work within
the constraints of commercial processor development:
(1) Processor development takes a long time (2 years or more) and it is impor-
tant to be able to be able to detect bugs at all stages of processor development.
We have applied ISA-Formal all the way from incomplete designs that still con-
tain bugs through to complete, heavily tested designs.
(2) Verifying a processor takes longer than design: the long tail of processor
development is developing new tests for the processor and ﬁxing any bugs. It
is important that useful results can be obtained even in the early stages of
veriﬁcation — before the complete test infrastructure has been developed. ISA-
Formal is able to ﬁnd bugs involving instructions for which we do not have a
speciﬁcation; all we need is a speciﬁcation of any instruction whose result could
be aﬀected by the bug.
42
CHAPTER 3. END-TO-END VERIFICATION OF ARM PROCESSORS

44
A. Reid et al.
(3) Veriﬁcation teams work in parallel with design teams so it is important
that veriﬁcation teams are able to continue searching for new bugs even when
there are multiple outstanding bugs waiting to be ﬁxed. Some bugs can take
months to be ﬁxed if they are not critical to immediate project milestones. ISA-
Formal is able to work round known bugs in the processor.
(4) Any veriﬁcation technique requires signiﬁcant investment so reusability
not only of the technique but also of the infrastructure is critical. We are able
to reuse the tools across ARM v8-A/R (Application/Real-time) class and across
v8-M (Microcontroller) class processors. The only part that needs to be cus-
tomized for each processor is the Verilog abstraction function that extracts the
eﬀective architectural state from the micro-architectural state of a processor.
This portability has been a great beneﬁt while developing the technique because
it allowed several processor teams to pool resources: one team worked on how to
verify ﬂoating point instructions while another worked on branches and another
worked on load-store instructions.
(5) Modern processor architectures and modern processors are large: the
ARM v8-A ISA speciﬁcation is over 2500 pages long, the v7-M ISA speciﬁcation
is over 600 pages long (almost half the length of the entire speciﬁcation). It
is important that veriﬁcation techniques scale both in terms of human eﬀort
and computing resources. We have written a tool to automatically translate
the source of the ARM Architecture Speciﬁcations to Verilog; and we split the
veriﬁcation task into thousands of small properties allowing eﬀective use of large
compute clusters.
We demonstrated these properties in three small-scale trials on diﬀerent
processors and have since reﬁned and applied the technique on ﬁve further
ARM processors: checking almost the complete instruction set architecture of
these processors ranging from simple 3-stage microcontrollers up to sophisti-
cated 64-bit out-of-order processors. ISA-Formal is now a key part of ARM's
formal veriﬁcation strategy.
We characterise our approach as "end-to-end veriﬁcation" because it focusses
on directly verifying the path from instruction decode through to instruction
retire against the architectural speciﬁcation in contrast to hierarchical or block-
level veriﬁcation which focusses on verifying individual blocks against micro-
architectural speciﬁcations and then verifying that the composition of those
blocks meets the overall speciﬁcation.
ISA-Formal is strongly based on techniques developed in the academic com-
munity; our contribution is a description of the techniques needed to make it scale
and of the challenges and solutions in creating a portable approach which can be
applied in a commercial setting to a wide range of processor micro-architectures.
The remainder of this paper is structured as follows: Sect. 2 discusses related
work; Sect. 3 illustrates the basic idea, demonstrating how ISA-Formal can be
applied manually, to a single instruction and discusses the kinds of bugs it was
able to discover in real processors; Sect. 4 describes how we scaled this idea up to
handle full ISA speciﬁcations; Sect. 5 describes adaptations to handle a variety of
43

End-to-End Veriﬁcation of ARM
R
⃝Processors with ISA-Formal
45
diﬀerent micro-architectural features; Sect. 6 reports on the results of applying
this method to multiple processors; Sect. 7 concludes.
2
Related Work
Our work builds heavily on the pioneering work from the '90's such as Burch-
Dill's automatic veriﬁcation based on ﬂushing reﬁnements [5] and Srinivasan's
veriﬁcation based on completion reﬁnements [19]. These and many other works
used diﬀerent notions of correctness of which Aagard et al. [1,2] give a useful
taxonomy and establish conditions under which diﬀerent notions of correctness
are equivalent.
Our approach focusses on verifying RTL (Verilog) in contrast to work which
veriﬁes a high-level model of the microarchitecture design against a speciﬁca-
tion. For example, Lahiri et al. [14] veriﬁed the microarchitecture of the M*-core
processor core (an early RISC-style architecture) and [13] veriﬁed the microar-
chitecture for an out-of-order processor through a series of successive reﬁnements
but neither veriﬁed against the RTL of an actual processor. In our experience,
most errors are introduced while translating the microarchitecture design into
RTL and during subsequent optimisation so verifying before RTL misses a lot
of bugs. The challenge of verifying actual RTL is that it makes it hard to use
abstraction techniques such as using uninterpreted functions because the actual
RTL of an eﬃcient processor tends not to have convenient blocks which match
directly with parts of the original speciﬁcation.
Many approaches to verifying pipeline control logic have used theorem prov-
ing techniques to tackle the diﬃcult problems of handling pipeline forwarding
and hazards in in-order processors [12,21] and, later, for out-of-order proces-
sors [7-9,16]. Theorem proving techniques are powerful and tend to suﬀer less
machine-scaling issues than more automated techniques but their reliance on ver-
iﬁcation experts leads to severe human-scaling issues: it is hard to hire enough
experts. We prefer to ride Moore's law and use more CPU-intensive but more
automatable approaches.
There has been considerable commercial interest recently in formal veriﬁ-
cation of ﬂoating point units such as Kaivola et al. [10], KiranKumar [11] and
Slobodova et. al [18]. This is impressive and important work but essentially
orthogonal to our own: while it tackles the scaling issues that occur when ver-
ifying commercial processors, it focusses on individual blocks processing a sin-
gle instruction with relatively simple input-output signals while our approach
focusses on the entire pipeline and especially the control logic to handle interac-
tions between instructions. We describe how we deal with veriﬁcation of pipelines
containing ﬂoating point units in Sect. 5.1.
3
Illustration: Hand-Written Properties
The basic approach to veriﬁcation that we use in ISA-Formal is based on the
above prior work. We start with the processor in a simple, well-deﬁned state
44
CHAPTER 3. END-TO-END VERIFICATION OF ARM PROCESSORS

46
A. Reid et al.
uArch0 with no instructions in the pipeline. We then execute for a number of
cycles where each cycle may issue an instruction. This serves to put the processor
into a more complex state where hazards, forwarding, etc. can occur. And ﬁnally,
we execute an instruction In and test whether the instruction executes correctly.
This is done by applying an abstraction function abs which extracts the archi-
tectural state of the processor immediately before In executes and immediately
after In executes. We do not ﬂush the pipe before or after In.
uArch0
uArch1
uArchn−1
uArchn
Archn−1
Archn
I1
In
abs
abs
In
A key part of making this scalable is that, instead of allowing the formal
veriﬁcation tool to choose any instruction for In, we enumerate all the instruc-
tion classes supported by the architecture and perform a separate check for
each instruction class. Proving these simpler results is helpful early in processor
development by making it easy to focus on checking the currently implemented
instructions. Later in development, the pattern of failing instructions is a useful
guide in localizing the fault: if all branch instructions are failing, there is no
need to worry about bugs in the ALU. And as the size of the veriﬁcation task
scales up, splitting the veriﬁcation task into many small properties lets us make
more eﬀective use of our veriﬁcation cluster which is optimized for running many
independent processes across hundreds of machines.
To make this more concrete, consider the task of checking an addition instruc-
tion in the classic 5-stage pipeline illustrated in Fig. 1. This consists of 5 pipeline
stages responsible for instruction fetch (IF), decode (ID), execute (EX), memory
access (MEM) and writeback of results (WB). Values are read from the register
ﬁle at the ID/EX boundary and results are written to the register ﬁle at the
MEM/WB boundary. Forwarding paths (aka bypass logic) are used to reduce
the number of stalls by allowing the result of one instruction to be used as an
input to the ALU if required by the next instruction. Conventionally, most of
the control signals from decode and those that control the pipeline and forward-
ing paths are not shown — although that is where many of the most diﬃcult
bugs lie. We use this simple microarchitecture to explain the technique, Sect. 5
discusses how we adapt the approach to handle more realistic microarchitectures
including dual issue, out-of-order retire and register renaming.
Our ﬁrst challenge is to implement the abstraction function abs which is
responsible for converting the micro-architectural state of the processor into
an architectural state. To verify an addition instruction, the function abs must
extract the current values of the integer registers.
Many simple processors commit their results in order in a single pipeline
stage. This means that, at the beginning of the cycle where the add instruction
commits, the micro-architectural register ﬁle should contain the same values as
the architectural register ﬁle before the add executes and, at the end of the
cycle, the micro-architectural register ﬁle should contain the same values as the
45

End-to-End Veriﬁcation of ARM
R
⃝Processors with ISA-Formal
47
Fig. 1. A 5-stage processor pipeline, with forwarding paths, omitting I-Fetch
architectural register ﬁle after the add executes. We can therefore obtain the
state before by reading the state at the end of the writeback stage and the state
after by reading from the end of the Mem stage.
The other part of the input state of the processor that we require is the opcode
of the current instruction. The opcode is normally discarded shortly after instruc-
tion decode and is not available at the point where an instruction commits. We
therefore need to implement a "pipeline follower" which copies the opcode from
one stage to the next and implements the same pipeline stall/ﬂush logic as the
datapath. This is similar to the introduction of "ghost state" in Lahiri et al. [13].
The followers and abstraction logic for the pre/post-states are illustrated in Fig. 2
Fig. 2. A 5-stage processor pipeline with state abstraction and follower
Of course, modern ARM processors are considerably more challenging than
a simple 5-stage pipeline: Sect. 5 describes the variations on the above approach
required to apply ISA-Formal in practice.
Our second challenge is to create a speciﬁcation of the addition instruction.
For any individual instruction, the speciﬁcation can often be written as a short
piece of purely combinational logic. For example, ARM's 16-bit encoding of the
instruction "ADD Rd, Rn, Rm" has opcode 0b0001100 | Rm << 6 | Rn << 3 |
Rd and adds the contents of registers Rn and Rm and writes the result to register
Rd.
46
CHAPTER 3. END-TO-END VERIFICATION OF ARM PROCESSORS

48
A. Reid et al.
This can be implemented by the following System-Verilog.
assign ADD_retiring = (pre.opcode & 16'b1111_1110_0000_0000)
== 16'b0001_1000_0000_0000;
assign ADD_result
= pre.R[pre.opcode[8:6]]
+ pre.R[pre.opcode[5:3]];
assign ADD_Rd
= pre.opcode[2:0];
To complete the example, we add assertions that the abstracted result
matches the result of the speciﬁcation when retiring an add instruction.
assert property (@(posedge clk) disable iff (˜reset_n)
ADD_retiring |-> (ADD_result == post.R[ADD_Rd]));
The above speciﬁcation is remarkably simple so it is worth examining what
kinds of defect this speciﬁcation could catch.
Decode Errors. Most obviously, this speciﬁcation would detect any error in
instruction decoding. But many decode errors are also caught by other veriﬁ-
cation methods such as directed or random testing so, at ﬁrst sight, this does
not seem especially useful. However, the instruction decoder is responsible not
just for determining how to execute the current instruction but also for setting
signals that determine whether it is safe to apply optimizations involving later
instructions. A property like the above found a decoder bug involving one such
signal that determined whether two adjacent instructions could be fused into
a single micro-op: the signal was being incorrectly set for one instruction. This
defect had been missed despite extensive testing of the processor: there were tests
to ensure that the optimization did happen but testing is ill-suited to checking
that it never happens in any other circumstance.
Datapath Errors. An error in a datapath would be caught by this kind of check
although, in practice, many errors of this kind are caught by other veriﬁcation
methods already in use.
Interactions between Instructions. Most usefully, and unlike methods based
on Burch-Dill ﬂushing, this speciﬁcation will detect errors caused by interactions
between instructions such as errors in the forwarding logic that can supply inputs
to this instruction. The example given in the introduction of a sequence of ﬁve
instructions which triggered an error in the forwarding control logic was detected
by a hand-written property like the above. Bugs like this are signiﬁcantly more
important to catch because the forwarding paths vary from one processor to
another, the control logic is diﬃcult to get right and the errors are hard to catch
by conventional tests.
We currently use bounded model checking which veriﬁes that a sequence of
n instructions does not go wrong but to show that any sequence does not go
wrong, we would need to ﬁnd invariants about the processor and use those to
get unbounded proofs. Going further, in order to complete ISA veriﬁcation, we
would need to verify that instructions are not lost, duplicated or reordered (we
have done this for some processors) and, to complete veriﬁcation of the core,
we would need to verify exception taking mechanisms, the instruction fetch unit
and the memory management unit.
47

End-to-End Veriﬁcation of ARM
R
⃝Processors with ISA-Formal
49
4
Generating Veriﬁcation IP with Architecture Explorer
The main challenge in applying the above approach to a full processor is one
of scaling. The ARM v8-M architecture has 384 instruction encodings and the
instruction set part of the architecture speciﬁcation is over 600 pages long [4];
and the ARM v8-A/R architecture has 1280 instruction encodings and is over
2500 pages long [3]. Some of the encodings explicitly disallow using certain reg-
isters as sources or destinations to the instructions, many of the instructions
are conditional and there are a variety of other complications and corner cases.
In addition, changes are regularily added to the architecture speciﬁcation. All
these reasons make the prospect of writing, testing and maintaining a Verilog
speciﬁcation like that shown above unattractive.
Over the last 5 years we have developed tools which transform ARM's oﬃcial
Architecture Reference Manuals into executable speciﬁcations of the v8-A/R and
v8-M architectures [17]. A key part of making this speciﬁcation useful was to test
it thoroughly before using the speciﬁcation to verify anything else. In many ways,
this is like Fox and Myreen's testing of their ARM ISA speciﬁcation [6] except
that we were able to use ARM's internal architecture conformance testsuite
(that is normally used to test processors) to test the speciﬁcations with billions
of instructions that probe each instruction's corner cases.
The core of this speciﬁcation is ARM's Architecture Speciﬁcation Language
(ASL) that grew out of the pseudocode used in earlier versions of the architecture
reference manuals. At a high level, ASL is an indentation-sensitive, imperative,
strongly typed, ﬁrst-order language with type inference, exceptions, enumera-
tions, arrays, records, and no pointers. All integers in ASL are unbounded and
there is direct support for N-bit bitstrings and functions are allowed to be poly-
morphic in the width of a bitstring. For example, memory read returns a value
of type bits(8*size) where size is constrained to be 1, 2, 4 or 8.
The task of scaling the ISA-Formal approach up to handle the full instruction
sets with all their complexities is therefore one of translating the rich, expressive
ASL language to combinational System-Verilog using the synthesizable subset
of Verilog that is accepted by commercial Verilog model checkers. The chal-
lenge in doing this is that synthesizable Verilog is intended to describe hardware
and imposes several limitations upon us; (1) Verilog integers are ﬁnite and the
bitwidth is a part of the type; (2) Combinational Verilog is normally written in
a declarative style with no assignments or control ﬂow and few function calls;
(3) Synthesizable Verilog does not support unbounded for-loops or while-loops;
(4) Synthesizable Verilog does not support exceptions; (5) The width of bit-
strings in Verilog must always be a manifest constant and there is no form of
polymorphism over bitwidths of functions.
We were able to overcome the ﬁrst four issues using relatively conventional
compiler techniques. (1) We use a global ﬂow-insensitive value range analysis to
compute the required width of most integer variables and use a large, but safe
bound for any integers with unknown range. (2) Verilog includes a rarely used
procedural subset which most of the language can be translated into. (3) User-
supplied bounds on loops can be used to unroll all loops. (4) A whole-program
48
CHAPTER 3. END-TO-END VERIFICATION OF ARM PROCESSORS

50
A. Reid et al.
transformation which adds additional ﬂags and control ﬂow to make exception
and return-related control ﬂow explicit.
The most challenging problem was dealing with bitstring polymorphism. Vir-
tually all polymorphism was caused by instructions which could operate on data
of diﬀerent widths such as 8, 16, 32 or 64-bit load instructions. This obser-
vation enabled us to eliminate almost all polymorphism by automatically spe-
cializing such instruction encodings to create a separate instruction for each
data width and then to use alternate passes of constant propagatation and a
"monomorphization" pass which identiﬁes calls to polymorphic functions where
the bitwidth is a manifest constant and replaces the call with a call to a
monomorphic instance of the polymorphic function. The remaining polymor-
phism is handled by a set of ad-hoc transforms in the Verilog backend.
5
Applying ISA-Formal to CPUs
In practice, few processors are as simple as the 5-stage pipeline sketched in
Fig. 1 and we have had to develop a number of techniques in writing abstraction
functions to deal with complex functional units, out-of-order retire, dual issue
pipelines, instruction fusion, and register renaming.
5.1
Complex Functional Units
For the most part, our end-to-end approach to veriﬁcation works: commercial
model checkers are able to handle the complexity of most components without
assistance. However, for complex functional units such as ﬂoating point and the
memory system we choose to use other more scalable veriﬁcation techniques such
as the end-to-end memory-system veriﬁcation technique described by Stewart
et al. [20]. This modular approach lets ISA-Formal veriﬁcation focus on control
logic and forwarding paths that controls, feeds and is fed by these complex units.
In order to make ISA-Formal modular, we partition the speciﬁcation on func-
tion call boundaries into diﬀerent parts "Instruction Set Architecture (ISA),"
"Floating Point," "Exception," "Address Translation," etc. and only generate
Verilog for the "ISA" part. Any functions on the interfaces to other partitions
are written by hand and many are just a few lines long: returning some compo-
nent of the result of the pre-state or changing some component of the post-state.
On the interfaces, we adopt a variety of approaches to ﬁlling the resulting
gaps in the generated Verilog using interface properties, subset behaviour check-
ing and abstract functions. In general, these approaches will prevent us from
detecting bugs in some parts of the processor using ISA-Formal. We tackle this
by tracking which parts of the processor are not being checked by ISA-Formal
and ensuring that an alternative veriﬁcation technique is used on those parts.
Interface Properties. For some components such as the memory system, we
were already creating interface speciﬁcations which were suﬃciently strong that
we could use the interface speciﬁcation instead of the memory system. This only
49

End-to-End Veriﬁcation of ARM
R
⃝Processors with ISA-Formal
51
required us to convert the architectural view of the memory system to the micro-
architectural view by translating requests/responses between representations.
Subset Behaviour Checking. For components such as ﬂoating point units, a
speciﬁcation of the full behaviour would still be too complex to use in veriﬁcation
but is quite simple if we restrict ourselves to a subset of the full behaviour. For
example, if we restrict the inputs to ±{0, 1, ∞, S-NaN, Q-NaN} then it is easy
to create speciﬁcations of all the FP instructions for this subset and perform
some veriﬁcation. Obviously, this would not be suﬃcient to detect errors in the
ﬂoating point unit itself, but this subset gives enough diﬀerent values that errors
in the control and forwarding logic can be detected.
We could use SystemVerilog assumptions to restrict inputs to the chosen set
of inputs, but this would restrict all of the checks that ISA-Formal performs on
instructions: whether the instruction sets condition ﬂags, raises an exception,
accesses memory, which registers are written, etc. Instead, we add an additional
signal indicating whether the inputs are in the supported subset and use that
signal only to restrict checks of the values written to ﬂoating point registers.
Abstract Functions. The ﬁnal option is to use the processor as an oracle.
That is, we add logic to track the inputs and outputs from some functional unit
and then use the output value if the inputs of a function in the architectural
speciﬁcation match the actual inputs of a functional unit in the processor. Since
we are choosing to trust the behaviour of that unit, this cannot detect errors in
the unit but it can detect errors in the surrounding control and forwarding logic.
5.2
Out of Order Completion
In an in-order core, all instructions retire strictly in-order, but some slower
instructions may complete out of order. Retiring a load (say) after the memory
protection check but before the data returns from the memory system allows
independent instructions to continue without waiting for the access to complete.
Such optimizations are important to verify because they introduce diﬃcult cor-
ner cases in the design such as ensuring that the result of the load is written
back even if the processor takes an exception.
The diﬃculty in verifying out-of-order completing instructions is that it is
hard to construct the post-state: by the time that the load instruction completes,
some of the instructions issued after load will also have completed. This is further
complicated because some load instructions may be split into multiple micro-ops
which complete independently.
Our solution to this is to take a snapshot of the pre-state when the load
instruction retires. As each micro-op for the instruction under test completes, the
snapshot is updated with the change. Finally, when the last micro-op completes,
the ﬁnal post-state is available and the instruction can be checked against the
architecture speciﬁcation.
50
CHAPTER 3. END-TO-END VERIFICATION OF ARM PROCESSORS

52
A. Reid et al.
5.3
Dual Issue Pipelines
Dual issue pipelines decode and execute two consecutive instructions in parallel.
To handle dual issue pipelines, we add a further abstraction function to extract
the intermediate state between execution of the two instructions. Our initial
approach to checking these was to create two copies of the combinational logic
implementing the speciﬁcation: one copy for each pipeline. This worked but
consumed a lot of memory and would scale badly for 3 or more-issue processors
so, instead, we use a single copy of the speciﬁcation and insert multiplexors to
select which pre/post state is used with the speciﬁcation.
The most serious problem encountered occurs if the second instruction can
suppress part of the behaviour of the ﬁrst instruction. For example, if both
instructions modify the carry ﬂag, then the ﬁnal value written will be the result of
the second instruction. In this case, the carry ﬂag value from the ﬁrst instruction
may not be available at the writeback stage and we need to identify the correct
signal to use and add a pipeline follower to propagate the value down to the
point of serialization. Any error in choice of signal is detected when that signal
is used as part of the pre-state of the second instruction.
5.4
Instruction Fusion
A high-performance processor might wish to fuse commonly occuring pairs of
consecutive instructions into a single instruction. For example Malik et al. [15]
describes a processor that detects sequences of dependent ALU instructions
such as
SUB R4, R1, R2
; R4 := R1 - R2
ADD R4, R4, R3
; R4 := R4 + R3
and fuses them into a single macro-operation that reads three inputs from the
register ﬁle and performs two add/subtract operations.
Optimizations of this kind raise a potential problem in sequences where the
results of the ﬁrst instruction are overwritten by the second instruction because
the processor may not calculate the post-state of the ﬁrst instruction or the
pre-state of the second instruction.
Our solution is to add additional veriﬁcation logic to calculate the missing
intermediate state. The correctness of this logic is veriﬁed when checking that
all uses of the SUB instruction (i.e., the ﬁrst instruction of the pair) is correct
and that justiﬁes use of the result when checking that the SUB/ADD fused pair
(i.e., the ﬁrst/second instruction pair) gives the correct overall result.
5.5
Register Renaming
Processors with out-of-order instruction issue diﬀer signiﬁcantly from processors
with in-order issue because they speculatively execute instructions past branch
instructions. To allow them to recover from mis-speculation, they use a regis-
ter rename table that maps architectural registers such as "X0" to one of a
51

End-to-End Veriﬁcation of ARM
R
⃝Processors with ISA-Formal
53
large pool of physical registers. As instructions are decoded, source registers are
"renamed" using this table; free physical registers are allocated and the rename
table is updated with mappings from destination register names to these physi-
cal registers. Instructions typically execute as soon as their input dependencies
are satisﬁed but, to preserve the illusion that instructions execute in program
order, a reorder buﬀer (ROB) only commits instructions in program order.
Despite the added complexity of speculative execution, register renaming
and reorder buﬀers, it is actually simpler to apply ISA-Formal to out-of-order
processors because they have a single clearly identiﬁed point of serialization
implemented in the reorder buﬀer. In contrast, in-order processors have a variety
of diﬀerent mechanisms to support a limited degree of out-of-order execution
such as varying pipeline length or supporting out-of-order completion of slow
instructions and these diﬀerent mechanisms are scattered across the processor.
5.6
Debugging Abstraction Functions
From the above, it should be apparent that creating the abstraction code remains
a diﬃcult task and involves a lot of work with the CPU designers to get right.
While debugging these abstraction functions, we have found that it is useful to
start by using hand-written properties like those described in Sect. 3 for instruc-
tions that touch the major parts of the processor. For example, a data-processing
instruction, a load, a store, a ﬂoating point move, etc.
It is signiﬁcantly easier to debug the abstraction function using hand-written
speciﬁcations than using a mechanical translation from the speciﬁcation. Once
we have debugged the abstraction functions, we switch to using the machine-
generated speciﬁcations exclusively, and rarely look at the generated code.
5.7
Handling Known Problems
One of the major diﬃculties we experienced before developing ISA-Formal was
that formal veriﬁcation tools would report variations on the same defect over
and over again. This was a problem early in development when we might know
that part of the processor was missing or incomplete; and it is a problem at any
stage that once the bug report has been ﬁled, the veriﬁcation team wants to
focus on ﬁnding other problems until the bug has been dealt with.
A critical technique for handling known problems is to maintain a list of
assumptions corresponding to each individual bug or feature. As each bug is
ﬁxed, we remove the corresponding assumption and conﬁrm that the bug has
been ﬁxed. Using assumptions is a simple technique but it greatly increases our
ability to use formal veriﬁcation to detect errors early in development and it
very eﬀectively decouples processor design from veriﬁcation allowing the tasks
to proceed in parallel.
6
Results
This section describes the results of applying ISA-Formal in three small-scale
trials and ﬁve full-scale uses. These eight trials and uses cover the full lifetime of
52
CHAPTER 3. END-TO-END VERIFICATION OF ARM PROCESSORS

54
A. Reid et al.
ARM processor developments; they cover both application processor targetted
at mobile phones, etc. and microcontrollers targetted at embedded uses; and
they cover micro-architectures ranging from 3-stage, in-order pipelines through
dual-issue, in-order pipelines to out-of-order pipelines.
6.1
ARM's Development Phases
ARM's development process involves four stages of roughly equal length: Develop
and Test (D&T), Alpha, Beta and Access. The goal of each stage is to create
a basic pipeline design in D&T; make it feature complete by the end of Alpha;
improve power, performance and area through Beta; and to improve conﬁdence
in the design through the access period where the design is made available to
the lead partners for that processor for evaluation and feedback. Testing steadily
increases throughout this process and each stage applies roughly an order of
magnitude more testing than the previous stage.
6.2
Small-Scale Trials
We carried out three small-scale trials on processors that were already in the
access phase to demonstrate the ability of ISA-Formal to detect defects that
were hard to detect by other means. These trials consisted of developing hand-
written properties like those described in Sect. 3 and demonstrated the ability
to detect defects that had been found by other means as well as new defects.
The defect described in the introduction is an example of a bug we detected
during this trial process. The trigger sequence of the defect is conditional exe-
cution of instructions executing in two pipeline stages with a combination of
taken and not-taken instructions. In a 2-pipeline design, the size of the small-
est trigger sequence is 5 instructions: one to set up the condition, two (one per
pipe) to generate values that might be forwarded, and two (one per pipe) to
consume forwarded values. (There are several variations on that basic pattern.)
Using traditional simulation-based veriﬁcation, patterns like this would have to
be tested on all combinations of instructions that have forwarding paths between
them in that particular micro-architecture and each processor will have a diﬀer-
ent set of forwarding paths. There are many, many sequences of instructions like
this to be tested so defects of this form are typically only found during soak-
testing during the Access phase. Using ISA-Formal, we created hand-written
properties for one or two instructions corresponding to each major unit in the
datapath (the ALU, shifter, multiplier, etc.), we created abstraction functions
for each of the two pipelines, and, since we left the opcode received from the fetch
unit unconstrained, the commercial bounded-model-checker explored sequences
of instructions up to some bound. We ran about a dozen properties through
the model checker and after two minutes proof time detected the failing trigger
sequence.
The same experience was repeated on all three processors: bugs were found
with relatively little eﬀort with the bulk of the work being done by junior engi-
neers supervised by formal experts and with input from the microarchitects.
53

End-to-End Veriﬁcation of ARM
R
⃝Processors with ISA-Formal
55
D&T
Alpha
Beta
Access
0
20
40
60
80
Defects detected %
Fig. 3. Defect detection by phase
0
10
20
0
20
40
60
80
100
Time after ISA-Formal starts (weeks)
Cumulative Defects %
Fig. 4. Defect detection by time
The consistent combination of low human eﬀort and low machine eﬀort was an
important part of demonstrating that ISA-Formal could detect diﬃcult defects
that, at best, would have been caught only during the Access phase.
6.3
Production Usage
Based on the success of the small-scale trials, ARM decided to adopt ISA-Formal
as part of the formal veriﬁcation strategy on ﬁve processors that were in earlier
stages in their development: three in D&T, one in Alpha and one in Access. This
work used the tool described in Sect. 4 to generate Verilog for all instructions
directly from ARM's oﬃcial Architecture Reference Manuals allowing engineers
to focus on developing abstraction functions and testing the processor.
Defects have been found in all ﬁve processors with the distribution roughly
in proportion to the eﬀort invested in that processor. The small-scale trials
had demonstrated that ISA-Formal can detect diﬃcult to detect defects late in
processor development; the production usage demonstrated that ISA-Formal is
eﬀective at detecting defects in earlier phases of development. Figures 3 and 4
show the distribution of conﬁrmed, distinct defects detected using ISA-Formal
by phase and by time. Figure 3 shows that ISA-Formal is capable of catching
many defects early in development (overcoming the problem of being able to
ﬁnd many distinct defects in parallel with development) and that it is capable of
ﬁnding defects late in development even after extensive testing by other methods.
Figure 4 shows that ISA-Formal is able to start detecting defects in just a few
weeks work and continues to ﬁnd bugs as processors are developed.
We also found that ISA-Formal was able to detect issues aﬀecting all areas
of the instruction set: FP/SIMD, Memory, Branches, Integer, Exceptions and
System instructions (e.g., memory fence instructions). Figure 5 shows the dis-
tribution of bugs found by ISA-Formal by the area of the processor aﬀected
(combining results for all processors). (The "Integer" category includes both
integer datapath instructions and basic pipeline control issues — it is often hard
to separate the two since integer instructions are so fundamental to a processor.)
54
CHAPTER 3. END-TO-END VERIFICATION OF ARM PROCESSORS

56
A. Reid et al.
FP/SIMD 25%
Memory
21%
Branch
21%
Integer
18%
Exception
8%
System
7%
Fig. 5. Defect detection by area
Processor Lines of code
#1
2400
#2
2250
#3
4600
#4
1000
#5
2500
Fig. 6. Size of veriﬁcation code
It is encouraging to note that the two largest sources of detected bugs were
FP/SIMD instructions and memory instructions. As Sect. 5.1 explains, we do
not test the FPU or the memory subsystem but, despite this, we are still able
to test and ﬁnd defects in the forwarding, pipeline control and register logic
connected to these units.
The eﬀort of creating, testing and debugging the machine-readable speciﬁ-
cation and a tool to translate it to Verilog is considerable but can be shared
across multiple processors and can be used for other purposes within the com-
pany (e.g., documentation, testing of architecture extensions, etc.). The primary
cost of implementing ISA-Formal on a new processor is the eﬀort required to
implement the pipeline follower and abstraction function on each processor. As
a rough indication of the eﬀort required, Fig. 6 shows the number of lines of
code required for each (anonymized) processor. Most processors need around
2,500 lines of support code: a fairly modest cost. The outliers are processor #4
which has not yet added a follower for ﬂoating point registers and processor #3
which is a more complex processor than the other four.
Beyond the bug numbers, we found that applying ISA-Formal early in the
development was capable of ﬁnding bugs that would not normally be caught
until much later. For example, very early in development of an out-of-order
processor, ISA-Formal found a bug that occurred when all the free registers in
the physical register pool were in use. This was found before the processor could
even execute load-store instructions so we would not normally be catching such
bugs that early.
7
Conclusions
Two barriers to widespread industry adoption of formal veriﬁcation techniques
to check processors are scaling and return on investment issues. The end-to-end
approach to veriﬁcation that we adopt tackles both issues: it allows machine-
generation of veriﬁcation IP from the architecture speciﬁcation, it allows engi-
neers to detect bugs that aﬀect actual instruction sequences very early in deploy-
ment, and it encourages creation of reusable tools, techniques and IP that can
be used across an unusually wide range of micro-architectural styles.
This paper describes the steps needed to turn the basic idea into a scal-
able, reusable technique: automation, dealing with a range of diﬀerent micro-
architectural design techniques, and initial bringup issues. We have applied this
55

End-to-End Veriﬁcation of ARM
R
⃝Processors with ISA-Formal
57
method to 8 diﬀerent ARM processors spanning all stages of development up to
release. In all processors, this has found bugs that would have been hard for con-
ventional simulation-based methods to ﬁnd and ISA-Formal is now a key part
of ARM's formal veriﬁcation strategy.
To the best of our knowledge, this is the most broadly applicable formal ver-
iﬁcation technique for verifying processor pipeline control in mainstream com-
mercial use.
References
1. Aagaard, M.D., Cook, B., Day, N.A., Jones, R.B.: A framework for micro-
processor
correctness
statements.
In:
Margaria,
T.,
Melham,
T.F.
(eds.)
CHARME 2001. LNCS, vol. 2144, pp. 433-448. Springer, Heidelberg (2001).
http://dl.acm.org/citation.cfm?id=646705.702043
2. Aagaard, M.D., Jones, R.B., Melham, T.F., O'Leary, J.W., Seger, C.-J.H.: A
methodology for large-scale hardware veriﬁcation. In: Johnson, S.D., Hunt Jr.,
W.A. (eds.) FMCAD 2000. LNCS, vol. 1954, pp. 300-319. Springer, Heidelberg
(2000)
3. ARM Ltd: ARM Architecture Reference Manual (ARMv8, for ARMv8-A architec-
ture proﬁle). ARM Ltd (2013)
4. ARM Ltd: (In Preparation) ARM Architecture Reference Manual (ARMv8, for
ARMv8-M architecture proﬁle). ARM Ltd (2016)
5. Burch, J.R., Dill, D.L.: Automatic veriﬁcation of pipelined microprocessor control.
In: Dill, D.L. (ed.) CAV 1994. LNCS, vol. 818, pp. 68-80. Springer, Heidelberg
(1994). http://dl.acm.org/citation.cfm?id=647763.735662
6. Fox, A., Myreen, M.O.: A trustworthy monadic formalization of the ARMv7
instruction set architecture. In: Kaufmann, M., Paulson, L.C. (eds.) ITP
2010. LNCS, vol. 6172, pp. 243-258. Springer, Heidelberg (2010). doi:10.1007/
978-3-642-14052-5 18
7. Higgins, J.T., Aagaard, M.D.: Simplifying design and veriﬁcation for structural
hazards and datapaths in pipelined circuits. In: Ninth IEEE International Pro-
ceedings of the High-Level Design Validation and Test Workshop, HLDVT 2004,
pp. 31-36 (2004). http://dx.doi.org/10.1109/HLDVT.2004.1431229
8. Hunt Jr., W.A., Sawada, J.: Verifying the FM9801 microarchitecture. IEEE Micro
19(3), 47-55 (1999). doi:10.1109/40.768503
9. Jhalal, R., McMillan, K.L.: Microarchitecture veriﬁcation by compositional model
checking. In: Berry, G., Comon, H., Finkel, A. (eds.) CAV 2001. LNCS, vol. 2102,
p. 396. Springer, Heidelberg (2001). doi:10.1007/3-540-44585-4 40
10. Kaivola, R., et al.: Replacing testing with formal veriﬁcation in Intel R
⃝CoreTM
i7 processor execution engine validation. In: Bouajjani, A., Maler, O. (eds.) CAV
2009. LNCS, vol. 5643, pp. 414-429. Springer, Heidelberg (2009). http://dx.doi.
org/10.1007/978-3-642-02658-4 32
11. KiranKumar, V., Gupta, A., Ghughal, R.: Symbolic trajectory evaluation: the
primary validation vehicle for next generation Intel processor graphics FPU. In:
Formal Methods in Computer-Aided Design (FMCAD), pp. 149-156. IEEE (2012)
12. Kroening, D., Paul, W., Mueller, S.: Proving the correctness of pipelined
micro-architectures. In: Waldschmidt, K., Grimm, C. (eds.) Proceedings of
ITG/GI/GMM-Workshop "Methoden und Beschreibungssprachen zur Model-
lierung und Veriﬁkation von Schaltungen und Systemen", pp. 89-98. VDE Verlag
(2000)
56
CHAPTER 3. END-TO-END VERIFICATION OF ARM PROCESSORS

58
A. Reid et al.
13. Lahiri, S.K., Bryant, R.E.: Deductive veriﬁcation of advanced out-of-order micro-
processors. In: Hunt Jr., W.A., Somenzi, F. (eds.) CAV 2003. LNCS, vol. 2725, pp.
341-354. Springer, Heidelberg (2003). doi:10.1007/978-3-540-45069-6 33
14. Lahiri, S.K., Pixley, C., Albin, K.: Experience with term level modeling and veriﬁ-
cation of the M*CORET M microprocessor core. In: Proceedings of the Sixth IEEE
International High-Level Design Validation and Test Workshop 2001, Monterey,
California, USA, 7-9 November 2001, pp. 109-114 (2001). http://dx.doi.org/10.
1109/HLDVT.2001.972816
15. Malik, N., Eickemeyer, R.J., Vassiliadis, S.: Interlock collapsing ALU for increased
instruction-level parallelism. In: Proceedings of the 25th Annual International Sym-
posium on Microarchitecture, pp. 149-157. MICRO 25, CA (1992). http://dl.acm.
org/citation.cfm?id=144953.145794
16. McMillan, K.L.: Veriﬁcation of an implementation of Tomasulo's algorithm by
compositional model checking. In: Vardi, M.Y. (ed.) CAV 1998. LNCS, vol. 1427,
pp. 110-121. Springer, Heidelberg (1998). http://dl.acm.org/citation.cfm?id=647
767.733764
17. Reid, A.: Creating trustworthy speciﬁcations of ARM v8-A and v8-M system level
architecture. In: preparation (2016)
18. Slobodov´a, A., Davis, J., Swords, S., Hunt Jr., W.: A ﬂexible formal veriﬁcation
framework for industrial scale validation. In: 2011 9th IEEE/ACM International
Conference on Formal Methods and Models for Codesign (MEMOCODE), pp. 89-
97. IEEE (2011)
19. Srinivasan, S.K.: Automatic reﬁnement checking of pipelines with out-of-order exe-
cution. IEEE Trans. Comput. 59(8), 1138-1144 (2010)
20. Stewart, D., Gilday, D., Nevill, D., Roberts, T.: Processor memory system veriﬁ-
cation using DOGReL: a language for specifying end-to-end properties. In: Inter-
national Workshop on Design and Implementation of Formal Tools and Systems,
DIFTS 2014 (2014)
21. Windley, P.J.: Formal modeling and veriﬁcation of microprocessors. IEEE Trans.
Comput. 44(1), 54-72 (1995)
57

58
CHAPTER 3. END-TO-END VERIFICATION OF ARM PROCESSORS

Chapter 4
Who guards the guards? Formal
Validation of the ARM v8-M Architecture
Speciﬁcation (Paper III)
Alastair Reid. Who guards the guards? Formal validation of the ARM v8-M architecture spec-
iﬁcation. In Proceedings of the ACM on Programming Languages, volume 1 of OOPSLA 2017,
New York, NY, USA, October 2017. ACM.
c⃝2017 Alastair David Reid.
doi: https://dx.doi.org/10.1145/3133912.
59

60
CHAPTER 4. WHO GUARDS THE GUARDS?

88
Who Guards the Guards? Formal Validation of the Arm v8-M
Architecture Specification
ALASTAIR REID, Arm Ltd, United Kingdom
Software and hardware are increasingly being formally verified against specifications, but how can we verify
the specifications themselves? This paper explores what it means to formally verify a specification. We solve
three challenges: (1) How to create a secondary, higher-level specification that can be effectively reviewed
by processor designers who are not experts in formal verification; (2) How to avoid common-mode failures
between the specifications; and (3) How to automatically verify the two specifications against each other.
One of the most important specifications for software verification is the processor specification since it
defines the behaviour of machine code and of hardware protection features used by operating systems. We
demonstrate our approach on ARM's v8-M Processor Specification, which is intended to improve the security
of Internet of Things devices. Thus, we focus on establishing the security guarantees the architecture is
intended to provide. Despite the fact that the ARM v8-M specification had previously been extensively tested,
we found twelve bugs (including two security bugs) that have all been fixed by ARM.
CCS Concepts: • Computer systems organization →Architectures; Reduced instruction set computing; •
Hardware →Theorem proving and SAT solving; • Software and its engineering →Consistency; Software
verification; Formal software verification;
Additional Key Words and Phrases: ISA, Specification, Formal Verification
ACM Reference Format:
Alastair Reid. 2017. Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification.
Proc. ACM Program. Lang. 1, OOPSLA, Article 88 (October 2017), 24 pages. https://doi.org/10.1145/3133912
1
INTRODUCTION
The last decade has seen formal verification techniques scaling to the point where it is possible
to formally verify realistic compilers [Leroy 2009], operating system kernels [Klein et al. 2009],
hypervisors [Dam et al. 2013] and processors [Reid et al. 2016]. These efforts are impressive but
we must beware that the correctness of their proofs ultimately rests on the correctness of the
specifications they depend on. This is worrying because these specifications are, themselves, large
and complex artifacts with all the risks of bugs that we expect in large, complex software. This risk
is only likely to increase as more effective formal verification techniques and tools allow larger,
more complex projects to be verified against larger, more complex specifications.
Bugs in specifications are not just a theoretical possibility. In previous work [Reid 2016], we
reported that correcting errors in the ARM v8-A Architecture Reference Manual [ARM Ltd 2013]
resulted in changes to 12% of the lines of code in ARM's processor specification. The CompCert
compiler [Leroy 2009] required a bugfix despite being formally verified and the bug can be traced to
the architecture specification not describing the full behaviour of an instruction [CompCert 2016].
In an empirical study of the correctness of three formally verified distributed systems [Fonseca
Author's address: Alastair Reid, Arm Research, Arm Ltd, 110 Fulbourn Road, Cambridge, CB1 9NJ, United Kingdom,
alastair.reid@arm.com.
Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and
the full citation on the first page. Copyrights for third-party components of this work must be honored. For all other uses,
contact the owner/author(s).
© 2017 Copyright held by the owner/author(s).
2475-1421/2017/10-ART88
https://doi.org/10.1145/3133912
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
61

88:2
Alastair Reid
et al. 2017], no protocol bugs were found in the verified systems but 16 bugs were found in the
Trusted Computing Base (i.e., the unverified glue code, build system, and specifications used to
build the code and in the proof) including two bugs in the specifications. If we are to trust the
guarantees claimed for formally verified software, it is essential that we verify the large, complex
specifications on which our formal correctness claims are founded.
Three common ways that bugs are found in specifications are by testing specifications against
existing implementations [Flur et al. 2016; Fox and Myreen 2010; Goel et al. 2014]; by testing speci-
fications using testsuites used to test implementations [Reid 2016]; or as a side effect of attempting
to formally verify an implementation against a specification [Reid et al. 2016]. Unfortunately, these
approaches can still miss bugs either because test suites are incomplete or because of common
mode failure (i.e., the specification and the implementation do the same wrong thing).
This situation is bad for programmers relying on specifications because, no matter how careful
they are, they are reliant on the quality of the specification available to them. For example, Dun-
lap [Dunlap 2012] describes a bug in the Xen hypervisor that arose because of an inconsistency
between the Intel and AMD specifications of the SYSRET instruction allowing a privilege escalation
when run on Intel processors. The problem is that neither AMD's specification of x86-64 nor Intel's
specification of x86-64 fully captures the range of implementations of the architecture.
The situation is also bad for architects extending specifications. Reliance on testsuites or verifi-
cation against implementations creates a "chicken and egg" problem because implementors and
test writers do not want to work on unstable, incomplete specifications but architects want to test
changes to the specification while they are still developing the changes.
Our solution to this problem is to write high-level properties about the specification and to
formally verify that the specification satisfies those properties.
One of the most important specifications that formal verification of software depends on is
the processor specification that defines the boundary between software and hardware and on
which formal proofs about the entire software and hardware stack are founded. In this paper, we
consider properties about ARM's v8-M architecture specification [ARM Ltd 2016] that extends
ARM's microcontroller specification with additional security features that software can use to
improve the trustworthiness of Internet of Things devices.
We focus on cross-cutting features of the architecture and specify properties of the architecture
as a whole involving exceptions, privilege and security.
Cross-cutting features [Kiczales et al. 1997] are difficult for humans because they require under-
standing of interactions between many disparate parts of the architecture and so subtle errors can
slip through the cracks. The flip side of this is that writing cross-cutting properties can also scale
well: a single cross-cutting property can catch an error in many parts of the architecture. We do
not attempt to state properties about more cleanly decomposable parts of the architecture such
as whether an ADD instruction performs addition. We believe that these properties are adequately
served by existing techniques and that they would not give the same degree of leverage as our
cross-cutting properties.
We developed sets of properties by examination of natural language text in the ARM architecture
reference manual, by examining recently discovered bugs in the specification, and by discussion
with the architects of the specification.
The central design challenge we face is to create a set of properties that:
• express the major guarantees that programmers depend on;
• are concise so that architects can easily review and remember the entire set of properties;
• are stable so that architecture extensions don't invalidate large numbers of rules;
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
62
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:3
• and that describe the architecture differently from the existing specification to reduce the
risk of common-mode failure.
The ARM formal specification is split into many functions all rooted in a single top-level transition
function that specifies any state change that the processor can make due to executing instructions,
taking interrupts, etc. The classic compositional approach would be to tackle the problem hier-
archically: stating and proving properties about the little functions at the bottom of the call tree
of the specification, then using these properties as the basis for proofs about the functions in the
next layer up the call tree and gradually working our way up the tree until all the properties of the
specification have been stated and proved.
This conventional approach has a number of problems:
• It is not how the architects view the architecture. The architects describe the architecture at a
high level in terms of the net effect of the architecture using statements like "if X happens
then Y will happen" or "Y cannot happen unless X is enabled." Walking through the call tree
or the individual lines of code in the specification is a secondary activity during their internal
discussions. This observation is reflected in the natural language part of ARM's architecture
specification and, we believe, reflects the way the architects think about the specification.
Our experience is that, when dealing with domain experts, there is significant benefit from
formalizing their view of the domain instead of forcing them to use a different view.
• It does not aid understanding. The problem we face in gaining confidence that the ARM
specification is correct stems from all the fine detail in the existing specification: it is hard to
see the forest for the trees. Adding properties to each function continues this problem: we
better understand each tree but we still cannot see the forest.
• It increases the maintenance burden. Annotating every function with what would typically be
multiple preconditions and postconditions would require significant specification and review
effort. In addition, the internal structure of the specification is less stable than the boundary
of the specification: functions are refactored, function arguments and results are added or
removed, etc. The more that is written and proved about each individual function, the more
there is to update as the specification evolves.
Accordingly, we adopt an "end to end" approach to writing properties: we only write properties
that apply to the whole system. To make this practical, we extended conventional specification
techniques based on predicates over the state with a novel kind of property inspired by coverage-
based testing techniques.
Our verification is based on translating the specification plus the properties into verification con-
ditions that an SMT solver can check. This allows the verification process to be entirely automated
and requires no expert intervention.
The specification had previously been extensively tested [Reid 2016; Reid et al. 2016] but, despite
this, we found a dozen bugs including two security bugs. Due to extensive testsuites used in ARM
processor development and to redundancy between the natural language part of the specification
and the formal part of the specification, these bugs had not impacted processors but they are
important to anyone verifying software or hardware against the formal part of the specification.
To our knowledge, no realistic architecture specification has been subjected to this degree of
formal verification before.
The remainder of this paper is structured as follows: Section 2 describes the coverage properties
we use to write end-to-end properties; Section 3 sketches the ARM microcontroller architecture,
describes how ARM writes architecture specifications and provides an introduction to how we
write end-to-end properties; Section 4 further illustrates our approach with examples; Section 5
describes the design and implementation of our system; Section 6 describes our experience of using
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
63

88:4
Alastair Reid
the system; Section 7 describes related work; Section 8 describes limitations and future work; and
Section 9 concludes.
2
COVERAGE PROPERTIES
The classic approach to writing properties is to write invariant properties and function properties
using predicates that refer only to the state of the system before and after the state transition
function. Our decision to limit ourselves to writing end-to-end properties makes it very hard to
capture key properties only in terms of states. For example, some properties will only apply if
the system takes a certain kind of transition such as taking a reset or an exception but these are
hard properties to observe from the state alone. In principle, we could reverse engineer the initial
conditions under which these events could occur but then we would be reasoning about when we
think certain transitions occur instead of what the specification actually says.
Our solution to this problem takes its inspiration from the approach used in coverage-based
testing techniques that use measurement of the coverage of the system under test to determine
whether the tests are hitting the relevant parts of the system. For example, many programmers have
added an ad-hoc "debug printf" to a program to confirm that a test hits some line of code or some
condition. More rigorous applications of this approach are built into hardware design languages
such as System Verilog [IEEE 2013] that provides a rich set of functional coverage mechanisms
for tracking how many tests hit each case or combination of cases. Inspired by these test-based
mechanisms, we augment the traditional Hoare-style properties about states with the ability to
observe execution paths. The property Called(f) is satisfied for any execution of the function under
test that calls the function f. For example, to state that an exception causes register R[0] to be set to
zero, one could write the following (where ExceptionEntry is the name of the function that is called
when an exception is taken).
Called(ExceptionEntry) ⇒R[0] = 0
In some cases, finer-grained observation is important and we specify an additional predicate P that
tests the values of the parameters when a function is called. For example, the function ExceptionEntry
has a boolean parameter isSecure that specifies whether a secure or non-secure exception should be
taken so the property
Called(ExceptionEntry when isSecure) ⇒R[0] = 0
weakens the statement to say that R[0] is set to zero for secure exceptions.
Similarly, it is useful to write properties about function return and the values returned. We write
Returned(f when P) to say that a function f returned successfully with values that satisfy the predicate
P. (ARM's specification language includes exceptions so it is possible for a function to be called but
not to return.)
We feel that observing execution paths in this way is a satisfactory compromise on our commit-
ment to writing end-to-end properties: we mostly focus on the overall properties of the architecture
but we allow references to some of the inner structure of the specification when required. In
practice, we find that only a small fraction of the functions need to be observed in this way.
3
FORMALIZING ARM SPECIFICATIONS
The Internet of Things (IoT) adds network access to microcontroller-based systems: a class of
devices that are small, cheap and energy efficient but not previously required to be secure. To meet
this challenge, ARM created the "M-class" of processor that retains the positive characteristics but
adds extensive security features. This does not eliminate the IoT security challenge but it gives
software developers a sound foundation to build on.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
64
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:5
The challenge in designing security features is that security is asymmetric: the designer has to
get everything right but the attacker only has to find a single weakness to gain access. This makes
the design and programming of Internet of Things devices appealing targets of formal verification
research.
This section gives a brief introduction to the essential aspects of ARM's microcontroller specifi-
cation referred to in this paper, describes how ARM writes architecture specifications and provides
an introduction to their formalization.
3.1
The ARM v8-M Security, Privilege and Exception Model
ARM's v8-M architecture specification applies to ARM's 32-bit microcontrollers such as the recently
announced Cortex-M23 and Cortex-M33 processors that are designed for embedded, low-cost
devices at different performance points with a focus on security. Our focus in this paper is on
writing and proving properties about specifications but, in order to explain the examples, it is
necessary to describe a few key architectural concepts.
• An exception can be triggered by memory protection faults, security faults, interrupts, etc. If
the cause of the exception was a fault then an appropriate field of the Fault Status Register is
set to 1. Each exception has a priority and the processor selects the highest priority exception
to work on. On taking an exception, the processor automatically saves the current context
(user registers) onto the current stack and reads the address of the exception handler from an
exception vector table in memory.
• A derived exception occurs if the act of taking an exception triggers a further exception. Two
particular ways that derived exceptions occur are if saving the current context to the stack
triggers a fault such as a stack overflow or if reading the exception vector triggers a fault. A
cascade of up to two derived exceptions can result from an initial exception.
• Lockup occurs if a derived exception has lower priority than the original exception since
there is then no way to report the derived exception. When in lockup, the processor sets the
program counter to a distinctive lockup address and stops executing instructions.
• A processor can be in Privileged or Unprivileged mode. Privilege corresponds to the traditional
protection mechanisms used by operating systems: only privileged execution mode is allowed
to access system registers (including the memory protection registers).
• Orthogonally, a processor can be in Secure or NonSecure mode. The two modes share user
registers but the stack pointer and many of the system control and status registers are banked:
there are two copies and which copy is accessed depends on the current mode. Security goes
beyond traditional processor-based protection and enforces access checks in peripherals and
memory devices so that when a DMA controller or processor is executing in non-secure
mode they cannot access secure peripherals or memory containing secrets such as crypto
keys.
• An external debugger may request that the processor halt and can then examine and modify
the processor and memory state. When the processor is halted, it is said to be in Debug State.
It is possible to disable debugging of the processor when it is in Secure mode.
Inclusion of all these features makes the architecture more complex than a classic RISC archi-
tecture. There are multiple motivations for these features ranging from optimisations that can be
performed in stacking/unstacking registers that make interrupt response faster and more deter-
ministic; enabling interrupt handlers to be written in plain C code; and adding security features. It
also means that some of the corner cases arising from the interaction of features only have to be
handled correctly once by the hardware designers instead of having to be handled in many different
software stacks. However, the combination of four different privilege/security modes, priority,
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
65

88:6
Alastair Reid
derived exceptions, debug, lockup and security adds considerable complexity to the architecture
that makes testing and formal verification of the architecture specification desirable.
3.2
ARM's Specification Language
ARM's architecture specifications consist of two parts: a detailed, executable formal specification
and a natural language part.
The formal part of ARM's specifications is written in ARM's Architecture Specification Language
(ASL) that grew out of the pseudocode used in earlier versions of architecture reference manuals.
At a high level, ASL is an indentation-sensitive, imperative, strongly-typed, first-order language
with type inference, exceptions,1 enumerations, arrays, records, and no pointers. All integers in
ASL are unbounded and there is direct support for N-bit bitvectors and functions are allowed to
be polymorphic in the width of a bitvector. For example, memory read returns a value of type
bits(8∗size) where size is constrained to be 1, 2, 4 or 8.
To make this more concrete, here is a small example of an ASL function that is called when a
processor exception is triggered. The function pushes the current state onto the stack and, if this
does not trigger a memory access fault, it calls the function ExceptionTaken that adjusts registers,
swaps stacks, reads the address of the exception handler from memory and branches to it.
ExcInfo ExceptionEntry(integer exceptionType, boolean toSecure, boolean commitState)
// PushStack() can abandon memory accesses if a fault occurs during the stacking sequence.
exc = PushStack(commitState);
if exc.fault == NoFault then
exc = ExceptionTaken(exceptionType, FALSE, toSecure, FALSE);
return exc;
The ARM v8-M formal specification is over 15,000 lines of code consisting of over 300 instructions
and over 250 functions. This makes it one of the largest formal specifications we are aware of. The
most important functions in the specification are: (1) The function that defines the initial state of
the system. This function is called TakeColdReset and it specifies how the processor performs a "cold"
reset (i.e., when first powered up). (2) The transition function. This function is called TopLevel and
it specifies all types of transition that the specification can make: instruction fetch, instruction
execute, entering and returning from processor exceptions, warm reset, entering/leaving Debug
State, etc.
3.3
Rule Based Specification
ARM's architecture reference manuals also contain natural language statements about the architec-
ture. Starting with the v8-M Architecture Reference Manual [ARM Ltd 2016], these are structured
into a number of labelled "rules." Labels begins with the letter "R" for normative statements and
with the letter "I" for informative statements and are followed by four randomly chosen letters.
We found that many of these rules simply repeated information found in the formal specification
in much the same structure as the formal specification. These were not very useful for our purposes
because they were somewhat low level and, worse, they were prone to common-mode failure wrt
the formal specification. However, a small number of the rules stated high level properties about
the architecture. For example, the following rule describe properties of how a processor can exit
the Lockup state.
1The presence of "exceptions" in both the processor architecture and in ASL can lead to confusion as to which kind of
exception we are referring to. In the remainder of this paper, we use "processor exception" and "ASL exception" to avoid
confusion.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
66
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:7
RJ RJC
Exit from lockup is by any of the following:
• A Cold reset.
• A Warm reset.
• Entry to Debug state.
• Preemption by a higher priority processor exception.
We interpret this to mean that the only way to exit from a lockup state is if one of the four
listed conditions occurs. By examining the ASL specification, we found tests that could be used to
formalize this statement:
• The variable LockedUp indicates whether the processor is in lockup.
• A cold reset is specified by TakeColdReset and a warm reset is specified by the function TakeReset;
• The variable Halted indicates whether the processor is in Debug state.
• Taking a processor exception is initiated by the function ExceptionEntry.
Based on this, one could choose to formalize the original statement in the following Hoare-triple
{ Invariants ∧LockedUp }
TopLevel();
{ ¬ LockedUp ⇒Called(TakeColdReset) ∨Called(TakeReset) ∨(¬Halted' ∧Halted) ∨Called(ExceptionEntry) }
where Invariants is the conjunction of all the invariants for the system and Halted' represents the
value of Halted before the function is called. (This omits the requirement that preemption must be
by a higher priority exception. This is a general requirement on all processor exceptions and we
chose to specify it in a separate property.)
Even for this simple rule, we found this notation to be quite unwieldy so we introduced some
syntactic sugar to let us write properties in a more structured way.
• Each property is labelled for ease of reference.
• Instead of using the v′ convention for accessing the old value of a variable v, we provide an
operator Past(e) that refers to the value of an expression e before the function under test was
called.
• Following the example of System Verilog Assertions [IEEE 2013], we define syntactic sugar
for some common uses of the Past operator.
Stable(e) ˆ= Past(e) = e
Changed(e) ˆ= Past(e) , e
Rose(e) ˆ= Past(e) < e
Fell(e) ˆ= Past(e) > e
By abuse, Rose and Fell can also be applied to boolean expressions.
• We separate the assumptions from the consequences of those assumptions to improve read-
ability.
• We omit the name of the function under test because we wish to test the same invariants on
both the reset function and the transition function and because there is only one transition
function.
In our notation the above property is written as follows.2
2To avoid distraction, we have simplified the ASL language slightly in this paper: omitting explicit type conversions and
using mathematical symbols such as =, , and ∧where the concrete syntax uses conventional programming notation such
as "==", "!=" and "&&".
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
67

88:8
Alastair Reid
property R_JRJC
assume Fell(LockedUp);
Called(TakeColdReset) ∨Called(TakeReset) ∨Rose(Halted) ∨Called(ExceptionEntry);
We feel that this is a reasonably close match to the structure of the original natural language
statement.
Invariants: Invariants are properties that should initially be valid and then their validity should
be preserved by any action the processor takes. An example invariant is that a processor can be in
Lockup or it can be Halted but it cannot be both. In our notation, this property is written like this.
invariant dbg_lockup_mutex
¬(Halted ∧LockedUp);
Unpredictable Behaviour: ARM's specifications are deliberately incomplete and do not specify
what a processor should do in all circumstances. ARM labels these gaps in the specification as
UNPREDICTABLE and the processor is free to do anything that can be achieved at the current or a
lower level of privilege using instructions that are not UNPREDICTABLE and that does not halt or hang
the processor or parts of the system.
Most unpredictable behaviour in the ARM specification is associated with attempting to do some-
thing that is nonsensical and that can be easily avoided by the programmer. In ASL, unpredictable
behaviour is marked by the statement UNPREDICTABLE;. To let us distinguish executions that do not
execute this statement, we add a new property Predictable that is true for executions that do not
execute UNPREDICTABLE;.
Implicit assumptions: All of the properties that we wish to prove about the transition function
only hold under the restrictions that the initial state satisfies the invariant, and the execution is
Predictable. These restrictions could be added to each individual property by adding the following
assumptions:
assume Past(Invariants);
assume Predictable;
where Invariants represents the conjunction of all the invariant properties. Such assumptions would
be the same for all properties and would only serve to add noise to our properties so, instead, we
choose to leave these restrictions implicit and add them in our proof tool (see Section 5.3).
4
EXAMPLES
This section illustrates the use of the notation introduced in the previous section to write further
properties about the architecture and it will look at the challenges in formalizing rules found in the
natural language part of the specification.
4.1
The Exception Entry Bug
One of our motivating examples in this work was trying to detect a bug that had recently been
found in the v8-M specification and to prove that any bugfix does, indeed, fix the bug.
In order to write a property that would detect what the specification did wrong we asked the
v8-M architects how they could tell that the bug had occurred (but not to describe the bug itself).
They told us that the bug involved what state is saved on taking a processor exception. From
testing, they knew that the state was usually saved correctly but, under some circumstances, the
specification was not saving information about which stack the interrupted context was saved on.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
68
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:9
The current stack selection is recorded in the field SPSEL of the register CONTROL. On entry to
a processor exception handler, the current stack selection that was active before the exception is
recorded in bit two of the register LR. Using our notation, we formalized the property like this.
property exn_entry_spsel
assume Called(ExceptionEntry);
assume ¬Called(TakeReset);
assume ¬Called(ExceptionReturn);
Past(CONTROL.SPSEL) = LR<2>;
Having specified the required property, we used our tool to attempt to rediscover the bug. Our
tool generated a counterexample that the architecture development team confirmed as a possible
symptom of the bug they had previously found. In particular, the bug occured if the attempt to
save the state of the processor on the original stack failed and the processor exception could not be
escalated to an appropriate handler (e.g., because the processor was already in the highest priority
exception handler). In this case, the processor enters the Lockup state and stops execution but even
in this desperate circumstance, it is required that the originating mode and security level are saved
correctly in LR to enable the problem to be diagnosed through the debugger.
After confirming that the properties could detect the original bug, we applied a bugfix proposed
by the architecture team and repeated the check. To our relief, all of the processor exception entry
properties were found to hold: our first formal verification that a bugfix actually fixed a specification
bug.
4.2
Property Groups
Properties often share a number of assumptions and triggering conditions so we find it useful to
group multiple properties together to allow them to share common antecedents.
For example, when a processor exception is taken, the processor doesn't just save the current
stack selection, it also saves the current security state, the exception mode, whether the floating
point state is "dirty", etc. We provide some syntactic sugar for writing sets of related properties
sharing a common set of antecedents. The first sub-property in the following is equivalent to the
exn_entry_spsel property above.
rule exn_entry
assume Called(ExceptionEntry);
assume ¬Called(TakeReset);
assume ¬Called(ExceptionReturn);
property spsel: Past(CONTROL.SPSEL) = LR<2>;
property secure: Fell(IsSecure()) ⇔(LR<0> = '1');
property mode: Past((CurrentMode() = PEMode_Handler)) ⇔LR<3> = '0';
property ftype: Past(CONTROL.FPCA) = NOT LR<4>;
4.3
Entry to Lockup
One of the more challenging rules to formalize was the following rule that describes entry to Lockup.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
69

88:10
Alastair Reid
RV GNW
Entry to lockup from a processor exception causes:
• Any Fault Status Registers associated with the exception to be updated.
• No update to the exception state, pending or active.
• The PC to be set to 0xEFFFFFFE.
• EPSR.IT to be become UNKNOWN.
In addition, HFSR.FORCED is not set to 1.
Each bullet in this rule required careful interpretation/debugging in order to understand it.
• Other rules detail which fields of the Fault Status Registers should be set but one consequence
of the first bullet is that at least one bit in Fault Status Register CFSR should be set after entry
to lockup (in configurations that provide the CFSR register).
• The second bullet turned out to be false: pending and active processor exception state should
be updated to reflect the attempted exception entry. The statement had been true in the
previous version of the architecture but had not been updated. We filed a bug against the
documentation.
• The third bullet suggested that we check that PC = 0xEFFFFFFE but this property failed with
counterexamples where PC was equal to 0xF0000002. On investigation, we found that the rule
was implicitly referring to the "debug view" of the program counter that, for historical reasons,
reads as four less than the "program view" that is accessed as PC. We filed a clarification
request against the documentation.
• The fourth bullet is untestable because setting a register to UNKNOWN is allowed to choose
any value — including the current value of the register. We are currently unable to formalize
this statement.
• The final sentence seemed to allow multiple intepretations including HFSR.FORCED must
become 0 or may become 0 or must not be changed. After consulting the architects, we
learned that it meant that HFSR.FORCED is not modified. We filed a clarification request against
the documentation.
Of course, the task of determining which interpretation to use is not quite as direct as suggested
above and in practice, we followed a more experimental methodology. We would typically formalize
several different interpretations of each clause of a rule; we test which interpretations hold for
the specification; and we consult the architects to confirm that the winning interpretation is the
intended interpretation. This lead to the following set of properties
rule lockup_entry
assume Rose(LockedUp);
assume ¬Called(TakeReset);
property R_VGNWa: HaveMainExt() ⇒CFSR , 0;
property R_VGNWc: _RName[RNamesPC] = 0xEFFFFFFE;
property R_VGNWe: Stable(HFSR.FORCED);
4.4
Exit from Lockup
The example rule in Section 3 described when a processor could exit the Lockup state. The following
rule describes one part of what a processor should do when that happens.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
70
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:11
RSPP N
On an exit from lockup by entry to Debug state, or by preemption by a higher priority processor
exception, the return address is 0xEFFFFFFE.
We initially formalized the debug part of this rule with the following property.
property R_SPPNa
assume Fell(LockedUp);
assume Rose(Halted);
LR = 0xEFFFFFFE;
Our tool reported that this property did not hold and, on investigation, we realized that we had
misinterpreted the phrase "return address." When an ARM processor is executing instructions, the
return address is normally held in register LR but when an ARM processor is in Debug state, the
return address is held in the program counter and when an exception is taken, the return address is
held on the stack. The amended formalization read as follows for the debug case
property R_SPPN
assume Fell(LockedUp);
assume Rose(Halted);
_R[RNamesPC] = 0xEFFFFFFE;
We filed a clarification request against the documentation and recommended splitting these two
cases.
4.5
Lockup Invariants
Lockup occurs when a fault occurs and it is not possible to report the fault because the appropriate
fault handler is lower priority than the current execution priority. A consequence of this is that,
under normal circumstances, Lockup can only occur in the highest priority processor exception
handlers: Non-maskable Interrupt NMI and HardFault. We formalized this as follows using the
Interrupt Program Status Register IPSR to read the current processor exception handler and adding
the additional assumption that execution priority had not been boosted using the FAULTMASK
register.
invariant lockup_IPSR
assume LockedUp;
assume FAULTMASK.FM = 0;
IPSR ∈{NMI,HardFault};
A further rule about Lockup states
RMBT M
When the PE is in lockup:
• DHCSR.S_LOCKUP reads as 1.
• The PC reads as 0xEFFFFFFE. This is an execute never (XN) address.
• The PE stops fetching and executing instructions.
• If the implementation provides an external LOCKUP signal, LOCKUP is asserted HIGH.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
71

88:12
Alastair Reid
We formalized this as follows.
rule R_MBTM
assume LockedUp;
invariant a DHCSR.S_LOCKUP = 1;
invariant b PC == 0xEFFFFFFE;
property c
assume Past(LockedUp);
¬ Called(FetchInstr) ∧¬ Called(DecodeExecute);
Attempting to prove these properties found that the DHCSR register was only partially imple-
mented in the specification and that PC referred to the debug view of the program counter and we
filed bugs against the specification and the documentation.
4.6
Preemption by Processor Exceptions
As a final example, an important property of the processor exception mechanism is that execution
can only be preempted by higher priority exceptions. Since higher priority is represented by smaller
numbers, this says that if a processor exception is successfully taken then the priority value must
be lower than it was before the transition. In formalizing and proving this statement, we found a
counterexample: the priority need not increase if the program triggers a derived exception while
attempting to perform a processor exception return (e.g., because of a memory fault while popping
the exception frame off the stack). Our amended statement is as follows.
property priority_increase
assume Called(ExceptionEntry);
assume !Called(ExceptionReturn);
ExecutionPriority() < Past(ExecutionPriority());
Interestingly, the complementary property does not always hold: exception return does not
always lead to a decrease in priority (that is, an increase in priority number) because an exception
handler can dynamically change the priority of an interrupt before returning.
4.7
Summary
This section described several properties we created by talking to the architects or by translating
natural language "rules" to our property notation. The process of formalizing and of attempting
to prove the properties found several bugs in both the formal part of the specification and in the
natural language part.
The bugs we found in the formal specification typically involved corner cases that trigger cascades
of derived processor exceptions, exceptions triggered when returning from an exception, exceptions
triggered because the vector table is in an unreadable part of the memory space, etc. These bugs
tend to creep into a specification because humans find it hard to think about all of the corner cases
and because it is natural to focus on your current task when extending the architecture and to
forget about all of the cross-cutting issues.
It is not surprising to find ambiguous, misleading and erroneous statements in natural language
specification — even one as heavily reviewed as the ARM specification. It took a process of ex-
perimentation to find the correct interpretation of some statements although, a bit like a good
crossword puzzle, our final solution was obvious once we knew what it was. Our property language
and checker allows us to perform those experiments and to confirm that those results are consistent
with the formal specification; and the act of formalizing the statements helps us formulate clearer,
more accurate natural language statements.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
72
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:13
⟨definition⟩
::= 'rule' ⟨ident⟩
{ 'var' ⟨ident⟩':' ⟨type⟩';' }
{ 'assume' ⟨prop⟩';' }
{ ('property' | 'invariant') ⟨ident⟩⟨expr⟩';'
}
|
('property' | 'invariant') ⟨ident⟩
{ 'var' ⟨ident⟩':' ⟨type⟩';' }
{ 'assumes' ⟨expr⟩';' }
⟨expr⟩';'
⟨expr⟩
::= 'Past' '(' ⟨expr⟩')'
|
'Rose' '(' ⟨expr⟩')'
|
'Fell' '(' ⟨expr⟩')'
|
'Stable' '(' ⟨expr⟩')'
|
'Changed' '(' ⟨expr⟩')'
|
'Called' '(' ⟨ident⟩['when' ⟨expr⟩] ')'
|
'Returned' '(' ⟨ident⟩['when' ⟨expr⟩] ')'
|
'PREDICTABLE'
|
'Invariants'
Fig. 1. Property Syntax Extensions
5
DESIGN AND IMPLEMENTATION
This section describes the semantics and implementation of the property notation described in
earlier sections.
5.1
Property Language
Our notation for specifying invariants and properties extends the ASL specification language with
the ability to refer to the values of expressions before execution of the code under test; to test
whether an execution performs an action such as calling a function; and to name properties for
ease of reference. It also adds some syntactic sugar for defining groups of larger properties. The
grammar for these extensions is shown in Figure 1 which defines additional productions for the
⟨definition⟩and ⟨expr⟩non-terminals.
Our property language blends two different notions: conditions involving the state of the pro-
cessor before and after a processor transition; and conditions involving the execution path taken
while executing the state transition function. Defining the semantics of this combination requires
two steps:
• We extend the stateful semantics of the ASL language with generation of a trace during
execution. The details of this extension are unsurprising and results in a trace of function
call and return events. Function call events are represented by C⟨f , ¯a⟩consisting of the name
f of the function and a binding ¯a of the function's formal parameters to the values of each
actual parameter of the call. Function return events are represented by R⟨f , ¯a, ¯r⟩consisting
of the name f of the function and bindings ¯a and ¯r of the function's formal parameters and
results to the names of each function argument and return variable in the function.
• We define the semantics of the Called and Returned operators in terms of this trace. For
any terminating execution producing a trace T, the Called(f when P) operator is satisfied if
T contains an element C⟨f , ¯a⟩such that [[P]] ¯a is satisfied where [[_]]ρ is the semantics of
evaluating a expression wrt a binding ρ. Similarly, the Returned(f when P) operator is satisfied
if T contains an element R⟨f , ¯a, ¯r⟩such that [[P]] ¯a∪¯r is satisfied.
5.2
Implementation
A key requirement for practical deployment is that all proofs should be performed automatically
without needing to train the authors of the architecture in the use of an interactive proof assis-
tant. Our implementation therefore is based on translating the architecture specification and the
properties to be checked into verification conditions suitable for SMT solvers. This translation
consists of three major steps: converting property specifications to ASL; a number of "lowering
passes" that convert complex language features into simpler language features; and converting the
simplified ASL specification to a verification condition expressed in the SMT-Lib language [Barrett
et al. 2016].
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
73

88:14
Alastair Reid
5.2.1
Converting Properties to ASL. Properties are written using an extension of ASL so we
convert each extension into the original ASL language. This is done by introducing "ghost variables"
to collect information needed by the properties and adding code to initialize, update and test these
variables that should execute before, during and after the function under test. We introduce two
new functions SMTPre and SMTPost to hold the statements that execute before and after execution of
the function under test.
• The Past(e) operator is implemented by introducing a fresh global variable v and adding an
assignment v = e; to the SMTPre function. Occurrences of Past(e) are replaced by v.
• The Called(f when P) and Returned(f when P) operators are implemented by introducing a fresh
global boolean variable v initialized to FALSE and instrumenting each function with an assign-
ment v = v ∨P;. The assignment is placed at the start of the function for Called and before each
Return statement for Returned. Occurrences of the operator are replaced by v.
• Invariant properties are evaluated before and after the function under test by creating two
fresh global variables pre and post adding assignments pre = P; and post = P; to SMTPre and to
SMTPost, respectively. Our proof frontend uses the conjunction of all the pre-variables and
(separately) all the post-variables when proving that properties hold.
• All function properties are evaluated after the function under test by creating a fresh global
variable v and adding an assignment v = P; to SMTPost. Our proof frontend replaces the property
name with v.
With this conversion, testing whether a property holds for some function f consists of checking
whether the corresponding global variable is TRUE after executing the sequence SMTPre(); f(); SMTPost();.
5.2.2
Simplifying ASL. The challenge in translating the rich, expressive ASL language to an SMT
problem is that SMT-Lib [Barrett et al. 2016] is a pure expression language and lacks polymorphic
types, dependent types, function calls, control flow, assignments, exceptions and structured data
types.
Before starting translation, we apply a number of "lowering passes" that convert complex
language features into simpler language features. The primary transformations performed in these
passes are
• Eliminating dependent types and polymorphism by specializing all instructions and creat-
ing monomorphic instances of all polymorphic functions. For example, the memory load
instruction can perform an 8, 16, 32 or 64-bit memory access based on a 2-bit size field of the
instruction encoding. This results in many intermediate variables and function arguments
whose width is dependent on the value of the size field. The specialization pass creates 4
separate instances of the instruction each of which accesses a single data width.
• Unrolling all loops. In our application, we were fortunate that it was always possible and often
trivial to find an appropriate loop bound. There was one use of recursion but the architects
were easily persuaded that rewriting it would make it easier to understand. Had this not been
the case, we would have resorted to bounded unrolling and bounded recursion depths as is
common practice elsewhere [Clarke et al. 2004].
• Eliminating unstructured control flow using a simplified form of if-conversion [Allen et al.
1983]. ASL does not have goto but it provides functions that return in the middle of a function
and provides exception throwing that can exit in the middle of a function. This is converted
to structured control flow by introducing an additional control variable into each function.
This variable is initially true but it is set to false in the event of function return or an ASL
exception and the variable is used as a guard to disable actions of statements if the variable
is false.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
74
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:15
• Global context-insensitive, flow-insensitive, structure-insensitive constant propagation and
dead code elimination to exploit the large number of constants introduced by the previous
passes. The choice of global/local and sensitive/insensitive propagation is based on our
understanding of the structure of the specifications we wish to reason about.
These preprocessing steps reduce the ASL specification to a simple monomorphic, imperative
language with functions, structured control flow and no loops or recursion.
5.2.3
Converting ASL to Verification Conditions. The remainder of the transformation is per-
formed by symbolically executing the specification using SMT expressions as symbolic values
and with each step of the evaluation extending a graph of SMT expressions representing the
data/control flow of the program. When control-flow splits, the control expression is remembered,
both control paths are executed using separate copies of the current execution environment, and
when control-flow joins, the two execution environments are merged by introducing if-then-else
nodes to select values from one path or the other. Function calls are handled in the usual way for an
interpreter: a fresh environment is created containing the values of the function arguments and the
function body is evaluated in that environment. Uninitialized variables and UNKNOWN expressions
are handled by introducing oracles (that is, fresh variables that are unconstrained).
Unfortunately, this conventional translation resulted in excessively large SMT problems and we
were unable to generate SMT problems for even the smallest architecture configuration.
To overcome this, we implemented four important optimisations:
• When merging environments, we omit the if-then-else node if neither environment has
changed the value of a variable.
• We perform "hash-consing" to avoid creating nodes that are identical to a previously con-
structed node. This increases the effectiveness of the first optimization in the case that both
branches set a variable to the same value.
• When evaluating an if-statement, if the control expression is definitely true or definitely false
then we avoid exploring the dead branch. This is a significant optimization.
• We perform a limited amount of constant folding to catch constant propagation opportunities
that were missed during preprocessing. Our primary goal in doing this is to evaluate boolean
conditions to make the third optimization more effective.
After implementing these optimisations, the generated SMT expression was still large: approx-
imately 30,000 terms for TakeColdReset and between 360,000 terms and 860,000 terms for TopLevel
depending on the architecture configuration tested. We found that the Z3 SMT solver [de Moura and
Bjørner 2008] was able to handle problems of this size but we found that even proving very shallow
properties took 30-60 minutes: this put the feasibility of tackling interesting properties in question.
To resolve this, we consulted one of the Z3 developers [Wintersteiger 2017] who suggested that we
further simplify the SMT expression by avoiding use of high-level constructs such as enumerated
types and arrays whenever possible. Replacing enumerated types with small bitvectors was an
easy change but to avoid arrays we had to construct expressions that closely resemble the way
that register files are typically implemented in hardware using address decoder trees to write array
elements and using trees of multiplexors to read array elements. These additional optimisations
reduced the need to switch between different theories when solving problems and resulted in a
performance improvement of approximately 5x. Solution times with the above optimisations are
detailed in Section 6.3.
5.3
Proof Frontend
The final part of our implementation is a proof frontend that uses the Z3 solver to prove that
invariant properties and function properties hold.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
75

88:16
Alastair Reid
For each invariant I, we check two properties (expressed here as Hoare triples)
{} TakeColdReset() {I}
{Invariants} TopLevel() {Predictable ⇒I}
For each function property P, we check the property
{Invariants} TopLevel() {Predictable ⇒P}
For each assertion or bounds check P, we check the properties
{} TakeColdReset() {P}
{Invariants} TopLevel() {P}
5.4
Debugging Properties
Given the large size of the state space, we found it hard to debug failing properties just by examining
the initial and final states. To help us understand counterexamples, we added the ability to emit
code that would set the processor registers to the final state.
A minor challenge in doing this is that the generated SMT problem loses several type distinctions
that were present in the original ASL: we solved this by emitting a file containing the ASL-level type
of every SMT variable that our proof tool could use to generate type-correct ASL code. This was
used with an interpreter for ASL that provides useful debugging features such as displaying the call
tree of an execution, displaying register reads/writes, an interactive mode, etc. Using the interpreter
to animate counterexamples proved to be essential for understanding bugs in the specification
and when testing speculative properties and invariants. It was also useful while developing the
transformation from ASL to SMT for identifying differences between the transformation and the
interpreter that indicated bugs in the transformation.
A more significant challenge is that ASL allows underspecification (i.e., the specification does
not completely constrain the behaviour in some circumstances). Our ASL interpreter handles
this by choosing just one possible behaviour whenever the specification provides a choice. In
contrast, the SMT solver explores all possible behaviours and may find a counterexample that is
allowed by the specification but that is not the behaviour chosen by the ASL interpreter. When the
underspecification affects the control path in the specification we can see significant divergence
between the interpreter and the SMT solver. This has prevented us from debugging some of the
failing properties found by our tool (Section 6) and is the subject of future work.
6
EXPERIENCE
We subjectively feel that our properties closely reflect the rules we formalized and, hence, the
way that architects view the architecture. More objectively, we evaluate the effectiveness of our
approach based on the ability of our properties to find bugs, and the efficiency of proof.
6.1
Formalizing Natural Language Specifications
Our original intention in this project was to focus on verifying properties that would be useful
to programmers or that the architects identified as having been hard to get right (e.g., based on
bugfixes to the specification). When we realized that some of the natural language rules in ARM's
existing architecture specification could also be formalized using our tools, we shifted our focus to
formalizing those rules and added more structure to our notation to better match the style of those
rules.
We are also working with the team responsible for creating and maintaining the natural lan-
guage part of ARM's architecture documents about two improvements to the rule style. The first
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
76
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:17
improvement is adoption of a more structured approach where rules are categorized according to
the type of constraint expressed and each type is then written in a consistent way. For example,
responses to exceptional events might be written in a sentence structure like this:
R⟨label⟩
IF ⟨optional preconditions⟩⟨trigger⟩, THEN the ⟨system name⟩shall ⟨system response⟩
(This approach is inspired by the "EARS" requirements specification style [Mavin et al. 2009]
used by Rolls Royce PLC to write the requirements of their avionics engine control systems.) The
second improvement is adoption of a standardized terminology to describe the triggers, actions and
responses. For example, there should be only one way to describe a signal becoming '1', only one
way to describe a signal changing from '0' to '1' and only one way to describe a signal remaining
unchanged. These changes to improve consistency are motivated by a desire for clarity and ease of
understanding and is especially valuable for customers who are not native English speakers.
The more formal notation described in this paper is also a structured way of capturing rules: the
notation for properties and the assumptions they rely on provides a high level structure while the
ASL notation coupled with temporal operators such as Rose and Stable provides a standard way to
describe signal values and their changes.
We are starting to look at extending the formal notation with structures and operators directly
corresponding to the sentence structures and terminology used in the natural language rules.
Our hope is that we can narrow the gap between the two notations so that our formal properties
are "eyeball close" to the corresponding informal rule: that is, identically structured and using
corresponding terminology/notation so that humans can easily see that they have the same meaning.
We don't expect this to be possible for all rules but the experience reported in Section 4 suggests
that it should be possible.
An obvious further step would be to write rules in a style that can always be directly translated
to formal properties or, conversely, to write properties that can be automatically converted from
our formal notation to English sentences [Burke and Johannisson 2005, for example]. Our current
feeling is that this would be a step too far: it is possible and desirable to narrow the gap between
natural language and formal notation but there is a tension between the best way to express rules so
that humans from different technical backgrounds can understand them and the best way to express
properties to enable machine proofs. This tension is especially strong when the specification has to
deal with new concepts for which we do not have a good mathematical theory and may not yet
know how to formalize or prove a property. For example,
• We cannot currently formalize statements about UNKNOWN (see Section 4.3).
• The best way to formalize memory concurrency semantics is still an active area of research
with no clear agreement between an operational approach (e.g., [Flur et al. 2016]) and an
axiomatic approach (e.g., [Alglave et al. 2014]).
• It is not clear how to formalize statements about security properties of the architecture.
In such cases, we must start with a natural language specification, then formalize rules as techniques
and understanding develop and only then hope to find a way of structuring both the rules and the
properties to be "eyeball close."
6.2
Bugs Found
We checked the properties on two configurations of the v8-M architecture: one with security
extensions enabled and one with security extensions disabled. The configuration with security
extensions had previously been heavily tested [Reid 2016] but the configuration without security
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
77

88:18
Alastair Reid
extensions was relatively untested. In addition, debug features had only recently been implemented
and only partially tested.
We checked all properties on both configurations and, in the process, we found twelve bugs in
the formal part of the specification and 9 issues in the natural language part including:
• Trivial Bugs: Array bounds failures, a guarding test that was placed after the action it was
meant to guard instead of before the action, and an uninitialized variable.
• Unimplemented/untested functionality: Some parts of the debug specification were ignoring a
"debug disable" control signal;
• System register problems: We found several bugs in the machine-readable description of the
system registers. Some status fields in system registers gave incorrect information about the
state of the processor while others should have masked the status information based on a
control field but did not.
• Ambiguity of Natural Language: Some bugs were not in the ASL part of the specification but
in the natural language part that specifies the rules.
• Imprecision of Natural Language: Section 4 contains several examples where the specification
referred to the PC but meant the "debug view of the program counter." These lead to consid-
erable confusion and attempts at bugfixes failed until we understood the subtle distinction
between the two.
• Processor exception entry: The example discussed in Section 4.1 was already known to the
architects but we were able to detect it using very high level properties without knowledge
of the details of the bug.
• Mixed logic polarity: The security parts of the specification use boolean variables where TRUE
indicates that something is secure and they also use variables where TRUE indicates that
something is not secure. That is, it uses both positive logic and negative logic. We found a
bug where a variable of one polarity was passed to a function that expected a variable of the
opposite polarity.
• Secure accesses from NonSecure processor: The most serious of the bugs we found was in the
configuration with security extensions disabled. In this configuration, the processor should
behave as though it was in the NonSecure state: all accesses should be non-secure. Our tool
found a case where the processor was treating accesses as secure.
The most difficult and tedious part of this process was in creating invariant properties. Many of
the invariant properties were added in response to puzzling counterexamples involving processor
states that seemed to be nonsensical. After some time staring at these examples, we would convince
ourselves that these nonsense states were unreachable and we would add and prove another
invariant.
6.3
Proof Time
We wrote a total of 59 function properties and invariants. In addition the specification already
contained assertions and we added additional array bounds checks during SMT generation. We
test each of the invariants on both the initial function TakeColdReset and on the transition function
TopLevel and we test the function properties on TopLevel as detailed in Section 5.3. We applied our tool
to two architecture configurations: "NS" with security extensions disabled and "S" with security
extensions enabled. Our SMT generator omits checks for assertions and bounds checks that are
provably satisfied at generation time so the number of assertions and of bounds checks varies
slightly between configurations.
For this experiment, we ran all properties on an Intel(R) Xeon X5670 at 2.93GHz equipped with
48GB memory. We attempted to prove 315 verification conditions. Each proof attempt was run
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
78
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:19
Table 1. Number of properties of different classes for the TakeColdReset and TopLevel functions and number
of proofs that pass, fail or timeout in 30000s.
TakeColdReset
TopLevel
Asserts
Bounds
Invariant
Asserts
Bounds
Invariant
Properties
Configuration = NS
Total
21
2
38
36
2
38
23
Passed
21
2
38
36
2
36
21
Failed
1
Timeout
2
1
Configuration = S
Total
18
3
38
32
3
38
23
Passed
18
3
38
29
3
33
19
Failed
2
Timeout
3
5
2
with a timeout of one day and we were able to prove 299 of them within the timeout. The results
are summarized in Table 1. The 3 failing properties are still being diagnosed but are probably due
to missing invariants. The presence of 7 timeouts on the invariants means that our proofs are not
yet sound but this has not prevented us from using the tool for finding bugs. The presence of 6
timeouts on assertions and properties means that some of those properties could yet fail if given
enough time to run the checks. Though less worrying, we hope to reduce the size of the SMT
problem we generate and that that will allow these proofs to terminate one way or the other in an
acceptable time.
To help understand the timeouts in Table 1, Figures 2a and 2b summarize what fraction of
properties can be proved in a given time interval for the "NS" and "S" configuration, respectively.
As one might expect, proofs about the reset function are fairly trivial and take just a fraction of a
second while the amount of choice present in the transition function makes proofs about TopLevel
take longer. The graphs show that the properties for the "NS" configuration are typically proved
3-10x times faster than the properties for the "S" configuration but even for the "S" configuration
most proofs are generated within 1000 seconds. The total time taken for all passing proofs is under
5 hours and using a 1000 second timeout would result in the tests that fail or timeout taking another
4 hours. In practice, the proof effort should parallelize nicely so the total elapsed time is primarily
bounded by the number of properties that fail or timeout.
6.4
Notation
As Section 5.2.2 shows the ASL language used in the main specification is a little awkward for the
work described in this paper: it would be easier to translate ASL to an SMT problem if all loops had
explicit bounds, if ASL did not support exceptions and did not allow return from the middle of a
function, if ASL did not provide unbounded integers, etc. On the other hand, simplifying ASL in
such ways would make the language less readable, less robust or require a more subtle semantics
(whose finer details might be lost on some readers).
ASL is a compromise specification language intended to be useful to multiple communities inside
and outside ARM: OS engineers, compiler engineers, hardware engineers, hardware verification
engineers, authors of tests, JIT writers, creators of simulators, documentation teams and formal
verifiers of software. Enabling new user groups and applications increases the utility of the spec-
ification, detects previously undiscovered bugs in the specification and, through successful use,
increases our confidence in the specification. The cost of these benefits is that each individual use
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
79

88:20
Alastair Reid
10−1
100
101
102
103
Time (s)
0
20
40
60
80
100
Cumulative percentage of properties proven
Bounds (Reset)
Assertions (Reset)
Invariants (Reset)
Bounds (TopLevel)
Assertions (TopLevel)
Properties (TopLevel)
Invariants (TopLevel)
(a) Time to prove properties about configuration NS
10−1
100
101
102
103
Time (s)
0
20
40
60
80
100
Cumulative percentage of properties proven
Bounds (Reset)
Assertions (Reset)
Invariants (Reset)
Bounds (TopLevel)
Assertions (TopLevel)
Properties (TopLevel)
Invariants (TopLevel)
(b) Time to prove properties about configuration S
Fig. 2. Cumulative time to prove properties
is more difficult than if the specification and tools were optimized for that individual purpose. For
example, ARM's hardware engineers engineers would generally find an unoptimized processor
implementation written in Verilog to be easier to understand and easier to verify against than
the ASL specification. This would lead to fragmentation of the specification since a specification
written in Verilog would only be useful to hardware engineers and other groups would use one or
more separate and incompatible specifications.
7
RELATED WORK
There are two areas of closely related work: formal specification of processors and formal validation
of requirement specifications.
This paper is concerned with the general problem of trusting large specifications but its particular
focus is on specifications of processors. Most recent papers on creating processor specifications
describe how they tested their specification. The most extensively tested processor specifications are
the executable ARM specifications described in our previous work [Reid 2016; Reid et al. 2016] and
the executable x86-64 specifications created by Goel et al. [Goel et al. 2014]. Both have been verified
using substantial programs: Reid uses ARM's architecture conformance testsuite while Goel runs
real programs including (amusingly) a SAT solver. ARM has publicly released their v8-A processor
specification in machine readable form. Reid et al. also formally verify ARM processor pipelines
against the instruction set part of the specification: this increases confidence in the instruction set
part of the specification but it says little about the system architecture part of the specification that
is our primary concern in this paper.
Other notable processor specifications are the Fox/Myreen ARM v7-A ISA specification in
HOL [Fox and Myreen 2010] and Flur et al.'s ISA and concurrency specification in SAIL [Flur et al.
2016] both of which were tested against actual processors using random and directed tests (8400
tests in Flur et al., 281,307 tests in Fox/Myreen). The other major ARM ISA specification that we
are aware of is embedded in the CompCert compiler and is used in the proof that the compiler
faithfully translates the input C program to ARM assembly code. This specification is limited to a
subset of the user-mode ARMv6 specification and there is no published statement of how it was
validated.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
80
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:21
It is clear that testing of processor specifications is becoming standard practice but all of the
above work consists of testing or formally verifying the specification against implementations of
that specification. They are therefore vulnerable to the problems we identified in the introduction:
(1) Testing of the specification cannot begin until the first implementation or a test suite is produced;
and (2) Testing against an implementation of the specification is vulnerable to common mode
failure. Our approach avoids these pitfalls by relying on formalization of high level properties that
the specification is intended to meet and it avoids the well known limitations of testing by using
formal verification techniques.
We believe that our Called operator is a novel feature in formal specifications but it can be seen as
a adaptation of the coverage measurement features found in System Verilog [IEEE 2013] that allow
verification engineers to annotate Verilog programs with specific coverage goals. Verilog simulation
tools generate reports of how many times each coverage goal was hit allowing verification engineers
to confirm that their test harness is exercising the desired behaviour. Alternatively, in software
testing, it is common to add debug printf statements to a program to confirm that a certain path is
being tested.
Another important part of processor architecture is the specification of the memory concurrency
semantics [Alglave et al. 2014; Flur et al. 2016; Sarkar et al. 2011]. These specifications are tested
extensively against commercial processors. More recently, the MemAlloy tool has been created for
automatically comparing memory consistency models [Wickerson et al. 2017]. Although different
in almost every detail, we see this as solving a similar problem: understanding if a specification is
correct without the need to wait until an implementation is available.
Our work can also be seen as a variant on formal validation of requirements specifications3.
The Alloy language and analyzer [Jackson 2002] is closest to the system described here. Alloy is a
simplified and improved descendant of the Z notation that allows definition of a model consisting
of some state and operations on those states states and one can verify expected properties using a
SAT solver. In some ways, Alloy is considerably more general and sophisticated than the system
described here: it provides a simple, mathematically clean language for specification. In other ways
the ASL language is more powerful because it provides specialized concepts for the task of defining
processor semantics such as bitvectors and dependent types, concepts like instructions and bitfields
of registers, etc. and it is imperative: these features allow the creation of detailed specifications of
large, complex architectures and proofs about specifications with very large state spaces.
The Formal Tropos language [Fuxman et al. 2001] is specifically designed to allow the form of
loose specification that characterizes the early stages of requirements engineering: it focusses on
entities and the relationships between them and allows the addition both of hard goals specified
using first order linear temporal logic and soft goals that might be subjective (e.g., a company
may have a goal of attracting new customers). The language provides a number of high level
abstractions of events such as notions of object creation, fulfillment of a goal, etc. that could
be expressed in temporal logic but whose inclusion improved readability; specifications can be
animated to check understanding; and model checking can be used to formally verify that properties
of the specification are true or can be satisfied. Support for temporal logic is the most obvious
difference from our system but we are not sure that model checkers would be able to cope with the
large state spaces of our specification because, even with explicit invariants, some of the properties
we wish to check are barely provable by an SMT solver. However, the rich set of abstractions for
3Strictly speaking, ARM says that the natural language rules and the formal ASL specification in ARM's specifications
have equal weight: they are both part of the specification and both must be satisfied by an implementation. However, in
this work we have treated the natural language rules as a loose specification of the properties that the more precise ASL
specification is required to satisfy — much as a requirements specification can be seen as a loose specification for more
refined specifications developed as design and implementation proceeds.
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
81

88:22
Alastair Reid
describing events appears useful and we are considering whether they can be adopted without
requiring the use of model-checking.
More broadly, it is common practice when creating specifications in a theorem prover to prove
that a new definition satisfies sets of properties such as commutativity, associativity, etc. [Pierce et al.
2016]. Like our properties about specifications, such properties may not completely characterize
the functions being developed but they give increased confidence that the functions are correct
and they are often useful when using those functions. The difference is that our specifications are
somewhat larger and that our properties make use of the ability of our property language to restrict
the set of execution paths taken by the function being checked.
8
LIMITATIONS AND FUTURE WORK
This is part of a long program of creating a complete and precise specification of the ARM archi-
tecture. The most significant limitation is that it has not yet been integrated with parallel work
on concurrent memory semantics [Alglave et al. 2014; Flur et al. 2016; Sarkar et al. 2011]. This
limitation shows up most clearly in situations where TopLevel performs multiple memory accesses in
a single transition (either because of executing ARM's "load/store multiple" instructions or because
of pushing/popping context on/off the stack during exceptions). Our reasoning treats the entire
execution/exception as a single atomic transition while an external observer would see multiple
independent memory accesses.
We see this work as a step towards creating a set of properties that can be used to verify low-level
system code such as interrupt handlers, memory protection, etc. We hope that this could be used to
plug the gaps in formal proofs of software such as the seL4 OS kernel [Klein et al. 2009, Section 4.4]
that rely on manual inspection and thorough testing of a few pieces of low-level code instead of
providing a formal proof.
The current performance of our tool is adequate for daily or weekly checking of the specification
but it is currently too slow to use as a check on every commit to the specification repository. We
plan to implement a variation on DAG inlining [Lal and Qadeer 2015] to improve scalability.
We are considering how we could formalize the statement in Section 4.3 that says "EPSR.IT to
be become UNKNOWN." This property cannot be checked in our current implementation because
it is a 2-safety property: detecting a violation would require comparing the result of traces from
two program traces [Clarkson and Schneider 2010].
9
CONCLUSION
Formal verification of programs is becoming more and more practical but, if the verification is
to be meaningful, it must be based on correct architecture specifications for the hardware that
the programs run on. That is, the specifications are a critical part of the Trusted Computing Base.
Unfortunately, the size and complexity of architecture specifications is such that it seems inevitable
that specifications will contain bugs and our previous work confirms this supposition [Reid 2016].
While it is common to debug specifications by testing the specification, this paper proposes a
different approach: we define a set of formal properties that should hold for the specification and
we formally verify that the architecture specification satisfies these properties. We think of the
relationship between the properties and the specification as being like the relationship between a
nation's constitution and a nation's laws: the constitution is concise enough that everyone can
read them while the laws are too large for effective review; the constitution can be used to test
whether existing or proposed laws are compatible with high level goals; and the constitution is
stable and changes very, very slowly.
We have extended ARM's Architecture Specification Language with a property language that
is able to concisely express many of the properties currently written in natural language. Our
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
82
CHAPTER 4. WHO GUARDS THE GUARDS?

Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification
88:23
extension's power comes from a novel coverage operator that lets us express cross-cutting, end-to-
end properties. We are able to check that these properties hold by converting both the specification
and the properties to verification conditions that can be checked in a push-button manner using an
SMT solver. We have used this system to check ARM's v8-M specification. Despite the fact that the
ARM v8-M specification had previously been extensively tested and reviewed, we found twelve
bugs in it, that have all been fixed by ARM.
To our knowledge, no realistic architecture specification has been subjected to this degree of
formal verification before.
ACKNOWLEDGMENTS
We wish to thank Christoph Wintersteiger for his suggestions for using Z3 more effectively. We
are grateful to John Regehr, Peter Sewell and Nathan Chong and to the anonymous referees for
their comments and suggestions about the content and presentation of this paper.
REFERENCES
Jade Alglave, Luc Maranget, and Michael Tautschnig. 2014. Herding Cats: Modelling, Simulation, Testing, and Data Mining
for Weak Memory. ACM Trans. Program. Lang. Syst. 36, 2 (2014), 7:1-7:74. DOI:http://dx.doi.org/10.1145/2627752
J. R. Allen, Ken Kennedy, Carrie Porterfield, and Joe Warren. 1983. Conversion of Control Dependence to Data Dependence.
In Proceedings of the 10th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL '83). ACM,
New York, NY, USA, 177-189. DOI:http://dx.doi.org/10.1145/567067.567085
ARM Ltd. 2013. ARM Architecture Reference Manual (ARMv8, for ARMv8-A architecture profile) (DDI0487). ARM Ltd. https:
//developer.arm.com/docs/ddi0487/a/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile
ARM Ltd. 2016. ARMv8-M Architecture Reference Manual (DDI0553). ARM Ltd. https://developer.arm.com/docs/ddi0553/
latest/armv8-m-architecture-reference-manual
Clark Barrett, Pascal Fontaine, and Cesare Tinelli. 2016.
The Satisfiability Modulo Theories Library (SMT-LIB).
www.SMT-LIB.org. (2016).
D. A. Burke and K. Johannisson. 2005. Translating Formal Software Specifications to Natural Language / A Grammar-Based
Approach. Logical Aspects of Computational Linguistics (LACL 2005) 3402 (2005), 51-66. DOI:http://dx.doi.org/10.1007/
11422532_4
Edmund Clarke, Daniel Kroening, and Flavio Lerda. 2004. A Tool for Checking ANSI-C Programs. Springer Berlin Heidelberg,
Berlin, Heidelberg, 168-176. DOI:http://dx.doi.org/10.1007/978-3-540-24730-2_15
Michael R. Clarkson and Fred B. Schneider. 2010. Hyperproperties. Journal of Computer Security 18, 6 (Sept. 2010), 1157-1210.
DOI:http://dx.doi.org/10.3233/JCS-2009-0393
CompCert. 2016. Release Notes for CompCert 2.7 (Bugfixes). (29 June 2016). http://compcert.inria.fr/release/Changelog
Mads Dam, Roberto Guanciale, and Hamed Nemati. 2013. Machine Code Verification of a Tiny ARM Hypervisor. In Proc.
Workshop on Trustworthy Embedded Devices (TrustED '13). ACM, 3-12. DOI:http://dx.doi.org/10.1145/2517300.2517302
Leonardo de Moura and Nikolaj Bjørner. 2008. Z3: An Efficient SMT Solver. Springer Berlin Heidelberg, 337-340. DOI:
http://dx.doi.org/10.1007/978-3-540-78800-3_24
George Dunlap. 2012. The Intel SYSRET Privilege Escalation (Xen Project Blog). (2012). https://blog.xenproject.org/2012/06/
13/the-intel-sysret-privilege-escalation/
Shaked Flur, Kathryn E. Gray, Christopher Pulte, Susmit Sarkar, Ali Sezgin, Luc Maranget, Will Deacon, and Peter Sewell.
2016. Modelling the ARMv8 architecture, operationally: Concurrency and ISA. In Proc. Principles of Programming
Languages, POPL 2016. ACM, 608-621. DOI:http://dx.doi.org/10.1145/2837614.2837615
Pedro Fonseca, Kaiyuan Zhang, Xi Wang, and Arvind Krishnamurthy. 2017. An Empirical Study on the Correctness of
Formally Verified Distributed Systems. In Proceedings of the Twelfth European Conference on Computer Systems (EuroSys
'17). ACM, New York, NY, USA, 328-343. DOI:http://dx.doi.org/10.1145/3064176.3064183
Anthony C. J. Fox and Magnus O. Myreen. 2010. A Trustworthy Monadic Formalization of the ARMv7 Instruction Set
Architecture. In Proc. Interactive Theorem Proving ITP 2010 (LNCS), Vol. 6172. Springer, 243-258. DOI:http://dx.doi.org/10.
1007/978-3-642-14052-5_18
Ariel Fuxman, Marco Pistore, John Mylopoulos, and Paolo Traverso. 2001. Model checking early requirements specifications
in Tropos. In Requirements Engineering, 2001. Proceedings. Fifth IEEE International Symposium on. IEEE, IEEE, 174-181.
DOI:http://dx.doi.org/10.1109/ISRE.2001.948557
Shilpi Goel, Warren A. Hunt, Matt Kaufmann, and Soumava Ghosh. 2014. Simulation and formal verification of x86
machine-code programs that make system calls. In Formal Methods in Computer-Aided Design, FMCAD. 91-98. DOI:
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
83

88:24
Alastair Reid
http://dx.doi.org/10.1109/FMCAD.2014.6987600
IEEE. 2013. IEEE Standard for SystemVerilog - Unified Hardware Design, Specification, and Verification Language. IEEE Std.
1800-2012 (2013). DOI:http://dx.doi.org/10.1109/IEEESTD.2013.6469140
Daniel Jackson. 2002. Alloy: A Lightweight Object Modelling Notation. ACM Transactions on Software Engineering and
Methodology (TOSEM) 11, 2 (April 2002), 256-290. DOI:http://dx.doi.org/10.1145/505145.505149
Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cristina Lopes, Jean-Marc Loingtier, and John Irwin.
1997. Aspect-oriented programming. In Proceedings of the 11th European Conference on Object-Oriented Programming
(ECOOP'97), Mehmet Akşit and Satoshi Matsuoka (Eds.). Springer, Berlin, Heidelberg, 220-242. DOI:http://dx.doi.org/10.
1007/BFb0053381
Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock, Philip Derrin, Dhammika Elkaduwe, Kai
Engelhardt, Rafal Kolanski, Michael Norrish, Thomas Sewell, Harvey Tuch, and Simon Winwood. 2009. seL4: Formal
Verification of an OS Kernel. In Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles (SOSP
'09). ACM, New York, NY, USA, 207-220. DOI:http://dx.doi.org/10.1145/1629575.1629596
Akash Lal and Shaz Qadeer. 2015. DAG Inlining: A Decision Procedure for Reachability-modulo-theories in Hierarchical
Programs. In Programming Language Design and Implementation (PLDI), Vol. 50. ACM, New York, NY, USA, 280-290.
DOI:http://dx.doi.org/10.1145/2813885.2737987
Xavier Leroy. 2009. Formal verification of a realistic compiler. Commun. ACM 52, 7 (2009), 107-115. DOI:http://dx.doi.org/
10.1145/1538788.1538814
Alistair Mavin, Philip Wilkinson, Adrian Harwood, and Mark Novak. 2009. Easy Approach to Requirements Syntax (EARS).
In 17th IEEE International Requirements Engineering Conference (RE'09). IEEE. DOI:http://dx.doi.org/10.1109/RE.2009.9
Benjamin C. Pierce, Arthur Azevedo de Amorim, Chris Casinghino, Marco Gaboardi, Michael Greenberg, Cˇatˇalin Hriţcu,
Vilhelm Sjöberg, and Brent Yorgey. 2016. Software Foundations. Electronic textbook. http://www.cis.upenn.edu/~bcpierce/
sf Version 4.0.
Alastair Reid. 2016. Trustworthy Specifications of ARM v8-A and v8-M System Level Architecture. In Proceedings of Formal
Methods in Computer-Aided Design, (FMCAD 2016), Mountain View, CA, USA. 161-168. DOI:http://dx.doi.org/10.1109/
FMCAD.2016.7886675
Alastair Reid, Rick Chen, Anastasios Deligiannis, David Gilday, David Hoyes, Will Keen, Ashan Pathirane, Owen Shepherd,
Peter Vrabel, and Ali Zaidi. 2016. End-to-End Verification of ARM Processors with ISA-Formal, In Proceedings of the
2016 International Conference on Computer Aided Verification (CAV'16), S. Chaudhuri and A. Farzan (Eds.). CAV 2016,
Part II, Lecture Notes in Computer Science 9780 (July 2016), 42-58. DOI:http://dx.doi.org/10.1007/978-3-319-41540-6_3
Susmit Sarkar, Peter Sewell, Jade Alglave, Luc Maranget, and Derek Williams. 2011. Understanding POWER multiprocessors.
In Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2011,
San Jose, CA, USA, June 4-8, 2011, Mary W. Hall and David A. Padua (Eds.). ACM, 175-186. DOI:http://dx.doi.org/10.
1145/1993498.1993520
John Wickerson, Mark Batty, Tyler Sorensen, and George A. Constantinides. 2017. Automatically Comparing Memory
Consistency Models. In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL
2017). ACM, New York, NY, USA, 190-204. DOI:http://dx.doi.org/10.1145/3009837.3009838
Christoph M. Wintersteiger. 2017. Private communication. (2017).
Proceedings of the ACM on Programming Languages, Vol. 1, No. OOPSLA, Article 88. Publication date: October 2017.
84
CHAPTER 4. WHO GUARDS THE GUARDS?

Part II
Creating high performance
hardware-software interfaces
85


87
One paper and one patent are presented in this section.
Paper IV "SoC-C: efﬁcient programming abstractions for heterogeneous multicore systems
on chip" [102] describes the design and implementation of a set of extensions to the C program-
ming language that direct the mapping of that program to different parts of a heterogeneous
multiprocessor system.
Patent I "Reducing inter-task latency in a multiprocessor system" [103] describes an exten-
sion of the technique described in Paper IV that is able to exploit simple task triggering hardware
to reduce the latency between tasks running on the different processors within the system.

88

Chapter 5
SoC-C: efﬁcient programming
abstractions for heterogeneous multicore
systems on chip (Paper IV)
Alastair D. Reid, Krisztián Flautner, Edmund Grimley-Evans, and Yuan Lin. SoC-C: efﬁcient
programming abstractions for heterogeneous multicore systems on chip. In Erik R. Altman,
editor, Proceedings of the 2008 International Conference on Compilers, Architecture, and Syn-
thesis for Embedded Systems, CASES 2008, Atlanta, GA, USA, October 19-24, 2008, pages
95-104. ACM, October 2008.
c⃝2008 Association for Computing Machinery, Inc. Reprinted by permission. License number:
4296051467934.
doi: https://dx.doi.org/10.1145/1450095.1450112.
89

90
CHAPTER 5. SOC-C: EFFICIENT PROGRAMMING ABSTRACTIONS

SoC-C: Efﬁcient Programming Abstractions for
Heterogeneous Multicore Systems on Chip
Alastair D. Reid
Krisztian Flautner
Edmund Grimley-Evans
ARM Ltd
Yuan Lin
University of Michigan
ABSTRACT
The architectures of system-on-chip (SoC) platforms found in
high-end consumer devices are getting more and more complex
as designers strive to deliver increasingly compute-intensive ap-
plications on near-constant energy budgets. Workloads running
on these platforms require the exploitation of heterogeneous par-
allelism and increasingly irregular memory hierarchies. The con-
ventional approach to programming such hardware is very low-
level but this yields software which is intimately and inseparably
tied to the details of the platform it was originally designed for,
limiting the software's portability, and, ultimately, the architec-
tural choices available to designers of future platform generations.
The key insight of this paper is that many of the problems experi-
enced in mapping applications onto SoC platforms come not from
deciding how to map a program onto the hardware but from the
need to restructure the program and the number of interdepen-
dencies introduced in the process of implementing those decisions.
We tackle this complexity with a set of language extensions which
allows the programmer to introduce pipeline parallelism into se-
quential programs, manage distributed memories, and express the
desired mapping of tasks to resources. The compiler takes care
of the complex, error-prone details required to implement that
mapping.
We demonstrate the eﬀectiveness of SoC-C and its
compiler with a "software deﬁned radio" example (the PHY layer
of a Digital Video Broadcast receiver) achieving a 3.4x speedup
on 4 cores.
Categories and Subject Descriptors: D.3.3 [Software]:
Programming Languages
General Terms: Languages
1.
INTRODUCTION
In the next ﬁve years the peak available bandwidth to mo-
bile phones is expected to increase from less than 5 Mbps
today to 100 Mbps in 2012. The signal-processing through-
put to implement these protocols is expected to increase to
beyond 25 giga-operations per second. Commodity cameras
on phones already support 10M pixel resolution which fur-
ther drives the need for high-speed multimedia image pro-
cessing, high-deﬁnition video coding and 3D graphics. To
maintain the same form-factor, this massive performance
must be achieved without increasing battery size which lim-
its the power consumption to around 1 Watt.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CASES'08, October 19-24, 2008, Atlanta, Georgia, USA.
Copyright 2008 ACM 978-1-60558-469-0/08/10 ...$5.00.
Modern DSP designs are starting to achieve the required
energy eﬃciency. For example, ARM's prototype data pro-
cessing engine can sustain over 10 GMAC/s at less than
300mW in 65nm technology. The main problem is not cre-
ating energy-eﬃcient hardware but creating eﬃcient, main-
tainable programs to run on them. In order to save energy
and, to some extent, silicon area, high performance embed-
ded systems eschew features that characterize today's high-
end multiprocessor systems: Homogeneous processors are
replaced by a heterogeneous mix of specialized processors
tuned to particular parts of the expected workload; General-
purpose processors programmed in C, C++, etc. are supple-
mented by special-purpose accelerator engines which may be
ﬁxed-function, conﬁgurable or programmable using a C sub-
set; Shared memory is replaced by multiple private memo-
ries to decrease latency and energy and increase bandwidth;
and Hardware cache coherency is omitted to save area and
power consumed by cache coherence protocols.
Omitting
these features from high performance embedded systems re-
quires programmers to adopt a very low-level, error-prone
programming style that limits portability and maintainabil-
ity.
The key insight of this paper is that these problems come
not from deciding how to map the application onto the hard-
ware but from the restructuring of the code and the number
of interdependencies introduced in the process of implement-
ing those decisions.
Rather than abandon features because
of their hardware cost, SoC-C moves their implementation
into the language so that the programmer can reason about
and optimize the mapping at a high level while the compiler
takes care of the complex, error-prone details required to
implement that mapping.
SoC-C is a set of language extensions that enables pro-
grammers to express eﬃcient system-on-chip programs that
exploit the parallelism available in the platform, provides
programmers with control over how the many diﬀerent pro-
cessing elements in the platforms are used, and requires lit-
tle or no restructuring when the application is subsequently
ported within a family of platform architectures.
This paper makes the following contributions:
We de-
scribe channel-based decoupling: a novel spin on existing
ways to automatically introduce pipeline parallelism that
allows programmers to tradeoﬀdeterminism for scheduling
freedom and is capable of handling the complex control ﬂow
that real applications require. We propose a novel way of ex-
pressing the data copying that must happen in a distributed
memory system. Our annotations express the programmer's
intent allowing the compiler to detect missing or incorrect
copy operations. We describe an inference mechanism that
91

// Data placement
declaration ::= type variable @ { memory1, ... memoryn } ;
expression ::= variable @ memory
statement
::= SYNC(variable[,memory[,memory]]
) @ processor ;
// Code placement
expression ::= identiﬁer( expression, ... expression
) @ processor
// Fork-join parallelism
statement
::= parallel sections {
section {
compound-statement } ;
. . .
section {
compound-statement } ;
}
// Pipeline parallelism
statement
::= pipeline { compound-statement }
statement
::= FIFO ( variable ) ;
Figure 1: SoC-C syntax extensions.
signiﬁcantly reduces the amount of annotation required to
map an application onto a hardware platform. We identify
the critical optimizations required to support the high level
programming model. With these optimizations, SoC-C can
achieve accelerator utilization levels of 94% and a speedup
of 3.4x on a platform with 4 accelerators on a real workload.
The paper is structured as follows. Section 2 describes a
set of obvious minimal extensions to C to support heteroge-
neous, distributed parallel systems and introduces an exam-
ple to illustrate why these extensions are necessary but in-
suﬃcient for programming complex SoCs. Thus motivated,
Sections 3-6 make a series of improvements showing how
each extension improves the running example and we eval-
uate the expressiveness of the extensions in Section 7. Sec-
tions 8 and 9 discuss optimizations and performance. Sec-
tion 10 discusses related work and Section 11 concludes.
This paper does not address how the best application
mapping can be generated automatically using program anal-
ysis, proﬁling, iterative compilation, etc. for two reasons.
The ﬁrst is that the mechanism used to choose a mapping
is largely orthogonal to the mechanism used to act on those
decisions. The second is that there is no single obvious prop-
erty to optimize for in embedded systems. Depending on the
system one may want to optimize for some combination of
battery life, low-latency user experience, meeting real-time
deadlines, reducing number of retransmits, code size, etc.
2.
A MINIMAL EXTENSION TO C
This Section considers minimal extensions to C to support
heterogeneous multiprocessor systems with distributed mem-
ory and shows that whilst these or similar extensions are
necessary (and form the basis of SoC-C), they are not suﬃ-
cient for creating high performance, maintainable programs.
This sets the stage for later sections which describe further
extensions and optimizations to tackle these problems.
The extensions considered in this Section are those re-
quired to introduce parallelism, control sharing of resources
and variables, communicate between threads, map data onto
memories and map code onto processors/accelerators. Our
descriptions of the extensions are brief because they are
based on extensions found in other languages such as OpenMP
(which inspired our notation), Concurrent Pascal, etc. Fig-
ure 1 summarizes all the extensions discussed in this paper.
Parallel sections introduce fork-join parallelism where
a single master thread forks multiple child tasks (which may
also fork child tasks) and waits for all children to complete.
complex_t samples[2048];
bool
bits[3024];
int8_t
bytes[378];
int
timing_correction = 0;
while (1) {
ADC_get(&adc,&samples,2048);
AdjustTiming(timing_correction,samples);
FFT(samples);
timing_correction += FindTimeOffset(samples);
Demodulate(bits,samples);
ErrorCorrect(bytes,bits);
}
Figure 2: A simpliﬁed OFDM radio receiver.
The statement
parallel_sections{
section{ statement1 }
section{ statement2 }
}
executes statement1 and statement2 in parallel and com-
pletes when both statements complete. Parallel sections can
be implemented by forking one thread per section and then
waiting for all threads to complete. Since this is the basic
mechanism for expressing all parallelism, it is the program-
mer's responsibility to avoid race conditions, deadlock, etc.
Channels synchronize/communicate between threads.
FIFO channels provide two operations: "fifo_put" atomi-
cally transfers data into the channel and "fifo_get" opera-
tions atomically transfers data out (blocking if the channel
is full/empty). This atomic-transfer semantics ensures that
each thread has exclusive access to the data.
Data placement annotations map variables to memo-
ries. A variable declaration of the form
type V @
M ;
instructs the SoC-C compiler and linker to place the variable
'V' in memory 'M'.
Code placement annotations perform RPCs. A func-
tion call of the form
function(expr1, ... exprm) @ P
is compiled into a synchronous remote procedure call: the
function is invoked on processing element 'P'. Unlike most
RPC implementations, the call-frame (i.e., which function to
call and any scalar and pointer arguments) is copied to the
processing element but bulk data structures are not copied.
This reﬂects our design goal of giving the programmer con-
trol over data copying to let them tune memory use and the
impact on timing.
To illustrate these minimal extensions, consider mapping
the sequential program in Figure 2 onto the architecture
shown in Figure 3.
This program displays two diﬀerent
types of data dependency which must be handled when par-
allelizing the program.
There is forward dataﬂow within
a loop iteration carrying complex samples from the ADC
through timing correction, an FFT, demodulation and error
correction. There is also feedback loop from one iteration to
the next which continuously monitors changes in the timing
oﬀset between the transmitter and the receiver (caused by
slight diﬀerences in clock rates, Doppler eﬀects, etc.) which
is used to control timing correction in future iterations. For
simplicity, this example deals with ﬁne timing correction
(errors less than half the sample rate which are dealt with
by applying a rotation to the complex samples) but ignores
coarse timing correction (which would adjust the ADC in-
92
CHAPTER 5. SOC-C: EFFICIENT PROGRAMMING ABSTRACTIONS

GPP
ADC
DAC
Host
I/F
Timers
IRQ
Ctrl
SIMD PE
Turbo PE
Mem
Global Mem
Mem
DMA
DMA
DMA
SIMD PE
Mem
SIMD PE
Mem
SIMD PE
Mem
Mem
M0
M1
M3
M2
CM3
PE0
PE1
PE2
PE3
Turbo
TM
Global
Local
IN
OUT
DMA3
DMA
DMA2
DMA
DMA1
DMA
DMA0
Figure
3:
The
architecture
of
a
communication-
processing subsystem. This system consists of one RISC
processor and ﬁve processing elements (highlighted in
gray), ﬁve private memories and one shared memory.
teraction) and channel equalization (which would correct for
some frequencies being received more strongly than others).
In SoCs with heterogeneous processors, the principal form
of parallelism used is pipeline parallelism: each engine is
dedicated to performing a set of tasks and engines commu-
nicate with each other via FIFO channels. Figure 4 shows
how the program can be rewritten to express pipeline paral-
lelism using the minimal subset of SoC-C described in this
Section. As can be seen, the parallel version of the program
is signiﬁcantly longer than the sequential version and has
several more variables (both buﬀers and FIFOs). Looking
more closely, we identify the following problems:
FIFO channels create excessive synchronization In the
sequential version of the program, a feedback loop carries
the timing correction back for use in the next iteration. To
achieve exactly the same semantics, the parallel program
would need to use a FIFO channel but this would have forced
the ﬁrst three sections to run sequentially because section 1
could not start the next iteration until section 3 had sent
the new timing correction — a problem known as loss of
decoupling [1]. To avoid this, the programmers used their
knowledge of radio systems to conﬁrm that timing correc-
tions change slowly and so it would be acceptable to use
a slightly older timing correction if that leads to greater
parallelism. Since FIFO channels create too much synchro-
nization, they chose the other inter-thread communication
method of a shared variable accessed in a critical section.
Section 3 addresses this by supporting user deﬁned channels
and zero-copy optimization.
Structure of the program is signiﬁcantly changed. While
the sequential program was a single, short loop, the paral-
lel program contains four loops, the code is dominated by
communication and parallelism constructs and it takes more
eﬀort to determine the ﬂow of data through the program.
Equally seriously, this major restructuring was performed
to suit one particular architecture and achieve a reasonable
load balance given the current speed of each function. If the
architecture were to change or a function were optimized,
the program would have to be restructured accordingly — a
signiﬁcant and error-prone undertaking. Section 4 addresses
this using decoupling to automatically introduce pipeline
parallelism under programmer control.
Fragmentation of variables. Each individual variable in
the sequential program has been fragmented into many sep-
int timing_correction = 0;
parallel_sections{
section{
complex_t samples1[2048] @ {M0};
int
t1;
while (1) {
ADC_get(&adc,&samples1,2048);
critical(offset){
t1 = timing_correction;
}
AdjustTiming(t1,samples1) @ P0;
fifo_put(&f1,samples1);
}
}
section{
complex_t samples2[2048] @ {M0};
complex_t samples3[2048] @ {M1};
while (1) {
fifo_get(&f1,samples2);
memcpy(samples3,samples2,sizeof(samples2)) @ DMA;
FFT(samples3) @ P1;
fifo_put(&f2,samples3);
}
}
section{
complex_t samples4[2048] @ {M1};
complex_t samples5[2048] @ {M2};
bool
bits1[3024]
@ {M2};
int
t2 = 0;
while (1) {
fifo_get(&f2,samples4);
memcpy(samples5,samples4,sizeof(samples4)) @ DMA;
t2 += FindTimeOffset(samples5)@P2;
critical(offset){
timing_correction2 = t2;
}
Demodulate(bits1,samples5) @ P2;
fifo_put(&f3,bits1);
}
}
section{
bool
bits2[3024] @ {M2};
bool
bits3[3024] @ {M3};
int8_t
bytes[378]
@ {M3};
while (1) {
fifo_get(&f3,bits2);
memcpy(bits3,bits2,sizeof(bits2)) @ DMA;
ErrorCorrect(bytes,bits3) @ Viterbi;
}
}
}
Figure 4: A parallel version of the program in Figure 2.
arate variables in the parallel program. This fragmentation
comes from two distinct sources: replicating variables that
are communicated between threads and replicating variables
between memory spaces. Whilst the replication is necessary,
the burden on the programmer is signiﬁcant: they may use
the wrong version of a variable, they may fail to copy from
one version of a variable to the other, or they may perform
the copy but in the wrong direction. Sections 4 and 5 sepa-
rately address the two sources of fragmentation.
Performance issues In addition to the impact on the struc-
ture of the application, the choice of synchronous RPCs,
threads and FIFOs to express parallelism is convenient but
runs the risk of a high overhead from copying data and
swapping thread contexts.
Section 8 shows that existing
optimizations can be used to allow the use of high-level con-
structs without excessive overhead.
3.
USER DEFINED CHANNELS
In Section 2, we observed that FIFO channels introduced
too much synchronization and therefore used shared vari-
93

typedef struct { lock_t lock; int data; } atomic_int_t;
void atomic_int_init(atomic_int_t *a, int x)
{ lock_init(&a->lock); a->data = x; }
void atomic_int_put(atomic_int_t *a, int x)
__attribute(( PUT(a, x) IN(x) ))
{ lock(&a->lock); a->data = x; unlock(&a->lock); }
void atomic_int_get(atomic_int_t *a, int *x)
__attribute(( GET(a, x) OUT(x) ))
{ lock(&a->lock); *x = a->data; unlock(&a->lock); }
Figure 5:
Implementation of atomic channels showing
their dataﬂow annotations.
ables instead to achieve parallelism. The problem with us-
ing shared variables to communicate between threads is that
it is harder to determine the direction of dataﬂow through
shared variables, which makes it harder for programmers to
understand and makes dataﬂow analysis less precise. To ad-
dress this issue, SoC-C allows programmers to deﬁne new
channel types to express directional dataﬂow.
SoC-C provides the usual array of thread primitives (locks,
condition variables, etc.)
to allow programmers to create
their own channel operations. More importantly, SoC-C pro-
vides annotations to allow the programmer to specify that a
function performs directional communication. Figure 5 con-
tains a simple example: an "atomic channel" which allows
one thread to pass data to another thread atomically. The
most important aspect of this example is the annotations.
The PUT(a,x) attribute speciﬁes that the function argument
'a' is a channel used to communicate between threads and
that the function argument 'x' is the data transferred into
the channel. The PUT and GET attributes provide important
information for the decoupling transformation described in
Section 4 and the zero-copy transformation described in Sec-
tion 8.1. IN and OUT attributes indicate dataﬂow through
arguments in the usual way.
The PUT and GET attributes were originally added to
SoC-C to let us quickly prototype new types of channel
without the usual eﬀort of having to add new intrinsic func-
tions to tables in the compiler. We have since realized that
most inter-thread communication and communication be-
tween threads and stream-oriented devices like Analog-to-
Digital Convertors (ADCs) is directional and can be mod-
elled as channels using our annotations.
In addition to
atomic channels, some examples of channels we use are:
Channel interfaces to ADCs and DACs High rate ADCs
usually write data continuously into a circular buﬀer in mem-
ory.
In addition to the channel and buﬀer arguments, it
takes a size argument indicating how many samples are re-
quired.
void ADC_get(adc_t *adc, buffer_t *buf, unsigned sz);
Although it interacts with hardware, this function has the
same semantics as any other"get"function: if the data is not
yet available, the thread blocks until the data is available.
Timed channels provide time-indexed access to data. FIFO
channels and atomic channels are at opposite ends of the
spectrum on how puts and gets are matched: a FIFO chan-
nel matches each get with a unique put; while an atomic
channel matches gets with the most recent put. Timed chan-
nels provide an intermediate semantic: data is timestamped
and a get is matched with the put closest to the requested
time.
void ts_put(tschan_t *c, int timestamp, void* v);
void ts_get(tschan_t *c, int timestamp, void* v);
The ts_get operation returns the entry with the closest
timestamp to the one speciﬁed. All ts_put operations must
use strictly increasing times and all ts_get operations must
use strictly increasing times. This restriction allows entries
to be discarded when they can no longer be accessed. Timed
channels allow for more parallelism between threads since,
after the ﬁrst ts_put is performed, ts_get operations never
block because there is always an entry with a closest times-
tamp. The cost of this increased performance is less precise
synchronization between threads than with FIFO channels:
applications that use timed channels are unlikely to give de-
terministic results.
4.
DECOUPLING
In Section 2, we observed that manually introducing pipeline
parallelism requires a signiﬁcant restructuring of the pro-
gram. There are many papers on avoiding this cost by au-
tomating the transformation: Smith [10] applies the tech-
nique manually to Cray assembly code which they referred
to as "decoupling"; and Palacharla and Smith [9] use pro-
gram slicing to automatically decouple a program into two
threads communicating via FIFO channels: one containing
load-store operations, the other containing all other opera-
tions. Subhlok et al. [11] have proposed syntax extensions
for marking the start and end of pipeline stages within a
loop body. These tools allow the programmer to identify
what code should be in each section and then the compiler
inserts FIFO channel operations as required.
SoC-C's approach is similar in that it requires the pro-
grammer to indicate the boundaries between threads.
It
diﬀers in that the programmer indicates the boundaries by
inserting the communication between sections and the com-
piler determines which code must be in each section — the
exact opposite of previous work. In practice, the diﬀerence
in annotations is usually small: we insert similar annotations
at similar parts of the program. We believe our emphasis on
communication brings an important beneﬁt:
the program-
mer is able to select an appropriate channel type in order
to reduce synchronization between sections . These decisions
necessarily involve the programmer because using any chan-
nel other than a FIFO channel can change the meaning of
the program. A secondary beneﬁt is that our channel-based
decoupling transformation can be applied to code containing
complex control ﬂow and is not restricted to being applied
to loops — constraints applied by most prior work.
Figure 6 shows the program in Figure 4 rewritten to use
our pipeline construct. There are three major diﬀerences.
(1) It is possible to write the program as a single loop be-
cause decoupling can automatically split it into four parallel
copies of the loop. (2) It is not necessary to introduce as
many intermediate variables (samples2, samples4, bits2)
because our transformation performs range-splitting to split
any local variable with disjoint live ranges into multiple vari-
ables. (3) It is necessary to use an atomic channel to express
the direction of dataﬂow for the a_timing variable.
SoC-C uses the syntax
pipeline{
compound_statement
}
to indicate that the body of the compound statement is to be
transformed into an equivalent set of parallel sections which
94
CHAPTER 5. SOC-C: EFFICIENT PROGRAMMING ABSTRACTIONS

atomic_int_t a_timing;
atomic_int_init(&a_timing,0);
pipeline {
complex_t samples1[2048] @ {M0};
complex_t samples3[2048] @ {M1};
complex_t samples5[2048] @ {M2};
bool
bits1[3024]
@ {M2};
bool
bits3[3024]
@ {M3};
int8_t
bytes[378]
@ {M3};
int
t1;
int
t2 = 0;
while (1) {
ADC_get(&adc,&samples1,2048);
atomic int get(&a timing,&t1);
AdjustTiming(t1,samples1) @ P0;
ﬁfo put(&f1,samples1);
ﬁfo get(&f1,samples1);
memcpy(samples3,samples1,sizeof(samples1)) @ DMA;
FFT(samples3) @ P1;
ﬁfo put(&f2,samples3);
ﬁfo get(&f2,samples3);
memcpy(samples5,samples3,sizeof(samples3)) @ DMA;
t2 += FindTimeOffset(samples5)@P2;
atomic int put(&a timing,t2);
Demodulate(bits1,samples5) @ P2;
ﬁfo put(&f3,bits1);
ﬁfo get(&f3,bits1);
memcpy(bits3,bits1,sizeof(bits1)) @ DMA;
ErrorCorrect(bytes,bits3) @ Viterbi;
}
}
Figure 6: A version of the program in Figure 2 written
using the pipeline construct.
communicate (only) using the channel operations already
present in the program.
Since communication lies at the
boundaries between threads, the compiler uses a dataﬂow
analysis which "colors in" the code that lies between the
boundaries.
This analysis identiﬁes the set of operations
that are on the "producer" side of a channel and the set of
operations on the "consumer" side of a channel.
Repeat-
ing this for all channels and considering shared variables,
the compiler partitions the operations into sets of opera-
tions which must be in the same thread. The body of the
pipeline construct is then transformed into parallel sections
replicating control ﬂow and variables as required.
The decoupling algorithm must make two essential deci-
sions: "What variables and operations to replicate?" and
"What operations to place in the same thread?".
The task of decoupling is to split the region of code into
as many threads as possible, without introducing timing-
dependent behaviour, using channels to communicate be-
tween threads. Comparing Figure 4 with Figure 6 we ob-
serve that the generated threads do not strictly partition
the statements in the original code: some variables and op-
erations (principally those used for control) have been pri-
vatized (i.e., replicated in multiple threads) while others re-
main shared. The choice of what to privatize is an essential
part of the transformation: if too much code or data is priva-
tized, the transformed program can run more slowly and use
more memory than the original program. While these deci-
sions could be controlled using annotations on every variable
and statement, SoC-C applies some simple default rules that
give the programmer control without requiring excessive an-
notation. By default, scalar variables and variables declared
inside the pipeline annotation may be privatized. Opera-
tions other than function calls may be privatized unless they
have side-eﬀects or modify a non-duplicable variable.
The other essential decision that the transformation must
make is "What operations must be in the same thread as
each other?".
To avoid introducing timing-dependent be-
haviour, the compiler applies the following three rules:
1. To preserve data and control dependencies, any dependent
operations must be in the same thread as each other un-
less the dependency is from a 'put' operations to a 'get'
operation on the same channel. This special treatment of
dependencies on channel operations has the eﬀect of cut-
ting edges in the dataﬂow graph.
2. To avoid introducing race conditions, any operations which
write to a shareable, non-channel variable must be in the
same thread as all operations which read from or write to
that variable. Channels are excluded because all channel
operations are required to atomically modify the channel.
3. To avoid introducing unwanted non-determinism, all puts
to a given channel must be in one thread and all gets from
a given channel must be in one thread.
Our implementation of decoupling ﬁnds the unique, max-
imal solution in four stages: live range splitting of privati-
zable variables, dependency analysis, merging, and thread
production. To illustrate our method, we consider the fol-
lowing simple example.
1 pipeline{
2
for(int i=0; i<100; ++i) {
3
int x = foo();
4
if (i % 2 != 0) {
5
fifo_put(&f,x);
6
fifo_get(&f,&x);
7
bar(x);
8
}
9
}
10 }
The dependency analysis stage forms a large number of can-
didate threads by computing a backward data and control
slice [16] from each unprivatized operation ignoring data de-
pendencies on channel operations but including all other op-
erations in the slice. That is, we repeatedly apply rules (1-3)
to form candidate threads. In our running example, there
are four candidates: one each for foo(), fifo_put(&f,x),
fifo_get(&f,&x) and bar(x).
For example, the candidate for foo() is:
2
for(int i=0; i<100; ++i) {
3
int x = foo();
9
}
the candidate for fifo_put(&f,x) is:
2
for(int i=0; i<100; ++i) {
3
int x = foo();
4
if (i % 2 != 0) {
5
fifo_put(&f,x);
8
}
9
}
and the candidate for bar(x) is:
2
for(int i=0; i<100; ++i) {
3
int x;
4
if (i % 2 != 0) {
6
fifo_get(&f,&x);
7
bar(x);
8
}
9
}
The merging stage combines candidate threads by merging
threads that contain the same un-privatizable operation or
variable. For example, the candidate for foo() is merged
95

with the candidate for the operation fifo_put(&f,x) be-
cause they both contain the operation foo(). This results
in the candidate thread:
2
for(int i=0; i<100; ++i) {
3
int x = foo();
4
if (i % 2 != 0) {
5
fifo_put(&f,x);
8
}
9
}
This is identical to the candidate for fifo_put(&f,x) be-
cause the candidate already contained the x=foo() oper-
ation.
Similarily, the result of merging the candidate for
bar(x) with the candidate for the operation fifo_get(&f,&x)
is identical to the candidate for bar(x).
The thread production stage converts candidate threads
to threads by privatizing variables and combining the result
using parallel sections.
Syntactic sugar We have found that it is common for
pairs of put and get operations to be adjacent. In recog-
nition of this, we added a small piece of syntactic sugar:
"FIFO(x);". This is equivalent to a put followed by a get
on variable x and that also declares and initializes a ﬁfo
channel. This syntax is illustrated in Figure 7.
5.
COMPILER-SUPPORTED COHERENCY
In Section 2, we saw that distributed memory leads to
variable fragmentation: if functions running on diﬀerent pro-
cessors access the same variable, we must create a version
of the variable for each memory region. This is tedious and
error prone because it is hard to understand the original de-
sign intent. To address this problem, we extend the data
placement notation to allow the programmer to express the
fact that the additional variables are just versions of the
same variable. This preserves the structure of the original
design and allows the compiler to detect errors using a single
compile-time coherence protocol.
We allow the programmer to assign a variable to multiple
memory regions. For example, the declaration
bool bits[2048] @ {M2,M3};
introduces two copies of the variable bits: one in memory M2
(written bits@M2) and one in memory M3 (written bits@M3).
Semantically, the diﬀerent versions of a variable behave
like copies in a coherent cache: an assignment to one ver-
sion of bits (logically) invalidates the contents of the other
version. An invalid version of a variable can be made valid
by synchronizing it with a valid version of the same variable.
The statement
SYNC(bits,M3,M2) @ DMA;
makes bits@M2 valid if bits@M2 was already valid and is an
error if bits@M0 was invalid. A SYNC statement is compiled
into a copy operation which, in this example, is to be per-
formed on engine DMA. Figure 7 illustrates how using variable
coherency annotations simpliﬁes the task of keeping track of
all the diﬀerent variables in Figure 6.
Adding support for multiple coherent versions of a vari-
able required the following compiler changes. Various triv-
ial changes to support the new syntax; to transform uses
of variables to use the appropriate version; and to trans-
form SYNC constructs into memcpy operations. Checking for
coherence errors is performed using a ﬂow-sensitive, context-
insensitive, ﬁeld-insensitive forward dataﬂow analysis:
atomic_int_t a_timing;
atomic_int_init(&a_timing,0);
pipeline {
complex_t samples[2048] @ {M0,M1,M2};
bool
bits[3024]
@ {M2,M3};
int8_t
bytes[378]
@ {M3};
int
t1;
int
t2 = 0;
while (1) {
ADC_get(&adc,&samples@M0,2048);
atomic_int_get(&a_timing,&t1);
AdjustTiming(t1,samples@M0) @ P0;
FIFO(samples@M0);
SYNC(samples,M1,M0) @ DMA;
FFT(samples@M1) @ P1;
FIFO(samples@M1);
SYNC(samples,M2,M1) @ DMA;
t2 += FindTimeOffset(samples@M2)@P2;
atomic_int_put(&a_timing,t2);
Demodulate(bits@M2,samples@M2) @ P2;
FIFO(bits@M2);
SYNC(bits,M3,M2) @ DMA;
ErrorCorrect(bytes@M3,bits@M3) @ Viterbi;
}
}
Figure 7:
The eﬀect of rewriting Figure 6 using
variable coherency annotations. Changes are high-
lighted in bold.
1. Each version of each variable can be valid or invalid;
2. A kill makes all versions of a variable invalid;
3. A def to a version of a variable makes that version valid
and all others invalid;
4. A SYNC statement copies validity from one version of a
variable to another;
5. A use checks that the version used is valid; and
6. When ﬂow merges, a version is valid only if it is valid in
all incoming edges.
To illustrate the kind of errors these checks detect, suppose
the programmer had accidentally reversed the ﬁrst two ar-
guments in the ﬁrst call to memcpy in Figure 6. Since the
programmer's intent is not clear, it would be hard for a
compiler to detect this error. In contrast, reversing the M0
and M1 arguments in the ﬁrst SYNC statement in Figure 7
is detected as a coherence error by our compiler: the FIFO
on the previous line deﬁnes samples@M0 which invalidates
samples@M1 but the SYNC reads from samples@M1.
This coherency mechanism meets our primary goal of sup-
porting safe, statically checked use of distributed memory
between processors but within a single thread. Inter-thread
coherency checking would require dynamic checking of the
ownership of a variable and synchronization — which we
think is better expressed using channels.
A consequence
of not supporting inter-thread coherence is that we per-
form coherence checking and transformation before decou-
pling to eliminate coherence annotations before creating new
threads.
6.
PLACEMENT INFERENCE
Supporting multiple coherent versions of a variable helps
communicate the intent of the programmer and, hence, de-
tect errors but it requires that every single use of a variable
is annotated. To reduce this annotation burden, we replace
coherence checking with placement inference which exploits
the observation that the annotations contain a high degree
of redundancy:
96
CHAPTER 5. SOC-C: EFFICIENT PROGRAMMING ABSTRACTIONS

atomic_int_t a_timing;
atomic_int_init(&a_timing,0);
pipeline {
complex_t samples[2048];
bool
bits[3024];
int8_t
bytes[378];
int
t1;
int
t2 = 0;
while (1) {
ADC_get(&adc,&samples,2048);
atomic_int_get(&a_timing,&t1);
AdjustTiming(t1,samples) @ P0;
FIFO(samples);
SYNC(samples) @ DMA;
FFT(samples) @ P1;
FIFO(samples);
SYNC(samples) @ DMA;
t2 += FindTimeOffset(samples) @ P2;
atomic_int_put(&a_timing,t2);
Demodulate(bits,samples) @ P2;
FIFO(bits);
SYNC(bits) @ DMA;
ErrorCorrect(bytes,bits) @ Viterbi;
}
}
Figure 8:
An OFDM radio receiver mapped onto
a complex architecture using the full set of SoC-C
annotations.
• If P can only access one memory M, and the program con-
tains an RPC "foo(x)@P," then variable x must be placed
in memory M and that x must have a version in memory M.
• If there is only one valid version x@M of a variable at the
site of a SYNC(x) statement, then the only legal source of
the SYNC is x@M.
• If x@M is the only version of a variable whose use is reach-
able from a SYNC(x) statement, then the only sensible tar-
get of the SYNC is x@M.
These three observations follow a common pattern:
if
there is only one valid choice, assume that choice is true.
Our coherence inference algorithm is similar to ﬂow-sensitive
type inference: it uses annotations and the memory topol-
ogy to add constraints to the system (e.g., an RPC 'f(x)@P'
provides the constraint that 'x' must be in a memory accessi-
ble by 'P' while a reference to 'x@M0' provides the constraint
that 'x@M0' is valid. Having gathered all the constraints, we
use forward-chaining inference to add additional constraints.
When no more constraints can be inferred, we choose an
open question and test all possible answers to see if they
break the constraints. If precisely one possible solution does
not break the constraints, then we assume that it is the
correct solution and repeat the inference process. This is
repeated until no more open questions can be resolved in
this way. This process results in a unique solution if there
is one because it makes an assumption only if it can prove
that all other alternatives are invalid.
In practice we ﬁnd that SoCs which have multiple memory
regions also have suﬃciently restricted memory topologies
that the compiler can infer most annotations. For example,
Figure 8 shows the eﬀect of applying our annotations to the
code in Figure 7: all data placement annotations can be
inferred in this example.
7.
EVALUATING SOC-C ANNOTATIONS
Having completed our presentation of SoC-C, we consider
how eﬀective the annotations are at expressing SoC pro-
grams. Comparing Figure 8 with the sequential code, we
see that to map and parallelize we added: 8 code placement
annotations; 0 data placement annotations; 3 SYNC state-
ments; 3 FIFO statements to pass data between threads;
and 2 put/get operations on atomic operations.
While annotations and additional statements have been
inserted, the structure of the code is unchanged; to port the
parallelized code to a new platform, the worst case is that
one would delete all the annotations and start again.
Most importantly, we claim that there is little redundancy
in the code: most of the changes are independent of the other
changes. This suggests that SoC-C allows programmers to
express design decisions rather than focussing on the me-
chanics of making the program correct and consistent.
8.
KEY OPTIMIZATIONS
In Section 2 we identiﬁed two potential performance is-
sues in our choice of abstraction: the cost of copying buﬀers
into and out of channels; and the cost of using synchronous
RPC and threads. This Section describes the (previously
known) optimizations we apply to make the cost of these
abstractions acceptable.
8.1
Optimizing channels
The semantics of channels is that put operations transfer
data into the channel and get operations transfer data out.
This simple semantics ensures that each thread has exclusive
access to the data but a literal implementation would require
a lot of unnecessary data copying. Network stacks, ﬁlesys-
tems and embedded systems often provide a "zero copy" in-
terface which pass pointers instead of copying data.
For
example the Task Transaction Interface [14, section 4.1.5]
splits "put" operations into two operations. "acquireRoom"
allocates the next empty buﬀer in a channel; the producer
should then write data into the buﬀer and call"releaseData"
to make the data available to the consumer. Similarily, "get"
operations are split into "acquireData" and "releaseRoom".
Supporting this style of channel interface required three
changes. First, for all channels which hold large buﬀers, we
rewrote the channel implementation to support a zero-copy
interface. For example, the zero copy operations correspond-
ing to fifo_put are:
void fifo_acquireRoom(fifo_t *f, void* *room);
void fifo_releaseData(fifo_t *f, void* data);
Secondly, we added attributes to the "put" and "get" func-
tions identifying that these functions could be zero-copy op-
timized and naming the two associated functions. The aug-
mented set of attributes on the fifo_put function is:
void fifo_put(fifo_t *fifo, void *data)
__attribute(( PUT(fifo, data) IN(data)
ZEROCOPY(fifo1_acquireRoom,
fifo1_releaseData) ));
Finally, we modiﬁed the compiler to analyze the live range
of buﬀers passed to functions with ZEROCOPY attributes and
insert calls to the two functions at the starts of the live range
and at the ends of the live range.
The optimization cannot be used if the live range does not
end at a put (or start with a get), for example, if a variable is
put into multiple channels or is used after the put operation.
For bulk data types, the cost of not optimizing away the copy
may be signiﬁcant so, when zero-copying cannot be used,
our compiler reports a warning prompting the programmer
to change their code.
97

section{
complex_t *p_samples2;
complex_t *p_samples3;
while (1) {
fifo_acquireData(&f1,&p_samples2);
fifo_acquireRoom(&f2,&p_samples3);
memcpy(p_samples3,p_samples2,...) @ DMA;
fifo_releaseRoom(&f1,p_samples2);
FFT(p_samples3) @ P1;
fifo_releaseData(&f2,p_samples3);
}
}
Figure 9: The eﬀect of zero-copy optimization.
Figure 9 shows the eﬀect of applying zero-copy optimiza-
tion to the second code section in Figure 4. Using this trans-
formation typically reduces the channel operations to just a
small amount of book-keeping. For example, the put opera-
tion on an atomic channel is split into an operation to wait
for the buﬀer to become available followed later by an opera-
tion to release the buﬀer to other users of the channel. These
operations are exactly the same as the lock/unlock opera-
tions on a mutex that would normally have been used: our
optimizations result in the same low-level, eﬃcient imple-
mentation that embedded programmers normally use with-
out the semantic complexity of using shared variables di-
rectly.
8.2
Optimizing thread implementation
SoC-C provides synchronous RPCs and uses threads to
express sequencing of operations and parallelism. In embed-
ded systems, it is more usual to provide asynchronous (aka
non-blocking) RPCs and use an event-driven programming
style to express sequencing of operations and parallelism.
SoC-C's choice is simpler to use but a conventional thread
implementation would incur a large space overhead to store
thread contexts and a large time overhead performing con-
text switches when an engine sends an interrupt to signal
that it has completed a function call.
To achieve the simplicity of threads with the eﬃciency of
event-driven programming, we use an old trick: we trans-
form threads into event-driven programs [6]. Our compiler
transforms each thread into a state machine where states
represent points where the program may block on an event
and edges are labelled with event handlers which execute
code from the thread and update the current state. For ex-
ample, Figure 10 shows the state machine corresponding to
the code in Figure 9.
A typical execution sequence is as follows. The proces-
sor spends most of its time in a low-power state waiting
for an interrupt with all threads either blocked on a condi-
tion variable waiting for a processing element to complete
execution or blocked on a channel. On receiving an inter-
rupt signalling completion of a task, the processor invokes
an interrupt hander which acknowledges the interrupt and
invokes an event handler for the thread currently waiting for
that task to complete. This handler typically starts a new
task on a processing element and blocks waiting for the task
to complete or waiting for the processing element to become
available. If the event handler released a lock or put data
into a channel before it blocked, the handler may trigger
other event handlers: the completion of a single process-
ing element can cause a cascade of event handlers as results
propagate to other threads and buﬀers are freed. When all
event handlers in this cascade have executed, all threads are
true 
Æ 
fifo_acquireData(&f1,&p_samples2); 
data_available(&f1) 
Æ     
fifo_acquireRoom(&f2,&p_samples3)
 
task_completed(DMA) 
Æ 
fifo_releaseRoom(&f1,&p_samples2);
FFT(p_samples3) @ P1; 
data_available(&f2) 
Æ      
memcpy(p_samples3,p_samples2,...) @
task_completed(P1) 
Æ 
fifo_releaseData(&f2,&p_samples3); 
 
Figure 10: The state machine for Figure 9.
once more blocked on a condition variable or a channel and
the control processor returns from the interrupt handler and
reenters a low-power state.
8.3
Dataﬂow Analysis and Phase Ordering
Our compiler relies on the ability to perform a suﬃciently
accurate dataﬂow analysis. Since we wish to keep the pro-
grammer "in the loop", we limited ourselves to a simple
dataﬂow analysis that was easy to understand.
Accord-
ingly, our analysis is ﬂow sensitive, ﬁeld-insensitive, context-
insensitive. Our pointer analysis is just suﬃcient to analyze
programs that use pointers to pass arguments by reference;
programmers are encouraged to create abstract data types
to hide any other use.
The dataﬂow analysis used for decoupling and other trans-
formations requires programmer annotations on function ar-
guments. We rely on programmer annotation to determine
whether a pointer argument is an 'in' argument (indicated
by C's const qualiﬁer), an 'out' argument (indicated by an
attribute) or an 'in-out' argument (the default). Similarily,
if a function accesses a global variable, the function proto-
type must be annotated to indicate whether it is an 'in', 'out'
or 'in-out' variable. If a function modiﬁes just one ﬁeld in a
struct or array, the argument is recorded as an 'in-out' argu-
ment indicating that the function does not "kill" the entire
argument. In practice, we ﬁnd that most of this informa-
tion is already documented informally or can be obtained as
a side-eﬀect of function compilation.
Our compiler performs the transformations described in
this paper in the following order: dataﬂow analysis, place-
ment inference/checking, splitting variables with multiple
placements into separate variables, zero-copy optimization,
decoupling and transforming threads into state machines.
Performing dataﬂow analysis early is important because it
allows us to analyze the code before additional pointers are
introduced and to give accurate programmer feedback. Co-
herency checking is performed before decoupling because co-
herency checking can only be applied within a thread. Zero-
copy optimization can be performed either before or after
decoupling; to allow it to be performed before decoupling,
the 'releaseData' and 'acquireData' operations need to be
annotated with 'PUT' and 'GET' attributes.
Our SoC-C compiler is written as a source to source com-
piler implemented using Necula et al.'s wonderful CIL [7] C
processing framework, 5800 lines of O'Caml code and around
5000 lines of runtime support code including device drivers.
98
CHAPTER 5. SOC-C: EFFICIENT PROGRAMMING ABSTRACTIONS

activity
cycles
enter irq handler
10
clearing interrupts
20
start data engine
39
lock overhead
34-38
FIFO transfer overhead
54-55
Figure 11: Performance of SoC-C Implementation
9.
PERFORMANCE EVALUATION
This Section evaluates the performance of SoC-C using
two criteria: we establish the eﬃciency of our implementa-
tion using microbenchmarks; and we measure how perfor-
mance of a high performance "software deﬁned radio" appli-
cation scales with the number of processors.
All measurements were based on a multiprocessor sys-
tem being developed by ARM Ltd. to implement the phys-
ical layer processing of 3.9G mobile phones.
This plat-
form centres around a conﬁgurable number of moderate-
frequency, highly parallel C-programmable data processing
engines implemented using ARM's OptimoDE design tech-
nology. These processors exploit both data-parallelism us-
ing a very wide SIMD (512-bit) datapath and and exploit
instruction-level parallelism using VLIW instruction decod-
ing. These OptimoDE engines have a 512-bit data bus to
memory and are supported by a DMA engine capable of 512-
bit wide transfers. We evaluated using a platform conﬁgured
to use between 1 and 4 of these data engines as shown in Fig-
ure 3. SoC-C code runs on a Cortex-M3 RISC processor with
a 32-bit tightly coupled memory. The primary task of the
RISC processor is to control data engines, DMA, etc. and to
interact with processors executing the higher layers of the
network protocol stack. All measurements were made us-
ing cycle-accurate models of the data engines, DMA engine,
RISC processor and memory system and cycle-approximate
models of the peripherals.
9.1
Performance of the runtime system
One of the most important metrics is how long a data
engine spends idle between tasks.
The control processor
must perform the following steps: 1) Complete the current
instruction and enter the interrupt handler; 2) Acknowl-
edge the interrupt to the device; 3) Execute the appropriate
event handler including constructing a call frame and start-
ing the data engine. Using the simulator we monitored the
start/stop signals from data engines, the interrupt signals
and the program counter on the control processor and ob-
tained very precise, repeatable measurements to be made
(Figure 11). The total time that a data engine is idle be-
tween tasks is 69 cycles.
In practice, it is usually necessary to use locks to prevent
two threads from using the same engine at once. Locking
increases the idle time by 50% to 103-107 cycles. When two
threads communicate via a FIFO queue, the time between
the completion of a task on one thread and the start of a
task in the other thread is 157-162 cycles.
In comparision, our experience is that commercial RTOSs
require more than 300 cycles to enter an interrupt handler
and trigger a thread context switch. The extra 150-200 cy-
cles may appear negligible until one considers that in that
time, our SIMD data engine could have performed another
4500-6000 ﬁxed point multiply operations.
cores
ideal time
actual time
utilization
speedup
1
29286
31101
94%
1.00
2
15013
16865
89%
1.84
4
7876
9077
87%
3.43
Figure 12: Scaling of DVB application.
9.2
Scalability
This Section evaluates how well performance scales as the
number of processors is varied using the inner receiver of a
Digital Video Broadcast (DVB) physical layer as a bench-
mark. This has a similar structure and dataﬂow to our run-
ning example but, in addition, it performs: coarse-timing
correction to maintain synchronization over long time peri-
ods, demultiplexing of data, control bits and pilot channels;
channel equalization to correct for fading of individual fre-
quency channels; de-interleaving of the data to reduce sen-
sitivity to bursts of noise. Odd and even symbols require
slightly diﬀerent processing requiring the compiler to decou-
ple code containing if-statements and the two paths have
slightly diﬀerent execution times. Our receiver consists of
around 9000 lines of C code split into 17 DSP functions
which execute on the SIMD data engines. The total num-
ber of cycles of the functions and three DMA transfers is
29286 cycles of which 740 cycles are DMA transfer. Task
granularity varies considerably: there are 2 tasks of almost
7000 cycles, 3 tasks of more than 3000 cycles, 1 task of 1000
cycles and the remainder are 500 cycles or less.
We used SoC-C to combine these functions into a single-
threaded application and created two pipelined versions of
the program for platforms with two and with four SIMD
data engines by inserting FIFOs and atomic channels and
changing the placement annotations.
We measured the maximum sustainable rate at which a
stream of 2K point DVB symbols can be processed mea-
sured in cycles per symbol and calculated the best possible
time for a system with one DMA engine and N cores given
our code placement decisions and function runtimes and ig-
noring data dependencies which would prevent perfect par-
allelization. Ignoring data dependencies makes this number
a little conservative (too low). We calculated utilization as
the ratio between the ideal rate and the actual rate and
calculated speedup as the ratio of actual rate against the
actual rate of the 1-core variant. The results are summa-
rized in Figure 12. The results for a single core demonstrate
the eﬀectiveness of our implementation strategy: the over-
head of using SoC-C is just 1800 cycles (6%) which matches
our expectation from the microbenchmarks. On two cores,
the application speeds up by a factor of 1.84 compared with
the single core version. We were unable to achieve perfect
speedup because the coarse granularity of tasks made it im-
possible to perfectly balance the load. On four cores, the
application speeds up by a factor of 3.43 compared with the
single core version despite coarse task granularity.
10.
DISCUSSION AND RELATED WORK
SoC-C's major inﬂuences are stream programming languages
such as StreamIt [5] which emphasize pipeline parallelism
and have a clear separation of the communication language
from the kernel language.
We maintain the separation of
communication/control layer (SoC-C) from computation (code
called by RPCs) but we chose a sequential communication
language instead of a dataﬂow language because we found
99

it hard to express global control (i.e., conditionals that span
multiple pipeline stages) over pipeline stages that execute
asynchronously with respect to each other.
Using decou-
pling to introduce parallelism, gives the ease of expression of
global control that imperative languages provide combined
with the pipeline parallelism that stream languages provide.
Decoupling has been applied many times; we cite a rep-
resentative sample. Smith [10] applies the technique manu-
ally to Cray assembly code to separate load-store operations
from other operations to program Access-Execute proces-
sors; [9] automated this transformation; [4, 8, 2, 3] decouple
programs automatically based on load-balancing heuristics;
[11, 13] rely on programmer annotations to mark the begin-
ning and end of pipeline stages. All these papers rely on
partitioning of the operations into pipeline stages and then
inserting FIFO channels. Our channel-based decoupling al-
gorithm does the opposite: it relies on the programmer in-
serting channels and partitions the operations accordingly.
The diﬀerence is small but signiﬁcant: making the channels
ﬁrst-class concepts, instead of mere implementation details,
lets the programmer use diﬀerent channel types to explicitly
relax synchronization between pipeline stages to avoid loss
of decoupling. We are not aware of any work that uses non-
FIFO channels when automatically decoupling a sequential
program though StreamIt's "teleport messaging" [12] pro-
vides a related feature for dataﬂow languages.
Although SoC-C borrows syntax from OpenMP, the two
languages target very diﬀerent systems and parallelism pat-
terns: OpenMP targets SMP systems and supports data
parallelism using annotations on for-loops; SoC-C targets
AMP systems and, hence, supports pipeline parallelism.
EXOCHI [15] also tackles the problem of programming
heterogeneous multicore systems but is complementary since
they focus on coping with multiple instruction sets/toolchains,
providing shared virtual memory and dynamically allocat-
ing tasks to accelerators whereas we focus on distributed
memory, static allocation of tasks and decoupling.
There has been a large body of work on software dis-
tributed shared memory and on reducing cache-coherency
traﬃc between threads using compiler techniques. SoC-C's
approach is to express inter-thread communication (which
requires dynamic checks) using channels and restrict coher-
ence checking for intra-thread, inter-processor communica-
tion (which our compiler checks statically).
SoC-C handles data copying diﬀerently from many sys-
tems: RPCs normally copy bulk data structures; FIFO chan-
nels normally copy data both on a put and a get; private
memories are often used to store local copies of variables
whose master copy is in shared memory.
Instead, SoC-C
gives explicit control over data copying and SoC-C provides
support to make this less burdensome and error-prone.
11.
CONCLUSIONS
Mapping an application onto low-power, high-perform-
ance SoCs is a challenging problem due to the architectural
complexity needed to achieve high energy eﬃciency. A com-
mon approach to the problem of complex hardware is to use
software libraries to hide the complexity from the user. To
achieve signiﬁcantly higher energy eﬃciency we take a diﬀer-
ent approach: SoC-C provides the programmer with explicit
control over how an application is mapped onto an archi-
tecture without requiring signiﬁcant manual restructuring.
Any language requires careful implementation and choice of
optimizations to minimize overhead: our compiler is able to
speedup a coarse-grained, real-world application by a factor
of 3.4 on a four-core platform achieving utilization of 87%.
12.
REFERENCES
[1] P. L. Bird, A. Rawsthorne, and N. P. Topham. The
eﬀectiveness of decoupling. In International
Conference on Supercomputing, pages 47-56, 1993.
[2] M. Bridges et al. Revisiting the sequential
programming model for multi-core. In MICRO 2007:
Proc. of Symposium on Microarchitecture, 2007.
[3] J. Dai, B. Huang, L. Li, and L. Harrison.
Automatically partitioning packet processing
applications for pipelined architectures. In PLDI 2005,
pages 237-248, 2005.
[4] W. Du, R. Ferreira, and G. Agrawal. Compiler
support for exploiting coarse-grained pipelined
parallelism. In Proc. of Conf. on High Performance
Networking and Computing (SC2003), page 8, 2003.
[5] M. I. Gordon et al. A stream compiler for
communication-exposed architectures. In Proc.
Architectural Support for Programming Languages and
Operating Systems, pages 291-303, 2002.
[6] H. Lauer and R. Needham. On the duality of
operating system structures. In Proc. Symposium on
Operating Systems, 1978.
[7] G. C. Necula et al. CIL: Intermediate language and
tools for analysis and transformation of C programs.
In CC '02: Proc. Int. Conf. on Compiler
Construction, pages 213-228. Springer-Verlag, 2002.
[8] G. Ottoni, R. Rangan, A. Stoler, and D. I. August.
Automatic thread extraction with decoupled software
pipelining. In MICRO '05: Proc. Int. Symposium on
Microarchitecture, Nov 2005.
[9] S. Palacharla and J. E. Smith. Decoupling integer
execution in superscalar processors. In MICRO 28:
Proc. of International Symposium on
Microarchitecture, pages 285-290, 1995.
[10] J. E. Smith. Decoupled access/execute computer
architectures. ACM Trans. Comput. Syst.,
2(4):289-308, 1984.
[11] J. Subhlok et al. Exploiting task and data parallelism
on a multicomputer. In Proc. of Symp. on Principles
and Practice of Parallel Programming, 1993.
[12] W. Thies et al. Teleport messaging for distributed
stream programs. In PPoPP '05: Proc. of Symposium
on Principles and Practice of Parallel Programming,
pages 224-235. ACM Press, 2005.
[13] W. Thies et al. A practical approach to exploiting
coarse-grained pipeline parallelism in C programs. In
MICRO 2007, 2007.
[14] P. van der Wolf et al. Design and programming of
embedded multiprocessors: An interface-centric
approach. In CODES+ISSS'04: Hardware/Software
Codesign and System Synthesis, 2004.
[15] P. H. Wang et al. EXOCHI: architecture and
programming environment for a heterogeneous
multi-core multithreaded system. In Proc. PLDI, 2007.
[16] M. Weiser. Program slicing. In ICSE '81: Proc. of
International Conference on Software Engineering,
pages 439-449, 1981.
100
CHAPTER 5. SOC-C: EFFICIENT PROGRAMMING ABSTRACTIONS

Chapter 6
Reducing inter-task latency in a
multiprocessor system (Patent I)
Alastair David Reid. Reducing inter-task latency in a multiprocessor system, January 22 2013.
US Patent 8,359,588.
101

102
CHAPTER 6. REDUCING INTER-TASK LATENCY

103

104
CHAPTER 6. REDUCING INTER-TASK LATENCY

105

106
CHAPTER 6. REDUCING INTER-TASK LATENCY

107

108
CHAPTER 6. REDUCING INTER-TASK LATENCY

109

110
CHAPTER 6. REDUCING INTER-TASK LATENCY

111

112
CHAPTER 6. REDUCING INTER-TASK LATENCY

113

114
CHAPTER 6. REDUCING INTER-TASK LATENCY

115

116
CHAPTER 6. REDUCING INTER-TASK LATENCY

117

118
CHAPTER 6. REDUCING INTER-TASK LATENCY

119

120
CHAPTER 6. REDUCING INTER-TASK LATENCY

121

122
CHAPTER 6. REDUCING INTER-TASK LATENCY

123

124
CHAPTER 6. REDUCING INTER-TASK LATENCY

125

126
CHAPTER 6. REDUCING INTER-TASK LATENCY

127

128
CHAPTER 6. REDUCING INTER-TASK LATENCY

129

130
CHAPTER 6. REDUCING INTER-TASK LATENCY

Bibliography
[1] Jade Alglave, Luc Maranget, and Michael Tautschnig. Herding cats: Modelling, simu-
lation, testing, and data mining for weak memory. ACM Transactions on Programming
Languages and Systems, 36(2):7:1-7:74, 2014. doi:10.1145/2627752. [Cited on
page 14.]
[2] A. L. Ananda, B. H. Tay, and E. K. Koh. A survey of asynchronous remote procedure
calls. SIGOPS Operating Systems Review, 26(2):92-109, April 1992. doi:10.1145/
142111.142121. [Cited on page 18.]
[3] ARM Ltd.
ARM Architecture Reference Manual (ARMv8, for ARMv8-A architecture
proﬁle) (DDI0487).
ARM Ltd, 2013.
URL: https://developer.arm.com/
docs/ddi0487/a/arm-architecture-reference-manual-armv8-
for-armv8-a-architecture-profile. [Cited on pages 2 and 14.]
[4] ARM Ltd.
ARMv8-M Architecture Reference Manual (DDI0553).
ARM Ltd, 2016.
URL: https://developer.arm.com/docs/ddi0553/latest/armv8-m-
architecture-reference-manual. [Cited on pages 2 and 12.]
[5] ARM Ltd.
A-proﬁle architectures / exploration tools,
April 2017.
URL:
https://developer.arm.com/products/architecture/a-profile/
exploration-tools. [Cited on pages vii, 2, 5, 11, and 13.]
[6] ARM Ltd. ARM Quarterly results ﬁnancial report (First quarter, 2018). ARM Ltd, 2018.
URL:
https://www.arm.com/-/media/global/company/investors/
PDFs/Arm_SB_Q1_2018_Roadshow_Slides_Final.pdf. [Cited on page xi.]
[7] Alasdair Armstrong, Thomas Bauereiss, Brian Campbell, Shaked Flur, Kathryn E. Gray,
Prashanth Mundkur, Robert Norton, Christopher Pulte, Alastair Reid, Peter Sewell, Ian
Stark, and Mark Wassell. Detailed models of instruction set architectures: From pseu-
docode to formal semantics. In Proceedings of the 25th Automated Reasoning Workshop,
April 2018. URL: http://www.cl.cam.ac.uk/events/arw2018/. [Cited on
page 13.]
131

132
BIBLIOGRAPHY
[8] Alasdair Armstrong, Thomas Bauereiss, Brian Campbell, Alastair Reid, Kathryn E. Gray,
Robert M. Norton, Prashanth Mundkur, Mark Wassell, Jon French, Christopher Pulte,
Shaked Flur, Ian Stark, Neel Krishnaswami, and Peter Sewell. ISA semantics for ARMv8-
A, RISC-V, and CHERI-MIPS.
In Proceedings of the 46th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, POPL '19, New York, NY, USA,
2019. ACM. doi:10.1145/3290384. [Cited on pages vii, 5, 7, 8, and 13.]
[9] Sorav Bansal and Alex Aiken. Automatic generation of peephole superoptimizers. In
Proceedings of the 12th International Conference on Architectural Support for Program-
ming Languages and Operating Systems, ASPLOS XII, pages 394-403, New York, NY,
USA, 2006. ACM. doi:10.1145/1168857.1168906. [Cited on page 6.]
[10] Sorav Bansal and Alex Aiken. Binary translation using peephole superoptimizers. In
Proceedings of the 8th USENIX Conference on Operating Systems Design and Im-
plementation, OSDI'08, pages 177-192, Berkeley, CA, USA, 2008. USENIX Asso-
ciation.
URL: https://www.usenix.org/legacy/event/osdi08/tech/
full_papers/bansal/bansal.pdf. [Cited on page 6.]
[11] Mario R. Barbacci.
Instruction set processor speciﬁcations (ISPS): The notation and
its applications. IEEE Transactions on Computers, C-30(1):24-40, Jan 1981. doi:
10.1109/TC.1981.6312154. [Cited on pages 6 and 7.]
[12] Earl T. Barr, Mark Harman, Phil McMinn, Muzammil Shahbaz, and Shin Yoo. The oracle
problem in software testing: A survey. IEEE Transactions on Software Engineering,
41(5):507-525, May 2015. doi:10.1109/TSE.2014.2372785. [Cited on page 7.]
[13] Clark Barrett, Christopher L. Conway, Morgan Deters, Liana Hadarean, Dejan Jovanovi´c,
Tim King, Andrew Reynolds, and Cesare Tinelli. CVC4. In Ganesh Gopalakrishnan
and Shaz Qadeer, editors, Proceedings of the 23rd International Conference on Com-
puter Aided Veriﬁcation (CAV '11), volume 6806 of Lecture Notes in Computer Science,
pages 171-177. Springer, July 2011. Snowbird, Utah. doi:10.1007/978-3-642-
22110-1_14. [Cited on page 6.]
[14] C. Gordon Bell and Allen Newell.
The PMS and ISP descriptive systems for com-
puter structures.
In Proceedings of the May 5-7, 1970, Spring Joint Computer Con-
ference, AFIPS '70 (Spring), pages 351-374, New York, NY, USA, 1970. ACM. doi:
10.1145/1476936.1476993. [Cited on page 6.]
[15] Brian N. Bershad, Matthew J. Zekauskas, and Wayne A Sawdon. The Midway distributed
shared memory system. In Digest of Papers, Compcon Spring, 1993. doi:10.1109/
CMPCON.1993.289730. [Cited on page 18.]

133
[16] William R. Bevier, Warren A. Hunt, J. Strother Moore, and William D. Young. An ap-
proach to systems veriﬁcation.
Journal of Automated Reasoning, 5(4):411-428, Dec
1989. doi:10.1007/BF00243131. [Cited on page 7.]
[17] Sven Beyer, Christian Jacobi, Daniel Kröning, Dirk Leinenbach, and Wolfgang J. Paul.
Putting it all together - formal veriﬁcation of the VAMP.
International Journal on
Software Tools for Technology Transfer, 8(4):411-430, Aug 2006.
doi:10.1007/
s10009-006-0204-6. [Cited on pages 6 and 7.]
[18] Peter L. Bird, Alasdair Rawsthorne, and Nigel P. Topham.
The effectiveness of de-
coupling. In International Conference on Supercomputing, pages 47-56, 1993. doi:
10.1145/165939.165952. [Cited on page 19.]
[19] Andrew D. Birrell and Bruce Jay Nelson. Implementing remote procedure calls. ACM
Transactions on Computing Systems (TOCS), 2(1):39-59, 1984.
doi:10.1145/
2080.357392. [Cited on page 18.]
[20] OpenMP Architecture Review Board. OpenMP application program interface, version
3.0, 2014. URL: https://www.openmp.org/. [Cited on page 23.]
[21] Richard Boulton, Andrew Gordon, Mike Gordon, John Harrison, John Herbert, and
John Van Tassel. Experience with embedding hardware description languages in HOL.
In Proceedings of the IFIP TC10/WG 10.2 International Conference on Theorem Provers
in Circuit Design: Theory, Practice and Experience, volume A-10 of IFIP Transac-
tions A: Computer Science and Technology, pages 129-156, Nijmegen, The Netherlands,
1993. North-Holland. URL: https://www.cl.cam.ac.uk/~jrh13/papers/
EmbeddingPaper.html. [Cited on page 6.]
[22] Matthew Bridges, Neil Vachharajani, Yun Zhang, Thomas Jablin, and David August.
Revisiting the sequential programming model for multi-core. In 40th Annual IEEE/ACM
International Symposium on Microarchitecture (MICRO 2007), pages 69-84, Dec 2007.
doi:10.1109/MICRO.2007.20. [Cited on pages 18 and 19.]
[23] Cadence Inc. JasperGold formal veriﬁcation platform. [Cited on page 6.]
[24] Roderic Geoffrey Galton Cattell. Automatic derivation of code generators from machine
descriptions. ACM Transactions on Programming Languages and Systems (TOPLAS),
2(2):173-190, April 1980. doi:10.1145/357094.357097. [Cited on page 6.]
[25] Cristina Cifuentes and Shane Sendall. Specifying the semantics of machine instructions.
In Program Comprehension, 1998. IWPC '98. Proceedings., 6th International Work-
shop on, pages 126-133, Jun 1998.
doi:10.1109/WPC.1998.693332.
[Cited
on page 7.]

134
BIBLIOGRAPHY
[26] David Cock, Qian Ge, Toby Murray, and Gernot Heiser. The last mile: An empirical
study of timing channels on seL4. In Proceedings of the 2014 ACM SIGSAC Conference
on Computer and Communications Security, CCS '14, pages 570-581, New York, NY,
USA, 2014. ACM. doi:10.1145/2660267.2660294. [Cited on page 15.]
[27] Thierry Coquand and Gérard Huet.
Constructions: A higher order proof system for
mechanizing mathematics, pages 151-184. Springer, Berlin, Heidelberg, 1985. doi:
10.1007/3-540-15983-5_13. [Cited on page 6.]
[28] Digital Equipment Corporation. PDP-11/45 processor handbook. Digital Equipment
Corporation, 1973. [Cited on page 6.]
[29] Frank Dabek, Nickolai Zeldovich, Frans Kaashoek, David Mazières, and Robert Morris.
Event-driven programming for robust software. In Proceedings of the 10th Workshop on
ACM SIGOPS European Workshop, EW 10, pages 186-189, New York, NY, USA, 2002.
ACM. doi:10.1145/1133373.1133410. [Cited on page 18.]
[30] Jinquan Dai, Bo Huang, Long Li, and Luddy Harrison. Automatically partitioning packet
processing applications for pipelined architectures. In Proceedings of the 2005 ACM
SIGPLAN Conference on Programming Language Design and Implementation, PLDI
'05, pages 237-248, New York, NY, USA, 2005. ACM. doi:10.1145/1065010.
1065039. [Cited on pages 18 and 19.]
[31] Mads Dam, Roberto Guanciale, and Hamed Nemati.
Machine code veriﬁcation of a
tiny ARM hypervisor. In Proceedings of the 3rd International Workshop on Trustworthy
Embedded Devices, TrustED '13, pages 3-12, New York, NY, USA, 2013. ACM. doi:
10.1145/2517300.2517302. [Cited on pages 6 and 9.]
[32] Sandeep Dasgupta and Vikram Adve.
A complete formal semantics of x86-64 user-
level instruction set architecture. In Proceedings of the 2019 ACM SIGPLAN Confer-
ence on Programming Language Design and Implementation. To appear, 2019. [Cited on
page 10.]
[33] Leonardo De Moura and Nikolaj Bjørner. Z3: An efﬁcient SMT solver. In Proceed-
ings of the Theory and Practice of Software, 14th International Conference on Tools and
Algorithms for the Construction and Analysis of Systems, TACAS'08/ETAPS'08, pages
337-340, Berlin, Heidelberg, 2008. Springer-Verlag. doi:10.1007/978-3-540-
78800-3_24. [Cited on page 6.]
[34] Ulan Degenbaev.
Formal speciﬁcation of the x86 instruction set architecture.
PhD
thesis, Universität des Saarlandes, Postfach 151141, 66041 Saarbrücken, 2012. URL:
http://scidok.sulb.uni-saarland.de/volltexte/2012/4707. [Cited
on page 8.]

135
[35] Wei Du, Renato Ferreira, and Gagan Agrawal. Compiler support for exploiting coarse-
grained pipelined parallelism.
In Proceedings of Conference on High Performance
Networking and Computing (SC2003), page 8, 2003.
doi:10.1145/1048935.
1050159. [Cited on pages 18 and 19.]
[36] Adam Dunkels, Oliver Schmidt, Thiemo Voigt, and Muneeb Ali. Protothreads: Simpli-
fying event-driven programming of memory-constrained embedded systems. In Proceed-
ings of the 4th International Conference on Embedded Networked Sensor Systems, Sen-
Sys '06, pages 29-42, New York, NY, USA, 2006. ACM. doi:10.1145/1182807.
1182811. [Cited on page 19.]
[37] A. D. Falkoff, K. E. Iverson, and E. H. Sussenguth.
A formal description of SYS-
TEM/360. IBM Systems Journal, 3(2):198-261, June 1964. doi:10.1147/sj.32.
0198. [Cited on pages 6 and 7.]
[38] Andreas Fauth, Johan Van Praet, and Markus Freericks. Describing instruction set proces-
sors using nML. In Proceedings European Design and Test Conference, 1995. ED&TC
1995, pages 503-507. IEEE, 1995. doi:10.1109/EDTC.1995.470354. [Cited on
page 7.]
[39] Joseph A. Fisher. Very long instruction word architectures and the ELI-512. In Proceed-
ings of the 10th Annual International Symposium on Computer Architecture, ISCA '83,
pages 140-150, New York, NY, USA, 1983. ACM. doi:10.1145/800046.801649.
[Cited on page 16.]
[40] Shaked Flur, Kathryn E. Gray, Christopher Pulte, Susmit Sarkar, Ali Sezgin, Luc
Maranget, Will Deacon, and Peter Sewell. Modelling the ARMv8 architecture, opera-
tionally: concurrency and ISA. In Proceedings Principles of Programming Languages,
POPL 2016, pages 608-621, 2016. doi:10.1145/2837614.2837615. [Cited on
pages 7 and 14.]
[41] Pedro Fonseca, Kaiyuan Zhang, Xi Wang, and Arvind Krishnamurthy. An empirical study
on the correctness of formally veriﬁed distributed systems. In Proceedings of the Twelfth
European Conference on Computer Systems, EuroSys '17, pages 328-343, New York,
NY, USA, 2017. ACM. doi:10.1145/3064176.3064183. [Cited on page 7.]
[42] Anthony Fox. Formal veriﬁcation of the ARM6 micro-architecture. Technical Report
UCAM-CL-TR-548, University of Cambridge, Computer Laboratory, November 2002.
URL: http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-548.pdf.
[Cited on pages 6, 7, and 9.]
[43] Anthony Fox.
Formal speciﬁcation and veriﬁcation of ARM6.
In David Basin and
Burkhart Wolff, editors, Theorem Proving in Higher Order Logics (TPHOLs '03), volume

136
BIBLIOGRAPHY
2758 of LNCS, pages 25-40. Springer, 2003. doi:10.1007/10930755_2. [Cited
on page 9.]
[44] Anthony Fox.
Directions in ISA speciﬁcation.
In Lennart Beringer and Amy Felty,
editors, Interactive Theorem Proving, pages 338-344, Berlin, Heidelberg, 2012. Springer
Berlin Heidelberg. [Cited on page 9.]
[45] Anthony Fox. Improved tool support for machine-code decompilation in HOL4. In Pro-
ceedings 6th International Conference Interactive Theorem Proving ITP 2015, volume
9236 of LNCS, pages 187-202. Springer, August 2015. doi:10.1007/978-3-319-
22102-1. [Cited on pages 7, 8, and 9.]
[46] Anthony C. J. Fox and Magnus O. Myreen. A trustworthy monadic formalization of the
ARMv7 instruction set architecture. In Proceedings Interactive Theorem Proving ITP
2010, volume 6172 of LNCS, pages 243-258. Springer, 2010. doi:10.1007/978-
3-642-14052-5_18. [Cited on pages 3, 6, 7, and 9.]
[47] Anthony C.J. Fox.
A HOL speciﬁcation of the ARM instruction set architecture.
Technical Report UCAM-CL-TR-545, University of Cambridge, Computer Laboratory,
June 2001.
URL: https://www.cl.cam.ac.uk/techreports/UCAM-CL-
TR-545.pdf. [Cited on page 9.]
[48] Christopher W. Fraser. A knowledge-based code generator generator. ACM SIGART
Bulletin, 64:126-129, August 1977. doi:10.1145/872736.806941. [Cited on
page 6.]
[49] David Gay, Philip Levis, Robert von Behren, Matt Welsh, Eric Brewer, and David
Culler. The nesC language: A holistic approach to networked embedded systems. In
Proceedings of the ACM SIGPLAN 2003 Conference on Programming Language De-
sign and Implementation, PLDI '03, pages 1-11, New York, NY, USA, 2003. ACM.
doi:10.1145/781131.781133. [Cited on page 18.]
[50] Qian Ge, Yuval Yarom, David Cock, and Gernot Heiser. A survey of microarchitec-
tural timing attacks and countermeasures on contemporary hardware. Journal of Cryp-
tographic Engineering, pages 1-27, 2016. doi:10.1007/s13389-016-0141-6.
[Cited on page 14.]
[51] Patrice Godefroid, Michael Y. Levin, and David Molnar.
SAGE: Whitebox fuzzing
for security testing. ACM Queue, 10(1):20:20-20:27, January 2012. doi:10.1145/
2090147.2094081. [Cited on page 6.]

137
[52] Patrice Godefroid and Ankur Taly. Automated synthesis of symbolic instruction encod-
ings from I/O samples. In Proceedings of the 33rd ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation, PLDI '12, pages 441-452, New York,
NY, USA, 2012. ACM. doi:10.1145/2254064.2254116. [Cited on page 10.]
[53] Shilpi Goel.
Formal Veriﬁcation of Application and System Programs Based on a
Validated x86 ISA Model.
PhD thesis, University of Texas at Austin, December
2016. URL: http://www.cs.utexas.edu/users/shigoel/x86isaInfo/
Shilpi-Goel-Dissertation.pdf. [Cited on page 6.]
[54] Shilpi Goel, Warren A. Hunt, and Matt Kaufmann. Abstract stobjs and their application
to ISA modeling. In Proceedings of the ACL2 Workshop 2013, EPTCS 114, pages 54-69,
2013. doi:10.4204/EPTCS.114.5. [Cited on page 6.]
[55] Shilpi Goel, Warren A. Hunt, and Matt Kaufmann. Engineering a Formal, Executable
x86 ISA Simulator for Software Veriﬁcation, pages 173-209. Springer International Pub-
lishing, Cham, 2017. doi:10.1007/978-3-319-48628-4_8. [Cited on page 6.]
[56] Shilpi Goel, Warren A. Hunt, Matt Kaufmann, and Soumava Ghosh. Simulation and
formal veriﬁcation of x86 machine-code programs that make system calls. In Formal
Methods in Computer-Aided Design, FMCAD, pages 91-98, 2014. doi:10.1109/
FMCAD.2014.6987600. [Cited on pages 7, 8, and 9.]
[57] M. J. C. Gordon and T. F. Melham, editors. Introduction to HOL: A Theorem Proving
Environment for Higher Order Logic. Cambridge University Press, New York, NY, USA,
1993. [Cited on page 6.]
[58] Michael I. Gordon, William Thies, Michal Karczmarek, Jasper Lin, Ali S. Meli, An-
drew A. Lamb, Chris Leger, Jeremy Wong, Henry Hoffmann, David Maze, and Saman
Amarasinghe. A stream compiler for communication-exposed architectures. In Proceed-
ings Architectural Support for Programming Languages and Operating Systems, pages
291-303, 2002. doi:10.1145/605397.605428. [Cited on page 19.]
[59] Kathryn E. Gray, Gabriel Kerneis, Dominic P. Mulligan, Christopher Pulte, Susmit
Sarkar, and Peter Sewell. An integrated concurrency and core-ISA architectural envelope
deﬁnition, and test oracle, for IBM POWER multiprocessors. In MICRO 2015: Proceed-
ings of the 48th International Symposium on Microarchitecture (MICRO 2015), pages
635-646, December 2015. doi:10.1145/2830772.2830775. [Cited on pages 8
and 13.]
[60] Khronos Group.
C++ single-source heterogeneous programming for OpenCL, 2014.
URL: https://www.khronos.org/sycl/. [Cited on page 23.]

138
BIBLIOGRAPHY
[61] Samuel Z. Guyer and Calvin Lin. An annotation language for optimizing software li-
braries. In Proceedings of the 2nd Conference on Domain-Speciﬁc Languages - Volume
2, DSL'99, Berkeley, CA, USA, 1999. USENIX Association. doi:10.1007/3-540-
45574-4_15. [Cited on page 18.]
[62] Stefan Heule, Eric Schkufza, Rahul Sharma, and Alex Aiken. Stratiﬁed synthesis: Auto-
matically learning the x86-64 instruction set. In Proceedings of the 37th ACM SIGPLAN
Conference on Programming Language Design and Implementation, PLDI '16, pages
237-250, New York, NY, USA, 2016. ACM. doi:10.1145/2908080.2908121.
[Cited on pages 9 and 10.]
[63] Bo-Yuan Huang, Hongce Zhang, Pramod Subramanyan, Yakir Vizel, Aarti Gupta, and
Sharad Malik. Instruction-level abstraction (ILA): A uniform speciﬁcation for system-on-
chip (SoC) veriﬁcation. ACM Transactions on Design Automation of Electronic Systems,
2019. [Cited on page 10.]
[64] Warren A. Hunt, Jr. Microprocessor design veriﬁcation. Journal of Automated Reasoning,
5(4):429-460, November 1989. [Cited on pages 6 and 7.]
[65] K. L. Johnson, M. F. Kaashoek, and D. A. Wallach. CRL: High-performance all-software
distributed shared memory. SIGOPS Operating Systems Review, 29(5):213-226, Decem-
ber 1995. doi:10.1145/224057.224073. [Cited on page 18.]
[66] Rajeev Joshi, Greg Nelson, and Keith Randall. Denali: A goal-directed superoptimizer.
SIGPLAN Not., 37(5):304-314, May 2002. doi:10.1145/543552.512566. [Cited
on page 6.]
[67] M. Kaufmann and J. S. Moore. An industrial strength theorem prover for a logic based on
Common Lisp. IEEE Transactions on Software Engineering, 23(4):203-213, Apr 1997.
doi:10.1109/32.588534. [Cited on page 6.]
[68] Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock, Philip
Derrin, Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski, Michael Norrish, Thomas
Sewell, Harvey Tuch, and Simon Winwood. seL4: Formal veriﬁcation of an OS ker-
nel. In Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Prin-
ciples, SOSP '09, pages 207-220, New York, NY, USA, 2009. ACM. doi:10.1145/
1629575.1629596. [Cited on page 6.]
[69] Paul Kocher, Daniel Genkin, Daniel Gruss, Werner Haas, Mike Hamburg, Moritz Lipp,
Stefan Mangard, Thomas Prescher, Michael Schwarz, and Yuval Yarom. Spectre attacks:
Exploiting speculative execution. ArXiv e-prints, January 2018. arXiv:1801.01203.
[Cited on page 14.]

139
[70] Ramana Kumar, Magnus O. Myreen, Michael Norrish, and Scott Owens. CakeML: A
veriﬁed implementation of ML. In Principles of Programming Languages (POPL), pages
179-192. ACM, 2014. doi:10.1145/2535838.2535841. [Cited on pages 6, 7,
and 9.]
[71] Hugh C. Lauer and Roger M. Needham. On the duality of operating system structures.
SIGOPS Operating System Review, 13(2):3-19, April 1979. doi:10.1145/850657.
850658. [Cited on page 18.]
[72] Xavier Leroy.
Formal veriﬁcation of a realistic compiler.
Communications of the
ACM, 52(7):107-115, 2009. doi:10.1145/1538788.1538814. [Cited on pages 3
and 6.]
[73] Kai Li and Paul Hudak. Memory coherence in shared virtual memory systems. ACM
Transactions on Computer Systems (TOCS), 7(4):321-359, November 1989. doi:10.
1145/75104.75105. [Cited on page 18.]
[74] Yuan Lin, Robert Mullenix, Mark Woh, Scott Mahlke, Trevor Mudge, Alastair Reid,
and Krisztián Flautner. SPEX: A programming language for software deﬁned radio. In
Software Deﬁned Radio Technical Conference and Product Exposition, 2006. [Cited on
page xiii.]
[75] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas, Stefan
Mangard, Paul Kocher, Daniel Genkin, Yuval Yarom, and Mike Hamburg. Meltdown.
ArXiv e-prints, January 2018. arXiv:1801.01207. [Cited on page 14.]
[76] Derek Lockhart, Berkin Ilbeyi, and Christopher Batten. Pydgin: generating fast instruc-
tion set simulators from simple architecture descriptions with meta-tracing JIT compilers.
In 2015 IEEE International Symposium on Performance Analysis of Systems and Software
(ISPASS), pages 256-267, March 2015. doi:10.1109/ISPASS.2015.7095811.
[Cited on page 14.]
[77] Andreas Lööw, Ramana Kumar, Yong Kiam Tan, Magnus O. Myreen, Michael Norrish,
Oskar Abrahamsson, and Anthony Fox. Veriﬁed compilation on a veriﬁed processor. In
Proceedings of the 2019 ACM SIGPLAN Conference on Programming Language Design
and Implementation. To appear, 2019. [Cited on page 7.]
[78] Nuno P. Lopes, David Menendez, Santosh Nagarakatte, and John Regehr. Provably cor-
rect peephole optimizations with Alive. In Proceedings of the 36th ACM SIGPLAN Con-
ference on Programming Language Design and Implementation, PLDI '15, pages 22-32,
New York, NY, USA, 2015. ACM. doi:10.1145/2737924.2737965. [Cited on
page 6.]

140
BIBLIOGRAPHY
[79] Lorenzo Martignoni, Stephen McCamant, Pongsin Poosankam, Dawn Song, and Petros
Maniatis. Path-exploration lifting: Hi-ﬁtests for lo-ﬁemulators. In Proceedings of the
Seventeenth International Conference on Architectural Support for Programming Lan-
guages and Operating Systems, ASPLOS XVII, pages 337-348, New York, NY, USA,
2012. ACM. doi:10.1145/2150976.2151012. [Cited on page 6.]
[80] Stefan Maus, Michał Moskal, and Wolfram Schulte. Vx86: x86 Assembler Simulated in C
Powered by Automated Theorem Proving, pages 284-298. Springer, Berlin, Heidelberg,
2008. doi:10.1007/978-3-540-79980-1_22. [Cited on page 6.]
[81] Ross Mcilroy, Jaroslav Sevcik, Tobias Tebbi, Ben L. Titzer, and Toon Verwaest. Spectre
is here to stay: An analysis of side-channels and speculative execution, 2019. arXiv:
1902.05178. [Cited on page 15.]
[82] Robin Milner. A theory of type polymorphism in programming. Journal of Computer and
System Sciences, 17(3):348 - 375, 1978. doi:10.1016/0022-0000(78)90014-
4. [Cited on page 19.]
[83] Prabhat Mishra and Nikil Dutt. Processor Description Languages. Morgan Kaufmann
Publishers Inc., San Francisco, CA, USA, 2008. [Cited on page 7.]
[84] Greg Morrisett, Gang Tan, Joseph Tassarotti, Jean-Baptiste Tristan, and Edward Gan.
RockSalt: Better, faster, stronger SFI for the x86.
In Proceedings of the 33rd ACM
SIGPLAN Conference on Programming Language Design and Implementation, PLDI
'12, pages 395-404, New York, NY, USA, 2012. ACM. doi:10.1145/2254064.
2254111. [Cited on page 9.]
[85] Alan Mycroft.
Type-based decompilation (or program reconstruction via type recon-
struction).
In Proceedings of the 8th European Symposium on Programming Lan-
guages and Systems, ESOP '99, pages 208-223, London, UK, 1999. Springer-Verlag.
doi:10.1007/3-540-49099-X_14. [Cited on page 6.]
[86] Magnus O. Myreen and Michael J. C. Gordon. Veriﬁed LISP implementations on ARM,
x86 and PowerPC. In Stefan Berghofer, Tobias Nipkow, Christian Urban, and Makar-
ius Wenzel, editors, Theorem Proving in Higher Order Logics (TPHOLs), pages 359-
374. Springer, 2009. doi:10.1007/978-3-642-03359-9_25. [Cited on pages 6
and 9.]
[87] George C. Necula. Translation validation for an optimizing compiler. In Proceedings
of the ACM SIGPLAN 2000 Conference on Programming Language Design and Imple-
mentation, PLDI '00, pages 83-94. ACM, 2000. doi:10.1145/349299.349314.
[Cited on page 6.]

141
[88] Tobias Nipkow, Markus Wenzel, and Lawrence C. Paulson.
Isabelle/HOL: A Proof
Assistant for Higher-order Logic.
Springer-Verlag, Berlin, Heidelberg, 2002.
doi:
10.1007/3-540-45949-9. [Cited on page 6.]
[89] Matt Noonan, Alexey Loginov, and David Cok. Polymorphic type inference for machine
code. SIGPLAN Not., 51(6):27-41, June 2016. doi:10.1145/2980983.2908119.
[Cited on page 6.]
[90] Guilherme Ottoni, Ram Rangan, Adam Stoler, and David I. August. Automatic thread
extraction with decoupled software pipelining. In MICRO '05: Proceedings International
Symposium on Microarchitecture, Nov 2005.
doi:10.1109/MICRO.2005.13.
[Cited on pages 18 and 19.]
[91] John Ousterhout.
Why threads are a bad idea (for most purposes) (invited talk).
In
USENIX 1996 Technical Conference, June 1996. [Cited on page 18.]
[92] Subbarao Palacharla and James E. Smith. Decoupling integer execution in superscalar
processors.
In MICRO 28: Proceedings of International Symposium on Microarchi-
tecture, pages 285-290, 1995. doi:10.1109/MICRO.1995.476836. [Cited on
page 18.]
[93] Simon Peyton Jones, Andrew Tolmach, and Tony Hoare.
Playing by the rules:
rewriting as a practical optimisation technique in GHC.
In Proceedings of the 2001
Haskell Workshop, September 2001. URL: https://www.microsoft.com/en-
us/research/publication/playing-by-the-rules-rewriting-as-
a-practical-optimisation-technique-in-ghc/. [Cited on page 18.]
[94] A. Pnueli, M. Siegel, and E. Singerman. Translation validation. In Bernhard Steffen,
editor, Tools and Algorithms for the Construction and Analysis of Systems, pages 151-
166. Springer, 1998. doi:10.1007/BFb0054170. [Cited on page 6.]
[95] John Regehr and Usit Duongsaa. Deriving abstract transfer functions for analyzing em-
bedded software. In Proceedings of the 2006 ACM SIGPLAN/SIGBED Conference on
Language, Compilers, and Tool Support for Embedded Systems, LCTES '06, pages 34-
43, New York, NY, USA, 2006. ACM. doi:10.1145/1134650.1134657. [Cited
on page 6.]
[96] John Regehr and Alastair Reid. HOIST: a system for automatically deriving static an-
alyzers for embedded systems. In Shubu Mukherjee and Kathryn S. McKinley, editors,
Proceedings of the 11th International Conference on Architectural Support for Program-
ming Languages and Operating Systems, ASPLOS 2004, Boston, MA, USA, October 7-13,
2004, pages 133-143. ACM, 2004. doi:10.1145/1024393.1024410. [Cited on
page 6.]

142
BIBLIOGRAPHY
[97] Alastair Reid. A precise semantics for ultraloose speciﬁcations. Master's thesis, Glasgow
School of Computing Science, 1993. [Cited on page 10.]
[98] Alastair Reid. Trustworthy speciﬁcations of ARM v8-A and v8-M system level archi-
tecture. In Proceedings of Formal Methods in Computer-Aided Design, (FMCAD 2016),
Mountain View, CA, USA, pages 161-168, October 2016.
doi:10.1109/FMCAD.
2016.7886675. [Cited on pages xii, 7, 11, 12, and 27.]
[99] Alastair Reid.
MRA-tools: tools to process ARM's Machine Readable Architecture
(software package), 2017. URL: https://github.com/alastairreid/mra_
tools. [Cited on page 2.]
[100] Alastair Reid. Who guards the guards? Formal validation of the ARM v8-M architecture
speciﬁcation.
In Proceedings of the ACM on Programming Languages, volume 1 of
OOPSLA 2017, New York, NY, USA, October 2017. ACM. doi:10.1145/3133912.
[Cited on pages xii, 12, and 27.]
[101] Alastair Reid, Rick Chen, Anastasios Deligiannis, David Gilday, David Hoyes, Will
Keen, Ashan Pathirane, Erin Shepherd, Peter Vrabel, and Ali Zaidi. End-to-end veriﬁca-
tion of ARM processors with ISA-Formal. In S. Chaudhuri and A. Farzan, editors, Pro-
ceedings of the 2016 International Conference on Computer Aided Veriﬁcation (CAV'16),
volume 9780 of LNCS, pages 42-58. Springer Verlag, July 2016. doi:10.1007/978-
3-319-41540-6_3. [Cited on pages xii, 6, 7, 11, 13, and 27.]
[102] Alastair D. Reid, Krisztián Flautner, Edmund Grimley-Evans, and Yuan Lin. SoC-C:
efﬁcient programming abstractions for heterogeneous multicore systems on chip.
In
Erik R. Altman, editor, Proceedings of the 2008 International Conference on Compil-
ers, Architecture, and Synthesis for Embedded Systems, CASES 2008, Atlanta, GA, USA,
October 19-24, 2008, pages 95-104. ACM, October 2008. doi:10.1145/1450095.
1450112. [Cited on pages xiii and 87.]
[103] Alastair David Reid. Reducing inter-task latency in a multiprocessor system, January 22
2013. US Patent 8,359,588. [Cited on pages xiii, 19, and 87.]
[104] University of Cambridge Rigorous Engineering of Mainstream Systems project (REMS).
Sail ARMv8-A ISA model (from ARM ASL), January 2019.
URL: https://
github.com/rems-project/sail-arm. [Cited on pages vii, 5, and 13.]
[105] Ian Roessle, Freek Verbeek, and Binoy Ravindran. Formally veriﬁed big step semantics
out of x86-64 binaries. In Proceedings of the 8th ACM SIGPLAN International Confer-
ence on Certiﬁed Programs and Proofs, CPP 2019, pages 181-195, New York, NY, USA,
2019. ACM. doi:10.1145/3293880.3294102. [Cited on page 9.]

143
[106] Hanan Samet. Automatically Proving the Correctness of Translations Involving Opti-
mized Code. PhD thesis, Stanford University, Stanford, CA, USA, 1975. AAI7525601.
[Cited on page 6.]
[107] Hanan Samet. A machine description facility for compiler testing. IEEE Transactions
on Software Engineering, SE-3(5):343-351, Sept 1977. doi:10.1109/TSE.1977.
231159. [Cited on page 6.]
[108] Susmit Sarkar, Peter Sewell, Jade Alglave, Luc Maranget, and Derek Williams. Under-
standing POWER multiprocessors. In Proceedings of the 32nd ACM SIGPLAN Confer-
ence on Programming Language Design and Implementation, PLDI 2011, San Jose, CA,
USA, June 4-8, 2011, pages 175-186, 2011. doi:10.1145/1993498.1993520.
[Cited on page 14.]
[109] Sabine Schmaltz and Andrey Shadrin. Integrated semantics of intermediate-language C
and macro-assembler for pervasive formal veriﬁcation of operating systems and hyper-
visors from VerisoftXT. In Rajeev Joshi, Peter Müller, and Andreas Podelski, editors,
Veriﬁed Software: Theories, Tools, Experiments, pages 18-33, Berlin, Heidelberg, 2012.
Springer Berlin Heidelberg. [Cited on page 7.]
[110] Thomas Arthur Leck Sewell, Magnus O. Myreen, and Gerwin Klein. Translation valida-
tion for a veriﬁed OS kernel. In ACM SIGPLAN Conference on Programming Language
Design and Implementation, PLDI '13, Seattle, WA, USA, June 16-19, 2013, pages 471-
482, 2013. doi:10.1145/2462156.2462183. [Cited on pages 6 and 9.]
[111] Xiaomu Shi.
Certiﬁcation of an Instruction Set Simulator.
PhD thesis, Université
de Grenoble, July 2013. URL: https://tel.archives-ouvertes.fr/tel-
00937524. [Cited on page 7.]
[112] James E. Smith. Decoupled access/execute computer architectures. ACM Transactions
on Computer Systems, 2(4):289-308, 1984. doi:10.1145/357401.357403. [Cited
on pages xiii and 18.]
[113] Nigel Stephens, Stuart Biles, Matthias Boettcher, Jacob Eapen, Mbou Eyole, Giacomo
Gabrielli, Matt Horsnell, Grigorios Magklis, Alejandro Martinez, Nathanael Premillieu,
Alastair Reid, Alejandro Rico, and Paul Walker. The ARM Scalable Vector Extension.
In IEEE Micro, volume 37, March 2017. doi:10.1109/MM.2017.35. [Cited on
page 12.]
[114] Jaspal Subhlok, James M. Stichnoth, David R. O'Hallaron, and Thomas Gross. Exploit-
ing task and data parallelism on a multicomputer. In Proceedings of the Fourth ACM
SIGPLAN Symposium on Principles and Practice of Parallel Programming, PPOPP '93,

144
BIBLIOGRAPHY
pages 13-22, New York, NY, USA, 1993. ACM. doi:10.1145/155332.155334.
[Cited on pages 18 and 19.]
[115] Simon Tatham. Coroutines in C, 2000. URL: https://www.chiark.greenend.
org.uk/~sgtatham/coroutines.html. [Cited on page 19.]
[116] William Thies, Vikram Chandrasekhar, and Saman Amarasinghe. A practical approach
to exploiting coarse-grained pipeline parallelism in C programs.
In Proceedings of
the 40th Annual IEEE/ACM International Symposium on Microarchitecture, MICRO
40, pages 356-369, Washington, DC, USA, 2007. IEEE Computer Society.
doi:
10.1109/MICRO.2007.7. [Cited on pages 18 and 19.]
[117] Pieter van der Wolf et al. Design and programming of embedded multiprocessors: An
interface-centric approach. In CODES+ISSS'04: Hardware/Software Codesign and Sys-
tem Synthesis, 2004. doi:10.1109/CODES+ISSS.2004.17. [Cited on page 18.]
[118] Todd L. Veldhuizen and Dennis Gannon. Active libraries: Rethinking the roles of compil-
ers and libraries. In Proceedings of the SIAM Workshop on Object Oriented Methods for
Inter-operable Scientiﬁc and Engineering Computing (OO'98. SIAM Press, 1998. URL:
http://arxiv.org/abs/math.NA/9810022. [Cited on page 18.]
[119] Rob von Behren, Jeremy Condit, and Eric Brewer. Why events are a bad idea (for high-
concurrency servers). In Proceedings of the 9th Conference on Hot Topics in Operating
Systems - Volume 9, HOTOS'03, page 4, Berkeley, CA, USA, 2003. USENIX Associa-
tion. [Cited on page 18.]
[120] Mark Woh, Yuan Lin, Sangwon Seo, Scott A. Mahlke, Trevor N. Mudge, Chaitali
Chakrabarti, Richard Bruce, Danny Kershaw, Alastair Reid, Mladen Wilder, and
Krisztián Flautner. From SODA to scotch: The evolution of a wireless baseband proces-
sor. In 41st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-
41 2008), November 8-12, 2008, Lake Como, Italy, pages 152-163. IEEE Computer Soci-
ety, 2008. doi:10.1109/MICRO.2008.4771787. [Cited on pages xiii, 2, and 16.]
[121] Clifford Wolf. SymbiYosys. URL: https://symbiyosys.readthedocs.io/.
[Cited on page 6.]
[122] Clifford Wolf.
End-to-end formal ISA veriﬁcation of RISC-V processors with riscv-
formal. In 7th RISC-V Workshop Proceedings, November 2017. URL: http://www.
clifford.at/papers/2017/riscv-formal/. [Cited on page 13.]
[123] Hongce Zhang, Caroline Trippel, Yatin Manerkar, Aarti Gupta, Margaret Martonosi, and
Sharad Malik. Integrating memory consistency models with instruction-level abstraction

145
for heterogeneous system-on-chip veriﬁcation. In Formal Methods in Computer-Aided
Design, FMCAD, 2018. [Cited on page 10.]
[124] V. Zivojnovic, S. Pees, and H. Meyr. LISA-machine description language and generic
machine model for HW/SW co-design. In VLSI Signal Processing, IX, pages 127-136,
Oct 1996. doi:10.1109/VLSISP.1996.558311. [Cited on page 7.]

