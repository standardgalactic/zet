Adding
Records
to
Hask
ell
John
P
eterson
and
Alastair
Reid
Departmen
t
of
Computer
Science,
Y
ale
Univ
ersit
y
,
P
.O.
Bo
x
0,
New
Ha
v
en,
CT
00,
USA.
Electronic
mail:
fpeterson-john,reid-alastai
rg@cs.
yal
e.ed
u
Octob
er
,
		
Abstract
The
Hask
ell
programming
language
has
a
v
ery
simple
y
et
elegan
t
view
of
data
struc-
tures.
Unfortunately
,
this
minimalist
approac
h
to
data
structures,
in
particular
record-
lik
e
structures,
presen
ts
serious
soft
w
are
engineering
problems.
W
e
ha
v
e
implemen
ted
an
extension
to
standard
Hask
ell
whic
h
pro
vides
record-lik
e
structures
in
addition
to
ordinary
algebraic
data
t
yp
es.
Our
extension
pro
vides
named
elds
in
data
structures,
default
eld
v
alues,
eld
up
date
functions,
detection
of
uninitialized
slots
and
m
ultiple
inheritance.
Our
ma
jor
design
goal
w
as
to
supply
as
m
uc
h
functionalit
y
as
p
ossible
without
c
hanging
an
y
of
the
basic
comp
onen
ts
of
the
Hask
ell
language
(in
particular,
w
e
a
v
oided
further
complication
of
the
t
yp
e
system).
The
purp
ose
of
this
pap
er
is
not
to
adv
o
cate
this
sp
ecic
extension
to
Hask
ell,
but
to
examine
the
basic
engineering
issues
asso
ciated
with
records;
describ
e
our
exp
eriences
with
the
implemen
tation
and
use
of
one
particular
prop
osal;
and
consider
alternativ
e
approac
hes
(some
of
whic
h
ha
v
e
b
een
used
in
other
languages).

In
tro
duction
The
Hask
ell
language
[]
includes
only
the
most
basic
supp
ort
for
a
fundamen
tal
program-
ming
language
feature:
the
record
t
yp
e.
In
the
most
general
sense
of
the
term,
a
record
simply
groups
a
heterogeneous
collection
of
ob
jects
in
to
a
single
v
alue.
There
are
man
y
dieren
t
manifestations
of
record-lik
e
features
in
programming
languages,
including
tuples,
structures,
and
ob
jects.
While
the
algebraic
data
t
yp
es
found
in
Hask
ell
ha
v
e
the
necessary
functionalit
y
to
build
record
data
structures,
Hask
ell
lac
ks
man
y
desirable
features
found
in
other
languages
for
dealing
with
complex
data
ob
jects.
This
pap
er
describ
es
our
implemen
tation
of
record
t
yp
es
in
the
Y
ale
Hask
ell
system.
The
purp
ose
of
this
exp
erimen
t
is
not
to
adv
o
cate
an
y
sp
ecic
implemen
tation
of
records
in
Hask
ell,
but
to
fully
explore
one
p
ossible
approac
h
to
this
problem
and
to
gain
practical
exp
erience
with
the
problem
of
in
tegrating
records
with
the
Hask
ell
programming
st
yle.
After
presen
ting
our
implemen
tation,
w
e
compare
our
system
of
records
to
those
found
in
other
languages
and
discuss
alternativ
es
to
our
design.


Before
pro
ceeding,
w
e
will
clarify
our
terminology
.
W
e
use
the
term
r
e
c
or
d
in
only
the
most
general
sense.
The
comp
onen
ts
of
records
are
elds
.
Within
the
con
text
of
our
sp
ecic
prop
osal,
w
e
use
the
terms
structur
e
and
slot
to
denote
our
particular
implemen
tation
of
records
and
elds
(resp
ectiv
ely).
The
issues
of
concern
here
are
not
so
m
uc
h
in
the
fundamen
tal
language
seman
tics,
but
instead
are
matters
of
engineering.
F
rom
a
soft
w
are
engineering
standp
oin
t,
the
record
structures
pro
vided
b
y
a
programming
language
b
enet
from
the
follo
wing
prop
erties:

Expandabilit
y
.
Adding
a
new
eld
to
a
record
should
not
require
mo
dication
of
co
de
whic
h
references
old
elds.
It
should
b
e
p
ossible
to
new
elds
silen
tly
without
c
hanging
existing
co
de.

Reusabilit
y
.
A
record
should
b
e
able
to
include
(inherit)
other
records;
op
erations
whic
h
apply
to
the
included
records
should
also
apply
the
including
record.

Eciency
.
Basic
record
op
erations
m
ust
b
e
extremely
ecien
t;
there
m
ust
b
e
no
hidden
p
erformance
costs.

Priv
acy
.
The
program
m
ust
b
e
able
to
hide
the
in
ternal
details
of
a
record.
Along
with
these
engineering
issues,
w
e
ha
v
e
one
further
goal:
to
k
eep
our
system
as
m
uc
h
in
the
spirit
of
standard
Hask
ell
as
p
ossible.
The
basic
features
of
our
prop
osal
are:

The
seman
tics
are
en
tirely
dened
via
a
translation
to
standard
Hask
ell.
No
mo
di-
cations
are
required
in
the
Hask
ell
t
yp
e
system.

Slots
ma
y
b
e
accessed
via
pattern
matc
hing
or
b
y
function
application.

Slots
ma
y
b
e
(functionally)
up
dated.

Default
v
alues
ma
y
b
e
pro
vided
for
slots.

Uninitialized
slots
can
b
e
detected
b
y
the
programmer.

Sp
ecial
syn
tax
is
used
for
creating,
up
dating,
co
ercing,
etc.
This
a
v
oids
generating
new
names
for
these
op
erations
(as
is
done
in
Common
Lisp
[
]).

Explicit
declarations
are
required
for
all
record
t
yp
es.
This
a
v
oids
the
eciency
and
t
yp
e-inference
problems
asso
ciated
with
more
general
record
t
yp
es
and
pro
duces
more
accurate
messages
when
t
yp
e
errors
o
ccur.

Structures
ma
y
b
e
p
olymorphic.

Multiple
inheritance
is
allo
w
ed.
Inheritance
is
implemen
ted
using
Hask
ell's
t
yp
e
class
mec
hanism;
structure
op
erations
and
user-dened
functions
are
o
v
erloaded
to
allo
w
them
to
apply
to
an
y
structures
dening
appropriate
elds.
Co
ercion
functions
are
pro
vided
to
mo
v
e
up
and
do
wn
the
inheritance
graph.



Data
structuring
in
standard
Hask
ell
Before
presen
ting
our
prop
osal,
w
e
explore
what
can
b
e
done
in
standard
Hask
ell.
This
b
oth
illustrates
the
need
for
impro
v
emen
t
and
pro
vides
the
basis
for
describing
the
seman
tics
of
our
prop
osal.
F
or
example
the
follo
wing
datat
yp
e
whic
h
is
used
to
represen
t
named
en
tities
within
the
Y
ale
Hask
ell
compiler.

data
Definition
=
MkDef
String
--
name
String
--
module
in
which
it
is
defined
String
--
unit
in
which
it
is
defined
Bool
--
is
it
exported?
Bool
--
is
it
a
PreludeCore
symbol?
Bool
--
is
it
a
Prelude
symbol?
Bool
--
is
it
created
by
an
interface?
Bool
--
is
it
``made
up''
by
the
compiler?
(Maybe
SrcLoc)
--
where
it
was
defined.
This
datat
yp
e
is
hard
to
use
reliably
.
There
are
sev
eral
elds
of
the
same
t
yp
e
|
the
t
yp
e
system
is
not
able
to
detect
simple
errors
suc
h
as
acciden
tally
sw
apping
the
fourth
and
fth
elds.
Suc
h
problems
are
v
ery
dicult
to
sp
ot
when
elds
are
iden
tied
only
b
y
their
p
osition
with
resp
ect
to
a
constructor.
It
is
also
hard
to
main
tain:
adding
an
extra
eld
to
this
denition
requires
c
hanges
to
ev
ery
use
of
the
constructor
MkDef
(i.e.
taking
Definitions
apart
in
patterns
and
constructing
Definitions
in
expressions.)
The
usual
solution
to
the
problem
of
reliably
handling
man
y
elds
is
to
dene
\access
functions"
for
up
dating
and
selecting
eac
h
eld
of
the
record.
F
or
this
example,
w
e
m
ust
dene

dieren
t
access
functions
|
one
to
extract
eac
h
slot
and
one
to
up
date
eac
h
slot:
getName,
getModule,
getUnit
::
Definition
->
String
getName
(MkDef
nm
_
_
_
_
_
_
_
_)
=
nm
getModule
(MkDef
_
mod
_
_
_
_
_
_
_)
=
mod
getUnit
(MkDef
_
_
unit
_
_
_
_
_
_)
=
unit
...
setName,
setModule,
setUnit
::
String
->
Definition
->
Definition
setName
nm
(MkDef
_
mod
unit
isEx
isCore
isPrel
isIface
isInternal
loc)
=
(MkDef
nm
mod
unit
isEx
isCore
isPrel
isIface
isInternal
loc)
setModule
mod
(MkDef
nm
_
unit
isEx
isCore
isPrel
isIface
isInternal
loc)
=
(MkDef
nm
mod
unit
isEx
isCore
isPrel
isIface
isInternal
loc)
setUnit
unit
(MkDef
nm
mod
_
isEx
isCore
isPrel
isIface
isInternal
loc)
=
(MkDef
nm
mod
unit
isEx
isCore
isPrel
isIface
isInternal
loc)
...

The
Y
ale
Hask
ell
compiler
is
written
in
Lisp;
this
example
is
obtained
b
y
translating
from
Lisp
to
Hask
ell.
Similar
examples
o
ccur
in
the
Glasgo
w
Hask
ell
compiler
|
whic
h
is
written
in
Hask
ell.


Using
these
access
functions
instead
of
referencing
the
constructor
MkDef
directly
results
in
more
readable
co
de
and
simplies
the
task
of
adding
new
elds
to
a
record.
Ho
w
ev
er,
the
reader
will
appreciate
that
creation
of
these
access
functions
is
a
somewhat
tedious
and
error-prone
task.
A
further
problem
with
this
approac
h
is
that
it
is
no
longer
p
ossible
to
use
pattern
matc
hing
to
extract
comp
onen
ts
of
records.
This
mak
es
programs
more
v
erb
ose.

Syn
tactic
Supp
ort
for
Records
The
core
of
our
prop
osal
is
to
pro
vide
sp
ecial
syn
tax
for
dening
structure
t
yp
es,
accessing
slots,
and
initializing
structures.
The
seman
tics
of
our
prop
osal
is
dened
as
a
translation
in
to
co
de
lik
e
that
giv
en
in
the
previous
section.
The
additions
to
Hask
ell
syn
tax
rules
(app
endix
B
of
[
])
are
as
follo
ws:
.
Structure
declarations
top
de
cl
!
structure
[
~
]
simple
where
f
structb
o
dy
[
;
]
g
[
deriving
(
tyclses
)
]
simple
!
tyc
on
tyvar

.
.
.
tyvar
k
structb
o
dy
!
structsigns
[
;valdefs
]
structsigns
!
structsign

;.
.
.
;structsign
n
structsign
!
vars
::
[
c
ontext
=>
]
typ
e
Using
this
syn
tax,
the
datat
yp
e
and
access
functions
in
section

can
b
e
more
concisely
dened
b
y
structure
~Definition
where
name,
moduleName,
unit
::
String
isExported,
isCore,
isPrelude
::
Bool
fromInterface,
isInternalDef
::
Bool
definedIn
::
Maybe
SourceLoc
(The
\t
widdle"
is
related
to
inheritance
and
is
describ
ed
in
section
..)
The
selector
functions
ha
v
e
exactly
the
same
name
as
the
slot
they
extract;
for
example,
the
follo
wing
function
prin
ts
the
original
name
of
a
denition:
showDefName
::
Definition
->
ShowS
showDefName
d
=
showString
(moduleName
d)
.
showChar
'.'
.
showString
(name
d)


T
ranslation:
The
declaration
structure
~S
t

:
:
:
t
k
where
v

::
u

;
...
;
v
m
::
u
m
v
i
=
init

;
...
;
v
in
=
init
n
is
equiv
alen
t
to
the
t
yp
e
declaration
and
function
declarations
data
S
t

:
:
:
t
k
=
M
k
S
u

...
u
m
v

::
S
t

:
:
:
t
k
->
u

v

(M
k
S
x

...
x
m
)
=
x

.
.
.
v
m
::
S
t

:
:
:
t
k
->
u
m
v
m
(M
k
S
x

...
x
m
)
=
x
m
(The
meaning
of
the
default
v
alues
(v
i
=
init

;
...
;
v
in
=
init
in
)
is
dened
b
elo
w;
the
meaning
of
omitting
the
\t
widdle"
(~)
is
dened
in
section
..)
Note:
Although
w
e
dene
the
seman
tics
of
our
system
b
y
translation
in
to
standard
Hask
ell,
the
constructor
M
k
S
used
in
this
translation
is
not
made
directly
a
v
ailable
to
the
program-
mer.
.
P
attern
Matc
hing
ap
at
!
(
sp
at

,
.
.
.
,
sp
at
n
)
(structure
pattern,
n

)
sp
at
!
var
=
p
at
An
alternativ
e
w
a
y
of
extracting
slots
is
b
y
pattern
matc
hing.
Structure
patterns
consist
of
a
list
of
pairs
of
slot-names
and
patterns.
F
or
example,
the
function
showDefName
could
b
e
written
as:
showDefName
::
Definition
->
ShowS
showDefName
(moduleName
=
m,
name
=
nm)
=
showString
m
.
showChar
'.'
.
showString
nm
The
order
in
whic
h
slot
names
are
listed
do
es
not
matter.
P
attern
matc
hing
pro
ceeds
left
to
righ
t
as
in
all
other
patterns.
T
ranslation:
The
expression
case
e
0
of
(s
=
p

,
...
sn
=
p
n
)
->
e;
->
e
0
,
for
slot
names
s,
.
.
.
sn,
is
equiv
alen
t
to:
let
f
y
=
e
0
g
in
case
e
0
of
f
MkS
x

...
x
k
->
case
x
s
of
f
p

->
...
case
x
sn
of
f
p
n
->
e
;
->
y
g
...
->
y
gg
where
y
,
x

.
.
.
x
k
are
new
v
ariables
and
x
s
is
the
v
alue
of
the
slot
named
s.


.
Up
dates
aexp
!
(
var
=)
(up
date
se
ction)
j
(
up
d

,
.
.
.
,
up
d
n
)
(up
date
function,
n

)
up
d
!
var
=
exp
F
or
eac
h
slot
s
::
t
of
a
structure
S
,
the
up
date
section
(s=)
is
a
function
of
t
yp
e
t
!
S
!
S
whic
h
copies
the
structure
up
dating
the
v
alue
of
the
slot
s.
The
v
alue
to
b
e
placed
in
the
slot
can
b
e
placed
inside
the
paren
thesis,
as
in
(name
=
"foo").
More
than
one
slot
can
b
e
up
dated
at
once,
as
in
(name
=
".",
moduleName
=
"Prelude").
T
ranslation:
Giv
en
the
structure
declaration
structure
~S
t

:
:
:
t
k
where
v

::
u

;
...
;
v
m
::
u
m
v
i
=
init

;
...
;
v
in
=
init
n
the
notation
(v
i
=)
is
equiv
alen
t
to:
(n
x
(M
k
S
x

...
x
i
...
x
m
)
->
(M
k
S
x

...
x
...
x
m
))
and
the
notation
(v
i
=
e

,
...v
in
=
e
n
)
is
equiv
alen
t
to:
(n
s
->
(v
i
=)
e

(
:
:
:
(v
in
=)
e
n
s
:
:
:
))
The
order
in
whic
h
slot
names
are
listed
do
es
not
matter;
but
it
is
a
static
error
to
use
the
same
slot
name
more
than
once.
.
Structure
Creation
There
is
no
sp
ecial
syn
tax
for
structure
creation.
The
structure
name
is
used
as
a
mo
died
data
constructor:
instead
of
b
eing
applied
to
the
comp
onen
t
v
alues,
this
constructor
applies
an
up
date
function
to
an
initial
v
alue
constructed
from
the
defaults
sp
ecied
in
the
structure
declaration.
F
or
example,
the
function
mkCoreDef
creates
a
PreludeCore
denition.
The
list
of
slot
names
and
v
alues
is
an
up
date
function
as
dened
in
the
previous
section
and
Definition
is
a
function
whic
h
applies
the
up
date
function
to
an
\empt
y"
structure
in
whic
h
eac
h
slot
is
undened
(there
are
no
default
slot
v
alues
declared
in
this
example).
mkCoreDef
::
String
->
SourceLoc
->
Definition
mkCoreDef
nm
src
=
Definition
(
name
=
nm,
moduleName
=
"PreludeCore",
isExported
=
True,
isCore
=
True,
isPrelude
=
True,
fromInterface
=
False,
definedIn
=
src
)


The
syn
tax
for
declaring
structures
allo
ws
default
v
alues
to
b
e
sp
ecied
for
some
of
the
slots.
A
straigh
tforw
ard
approac
h
w
ould
require
the
default
v
alue
of
eac
h
slot
to
ha
v
e
the
same
t
yp
e
as
the
slot.
F
or
example,
one
migh
t
add
the
follo
wing
default
v
alues
to
the
structure
declaration.
...
isExported
=
False
isCore
=
False
isPrelude
=
False
fromInterface
=
False
definedIn
=
Nothing
Ho
w
ev
er,
b
y
making
the
default
a
function
mapping
the
structure
b
eing
dened
on
to
a
slot
v
alue
it
b
ecomes
p
ossible
for
default
v
alues
to
dep
end
on
the
v
alues
of
other
slots
|
particularly
those
of
explicitly-initialized
slots.
F
or
example,
the
v
alues
of
the
slots
isCore
and
isPrelude
can
b
e
made
to
dep
end
on
the
v
alue
of
the
moduleName
slot.
...
isExported
self
=
False
isCore
(moduleName
=
mod)
=
mod
==
"PreludeCore"
isPrelude
(moduleName
=
mod)
=
take

mod
==
"Prelude"
fromInterface
self
=
False
definedIn
self
=
Nothing
The
implemen
tation
of
this
st
yle
of
default
argumen
t
is
somewhat
subtle:
w
e
use
a
recursion
to
allo
w
explicitly
initialized
slots
to
o
v
erride
default
v
alues
and
to
allo
w
default
v
alues
to
dep
end
on
other
slots
in
the
same
structure.
T
ranslation:
F
or
a
structure
t
yp
e
constructor
S
,
the
o
ccurrence
of
the
t
yp
e
constructor
S
in
an
expression
is
equiv
alen
t
to
the
function
ninit
->
let
s
=
init
((v

=
init

s,
...,
v
n
=
init
n
s)
(MkS
?
:
:
:
?)
in
s)
where
the
default
v
alues
for
v
ariables
v

;
:
:
:
;
v
n
are
init

;
:
:
:
;
init
n
(resp
ectiv
ely).
It
is
a
static
error
to
pro
vide
more
than
one
default
v
alue
for
a
slot.
Uninitialized
slots
with
no
default
are
b
ound
to
error
calls.
Strictness
annotations
in
data
t
yp
e
denitions
cause
problems
with
initialization:
an
unini-
tialized
structure
slot
w
ould
immediately
cause
a
program
error.
Our
solution
is
that
strict
slots
m
ust
ha
v
e
a
default
v
alue
and
that
default
v
alue
should
ha
v
e
the
same
t
yp
e
as
the
slot
(rather
than
b
eing
a
function
whose
argumen
t
is
the
structure
b
eing
created).
This
constan
t
is
used
instead
of
?
in
the
ab
o
v
e
translation.


.
Uninitialized
Slots
Slots
whic
h
ha
v
e
no
default
v
alue
ma
y
remain
uninitialized
b
y
structure
creation.
While
accessing
suc
h
slots
results
in
a
run
time
error,
it
is
sometimes
useful
to
test
whether
a
slot
is
initialized
without
actually
referencing
its
v
alue.
It
is,
of
course,
p
ossible
to
a
v
oid
this
b
y
adopting
the
con
v
en
tion
that
ev
ery
slot
m
ust
ha
v
e
a
default
v
alue.
On
the
other
hand,
b
y
allo
wing
uninitialized
slots
to
b
e
detectable,
a
robust
deriv
ed
Text
instance
for
structures
can
simply
skip
o
v
er
uninitialized
slots
instead
of
crashing
when
attempting
to
access
suc
h
a
slot.
The
c
hanges
to
the
translation
are
straigh
tforw
ard
but
tedious:
the
datat
yp
e
data
S
t

:
:
:
t
k
=
M
k
S
u

...
u
m
is
c
hanged
to
data
S
t

:
:
:
t
k
=
M
k
S
(Maybe
u

)
...
(Maybe
u
m
)
The
denition
of
selector
functions
and
up
date
sections
are
mo
died
to
accommo
date
this
c
hange
v
i
(M
k
S
x

...
(Just
x
i
)
...
x
m
)
=
x
i
(v
i
=)
=
n
x
(M
k
S
x

...
x
i
...
x
m
)
->
(S
x

...
(Just
x)
...
x
m
)
and
(in
the
absence
of
an
explicit
default)
the
default
v
alue
of
ev
ery
slot
is
c
hanged
from
?
to
Nothing.
T
ranslation:
Giv
en
the
structure
declaration
structure
~S
t

:
:
:
t
k
where
v

::
u

;
...
;
v
m
::
u
m
v
i
=
init

;
...
;
v
in
=
init
in
the
notation
(=
v
i
)
is
equiv
alen
t
to:
(n
(M
k
S
x

:
:
:
x
i
:
:
:
x
m
)
->
case
x
i
of
f
Just
->
True;
Nothing
->
False
g)
This
translation
is
rather
inecien
t
|
imp
osing
an
o
v
erhead
on
creation,
selection
and
up
dates.
F
ortunately
,
it
is
easy
to
detect
undened
slots
without
an
explicit
Maybe
datat
yp
e
in
the
represen
tation.
T
o
pro
duce
meaningful
error
messages,
eac
h
p
oten
tially
undened
slot
is
already
asso
ciated
with
a
particular
error
th
unk.
Instead
of
wrapping
the
slot
v
alue
up
in
the
Maybe
data
t
yp
e,
the
denedness
c
hec
k
simply
compares
the
slot
v
alue
with
the
asso
ciated
error
th
unk
using
p
oin
ter
equalit
y
.

Adding
Inheritance
It
is
p
ossible
to
extend
this
translation
further
to
allo
w
a
structure
to
inherit
slots
from
other
structures.
F
or
example,
one
migh
t
dene
v
ariables
whic
h
are
just
lik
e
denitions
but


pro
vide
additional
slots
to
store
the
t
yp
e,
signature,
xit
y
,
denition,
etc
of
the
v
ariable.
W
e
extend
the
syn
tax
sligh
tly
to
sp
ecify
whic
h
structures
slots
are
b
eing
inherited
from.
top
de
cl
!
structure
ty
con

;
:
:
:
;
ty
con
n
=>
[
~
]
tyc
on
where
f
structb
o
dy
[
;
]
g
[
deriving
(
tyclses
)
]
(n

)
F
or
example,
to
dene
a
t
yp
e
Variable
whic
h
inherits
slots
from
the
t
yp
e
Definition,
w
e
write:
structure
Definition
=>
Variable
where
varType
::
Signature
varSignature
::
Maybe
Signature
fixity
::
Fixity
definition
::
Expression
The
ma
jor
c
hange
required
to
mak
e
this
w
ork
is
that
the
functions
to
select
slots
and
up
date
structures
m
ust
b
e
o
v
erloaded
[	
].
That
is,
instead
of
translating
a
structure
denition
in
to
just
a
datat
yp
e
and
a
collection
of
slot
selection
and
up
date
functions,
structure
denitions
are
translated
in
to
a
t
yp
e
class
with
selection
and
up
date
functions
as
metho
ds,
a
new
datat
yp
e
and
an
instance
of
the
datat
yp
e
for
that
class.
W
e
use
the
same
name
for
the
t
yp
e
its
corresp
onding
class
|
this
w
ould
normally
b
e
a
syn
tax
error
since
Hask
ell
do
es
not
allo
w
t
yp
es
and
classes
to
share
names.
F
or
example,
the
denition
of
the
structure
Definition
m
ust
b
e
c
hanged
to
dene
a
t
yp
e
class
(also
called
Definition)
with
metho
ds
name,
moduleName,
unit
::
Definition
a
=>
a
->
String
...
(name=),
(moduleName=),
(unit=)
::
Definition
a
=>
String
->
a
->
a
...
The
old
denition
of
the
access
functions
is
used
to
dene
an
instance
of
the
class
Definition
at
the
t
yp
e
Definition.
Similarly
,
the
denition
of
the
t
yp
e
Variable
is
used
to
dene
a
t
yp
e
class
Variable,
and
a
data
t
yp
e
Variable
whic
h
is
an
instance
of
b
oth
Definition
and
Variable.
A
structure
ma
y
b
e
either
narro
w
ed
to
a
con
tained
structure
or
widened
to
a
con
taining
structure.
Widening
is
accomplished
b
y
adding
undened
slots
to
the
v
alue.
F
or
a
structure
t
yp
e
S,
the
function
(->
S)
narro
ws
a
v
alue
from
an
y
t
yp
e
whic
h
includes
S
on
to
S
and
the
function
(S
->)
widens
a
v
alue
of
t
yp
e
S
in
to
an
y
t
yp
e
con
taining
S.
The
t
yp
es
of
these
op
erators
are:
(->
S)
::
S
a
=>
a
->
S
(S
->)
::
S
a
=>
S
->
a
	

T
ranslation:
instance
S
S
0
where
...
(->
S
)
(M
k
S
0
x

:
:
:
x
n
)
=
M
k
S
n

:
:
:
n
i
(S
->)
(M
k
S
x

:
:
:
x
m
)
=
M
k
S
0
w

:
:
:
w
j
where
n
i
is
the
x
in
the
corresp
onding
slot
and
w
i
is
the
corresp
onding
x
when
the
slot
is
part
of
S
or
?
otherwise.
F
or
simplicit
y
,
widening
do
es
not
in
v
ok
e
the
defaulting
mec
hanism
to
ll
the
new
slots
added
b
y
widening.
The
most
dicult
c
hange
is
in
pattern
matc
hing.
Since
w
e
do
not
kno
w
the
exact
t
yp
e
of
the
structure,
the
translation
giv
en
in
section
.
is
no
longer
v
alid.
The
translation
w
e
implemen
ted
is:
T
ranslation:
The
expression
case
e
0
of
(s
=
p

,
...
sn
=
p
n
)
->
e;
->
e
0
,
for
slot
names
s,
.
.
.
sn,
is
equiv
alen
t
to:
let
f
x
=
e
0
;
y
=
e
0
g
in
case
s
y
of
f
p

->
...
case
sn
x
of
f
p
n
->
e
;
->
y
g
...
->
y
g
where
x,
y
,
x

.
.
.
x
k
are
new
v
ariables
and
x
s
is
the
v
alue
of
the
slot
named
s.
This
translation
has
the
dra
wbac
k
that
it
ma
y
o
ccasionally
cause
a
space
leak
if
an
y
p
i
is
irrefutable.
The
problem
is
exactly
that
rep
orted
b
y
W
adler
[
]:
slot
extraction
is
only
p
erformed
when
the
v
alue
of
the
slot
is
actually
required;
not
when
the
pattern
matc
hing
o
ccurs.
This
can
cause
the
en
tire
structure
to
b
e
retained
when
only
one
slot
is
required.
The
follo
wing
alternativ
e
translation
w
ould
eliminate
this
space
leak,
but
may
mak
e
o
v
er-
loaded
pattern
matc
hing
more
exp
ensiv
e.
(This
translation
is
for
single
inheritance.
Ex-
tending
it
to
handle
m
ultiple
inheritance
is
straigh
tforw
ard
but
tedious.)
Alternativ
e
translation:
If
e
0
has
t
yp
e
S
0

)
,
and
S
0
has
slots
s,
.
.
.
sn,
the
expression
case
e
0
of
(s
=
p

,
...
sn
=
p
n
)
->
e;
->
e
0
,
is
equiv
alen
t
to:
let
f
x
=
e
0
;
y
=
e
0
g
in
case
(->S
0
)
x
of
f
MkS'
x

...
x
k
->
case
x
s
of
f
p

->
...
case
x
sn
of
f
p
n
->
e
;
->
y
g
...
->
y
gg
where
x,
y
,
x

.
.
.
x
k
are
new
v
ariables
and
x
s
is
the
v
alue
of
the
slot
named
s.
0

.
Av
oiding
Inheritance
Inheritance
is
a
p
o
w
erful
to
ol
but
its
use
presen
ts
t
w
o
problems:
.
Since
inheritance
is
implemen
ted
with
the
class
system,
using
inheritance
in
v
olv
es
the
same
o
v
erhead
that
o
v
erloading
functions
en
tails.
This
o
v
erhead
consists
of
b
oth
the
instances
needed
to
dene
an
op
eration
o
v
er
a
set
of
data
t
yp
es
and
the
extra
lev
el
of
indirection
needed
to
call
o
v
erloaded
functions.
While
the
execution
time
o
v
erhead
can
b
e
eliminated
using
t
yp
e
signatures
to
eliminate
o
v
erloading,
this
is
v
ery
burdensome
for
the
programmer.
.
Inheritance
also
ma
y
prev
en
t
early
detection
of
some
errors.
F
or
example,
giv
en
t
w
o
structures
structure
S
where
a,
b
::
Int
structure
S
where
a,
b
::
Int
f
(a
=
x,
b
=
y)
=
x
+
y
The
denition
of
f
is
almost
certainly
incorrect
since
its
argumen
t
m
ust
con
tain
slots
from
t
w
o
dieren
t
structure
t
yp
es.
Ho
w
ev
er,
this
do
es
not
cause
a
t
yp
e
error
since
a
third
structure
ma
y
later
b
e
declared
(p
erhaps
in
a
separately-compiled
mo
dule)
whic
h
includes
b
oth
S
and
S.
On
the
other
hand,
a
t
yp
e
error
do
es
o
ccur
if
w
e
try
to
apply
f
to
an
argumen
t
of
t
yp
e
S
(whic
h
is
probably
what
the
programmer
in
tended
to
do.)
If
S
had
not
b
een
o
v
erloaded,
this
error
w
ould
ha
v
e
b
een
caugh
t
when
f
w
as
declared.
(Pro
viding
the
t
yp
e
signature
f
::
S
->
Int
w
ould
also
ha
v
e
caugh
t
this
error.)
W
e
th
us
mak
e
inheritance
optional:
a
structure
declaration
ma
y
indicate
that
the
declared
structure
will
not
b
e
inherited
b
y
an
y
other
structure.
This
is
accomplished
using
a
~
in
fron
t
of
the
structure
name
in
the
declaration:
structure
S
=>
~S
where
s
::
Int
The
~
prev
en
ts
S
from
b
eing
used
as
a
class
and
allo
ws
an
y
use
of
the
slot
s
to
precisely
determine
the
t
yping
of
an
up
date
or
pattern.
.
Multiple
Inheritance
and
Defaulting
The
Hask
ell
t
yp
e
class
system
allo
ws
a
class
to
ha
v
e
m
ultiple
sup
erclasses.
Since
structures
are
translated
in
to
t
yp
e
classes,
our
translation
naturally
allo
ws
multiple
inheritanc
e:
a
structure
is
allo
w
ed
to
inherit
slots
from
an
y
set
of
other
structures.
In
the
t
yp
e
class
system,
defaults
can
only
apply
to
metho
ds
directly
asso
ciated
with
a
class,
not
those
inherited
from
sup
erclasses.
This
a
v
oids
am
biguit
y
o
v
er
whic
h
default
to
apply


when
the
same
metho
d
is
inherited
via
sev
eral
routes
(e.g.
the
standard
class
Integral
inherits
Ord
via
b
oth
the
Ix
class
and
the
Real
class).
W
e
ha
v
e
c
hosen
to
relax
this
rule
for
structures.
Structure
declarations
ma
y
dene
default
metho
ds
for
inherited
slots.
The
follo
wing
rule
is
used
to
a
v
oid
am
biguit
y:
If
a
structure
inherits
a
slot
s,
it
ma
y
either
dene
a
new
default
for
s
or
use
the
default
asso
ciated
with
the
rst
structure
in
the
list
of
included
structures
con
taining
s.
.
The
P
olymorphic
Inheritance
Problem
The
reader
ma
y
ha
v
e
noticed
that
the
syn
tax
for
structure
declarations
do
es
not
allo
w
b
oth
p
olymorphism
and
inheritance.
This
is
to
a
v
oid
the
follo
wing
limitation
of
Hask
ell's
t
yp
e
system.
The
declarations
generated
b
y:
structure
S
a
where
s
::
a
structure
S
b
where
s
::
b
structure
S
a,
S
b
=>
S
a
b
w
ould
b
e:
data
S
a
=
MkS
a
data
S
b
=
MkS
b
data
S
a
b
=
MkS
a
b
class
S
s
where
s
::
s
a
->
a
class
S
s
where
s
::
s
b
->
b
--
instances
for
S,
S
omitted
instance
S
(S
b)
where
s
(MkS
x
_)
=
x
instance
S
(S
a)
where
s
(MkS
_
x)
=
x
This
\class
declaration"
is
not
legal
Hask
ell
since
the
t
yp
e
v
ariable
s
m
ust
b
e
instan
tiated
with
a
t
yp
e
constructor
rather
than
a
t
yp
e.
This
ma
y
app
ear
to
b
e
legal
using
constructor
classes,
but
the
instance
declaration
for
S
will
still
not
w
ork.
F
or
no
w
w
e
simply
prohibit
the
inheritance
of
p
olymorphic
structures
but
allo
w
p
olymorphic
structures
and
unrestricted
inheritance
of
non-p
olymorphic
structures.
It
remains
to
b
e
seen
whether
this
is
excessiv
ely
restricting
in
real
programs.



Alternativ
es
and
Related
W
ork
Our
system
is
an
exp
erimen
t,
not
a
nished
pro
duct.
Ha
ving
the
exp
erience
of
carrying
an
implemen
tation
all
the
w
a
y
through
and
using
it
on
a
n
um
b
er
of
real
applications,
including
the
Y
ale
debugger
and
a
protot
yp
e
GUI
system,
w
e
can
assess
our
design
and
consider
alternativ
es.
.
The
Namespace
Issue
Our
placemen
t
of
slot
names
in
to
the
v
alue
namespace
is
a
signican
t
dierence
from
lan-
guages
suc
h
as
C,
P
ascal,
or
ML.
Using
a
separate
namespace
for
eac
h
structure
in
the
manner
of
C
is
not
p
ossible,
ho
w
ev
er,
b
ecause
this
dep
ends
on
a
b
ottom-up
st
yle
of
t
yp
e
inference
whic
h
determines
whic
h
t
yp
e
of
structure
is
in
v
olv
ed
b
efore
resolving
eld
names.
In
practice,
w
e
ha
v
e
found
that
placing
selector
functions
in
the
v
alue
namespace
mak
es
it
almost
essen
tial
to
use
long
eld
names.
F
or
example,
the
structure
Point
dened
b
y
structure
~Point
where
x,
y
::
Int
in
tro
duces
t
w
o
top-lev
el
function
names
x
and
y
whic
h
the
programmer
is
lik
ely
to
w
an
t
to
use
for
other
purp
oses.
W
e
adopted
the
con
v
en
tion
of
using
the
structure
name
as
a
prex
for
the
eld
name.
F
or
example,
w
e
w
ould
normally
c
ho
ose
slot
names
pointX
and
pointY
instead
of
x
and
y.
This
problem
could
b
e
reduced
b
y
pro
viding
sp
ecial
syn
tax
for
selector
functions
|
a
v
oiding
the
need
to
place
selector
functions
in
the
v
alue
namespace|
but
this
w
ould
not
completely
a
v
oid
the
problem:
all
slot
names
w
ould
still
b
e
in
the
same
namespace.
A
more
radical
solution
is
used
in
ML
whic
h
allo
ws
\lab
els"
to
b
e
shared
among
dieren
t
records.
These
lab
els
do
not
carry
t
ypings
in
the
same
w
a
y
the
slot
names
do.
Instead,
they
simply
attac
h
names
to
tuple
comp
onen
ts.
Implemen
ting
records
using
shared
lab
els
w
ould
require
signican
t
c
hanges
to
the
syn
tax
and
further
complicate
the
t
yp
e
system.
.
Default
v
alues
In
our
exp
erience,
some
sort
of
defaulting
mec
hanism
is
essen
tial.
This
allo
ws
new
elds
to
b
e
inserted
in
to
a
structure
without
c
hanging
all
references
to
the
asso
ciated
constructor.
Although
not
often
used,
the
expressiv
eness
of
m
utually
recursiv
e
slot
initialization
can
b
e
v
ery
useful
and
seems
to
b
e
more
in
the
Hask
ell
spirit
than
restricting
defaults
v
alues
to
constan
ts
or
imp
osing
some
sort
of
ev
aluation
order
on
the
default
computation.
.
Uninitialized
Slots
Though
easy
to
implemen
t,
the
abilit
y
to
detect
uninitialized
structure
slots
is
somewhat
dubious.
T
o
date,
our
only
use
of
this
feature
has
b
een
to
allo
w
the
deriv
ed
Text
instances
for
structures
to
skip
o
v
er
uninitialized
slots.


The
need
to
detect
uninitialized
slots
could
b
e
eliminated
b
y
making
it
imp
ossible
to
lea
v
e
a
slot
uninitialized.
This
could
b
e
done
b
y
c
hanging
the
syn
tax
of
structure
creation
to
require
a
list
of
slot
names
and
v
alues
(rather
than
allo
wing
an
y
expression
of
the
righ
t
t
yp
e).
It
w
ould
then
b
e
p
ossible
for
the
compiler
to
c
hec
k
that
ev
ery
slot
had
either
a
default
v
alue
or
an
explicitly
pro
vided
v
alue.
A
similar
restriction
is
imp
osed
in
ML
[],
where
it
is
required
b
y
the
com
bination
of
strict
seman
tics
and
t
yp
e
safet
y
.
.
P
attern
Matc
hing
P
attern
matc
hing
in
Hask
ell
lac
ks
the
extensibilit
y
of
other
language
features.
It
w
ould
certainly
b
e
b
etter
to
add
a
general
purp
ose
mec
hanism
exible
enough
to
dene
structure
pattern
matc
hing
than
to
add
structure
pattern
matc
hing
as
a
sp
ecial
case,
as
in
our
im-
plemen
tation.
Sadly
,
W
adler's
\views"
[
,
]
w
ould
not
b
e
exible
enough
to
handle
this
case.
In
practice,
w
e
found
that
w
e
didn't
use
pattern
matc
hing
v
ery
m
uc
h,
preferring
to
use
selector
functions
to
extract
slots
at
the
place
where
they
are
needed
rather
than
at
the
head
of
a
function.
This
ma
y
b
e
caused
b
y
a
n
um
b
er
of
factors:
our
familiarit
y
with
this
st
yle
of
programming
from
other
languages
that
supp
ort
records;
our
use
of
long
eld
names
(section
.);
the
fact
that
structure
pattern
matc
hing
is
generally
not
connected
with
con
trol
o
w;
or
our
use
of
structures
in
big,
complicated
programs
that
solv
e
real
problems
instead
of
in
highly
p
olished
classro
om
examples.
.
Allo
wing
P
olymorphic
Inheritance
There
app
ears
to
b
e
a
simple
extension
to
constructor
classes
whic
h
w
ould
allo
w
p
olymor-
phic
inheritance.
The
problem
with
constructor
classes
is
that
only
those
t
yp
es
whic
h
are
curried
applications
of
a
t
yp
e
constructor
are
a
v
ailable.
Th
us,
for
a
t
yp
e
T
a
b,
constructor
classes
can
mak
e
use
of
T,
T
a,
and
T
a
b
as
t
yp
es.
Expanding
the
implicit
currying,
these
t
yp
es
are
\a
b
->
T
a
b,
\b
->
T
a
b,
and
T
a
b.
Unfortunately
,
p
olymorphic
inheri-
tance
requires
a
t
yp
e
suc
h
as
\a
->
T
a
b.
W
e
conjecture
that
adding
a
limited
lam
b
da
to
the
t
yp
e
language
is
p
ossible:
this
lam
b
da
is
needed
only
to
p
erm
ute
the
argumen
ts
to
the
t
yp
e
constructors.
.
Syn
tax
Issues
Using
similar
syn
tax
for
up
date
functions
(whic
h
are
functions)
and
structure
patterns
(whic
h
matc
h
data
v
alues)
is
somewhat
irregular.
In
hindsigh
t,
it
w
ould
b
e
p
ossible
to
drop
the
paren
thesis
in
single
up
date
functions
and
to
drop
m
ultiple
up
date
functions.
Where
one
curren
tly
writes
up
date
functions
suc
h
as
(moduleName
=
m,
name
=
nm),
one
w
ould
instead
write
(moduleName
=
m
.
name
=
nm).
Our
use
of
sp
ecial
syn
tax
suc
h
as
(s=),
(=s),
(->
S)
and
(S
->)
is
somewhat
con
torted.
An
alternativ
e
w
ould
b
e
to
indulge
in
name
mangling
(deriving
one
name
from
another)
as
in
Common
Lisp.
(F
or
example,
the
function
setFoo
w
ould
b
e
used
to
alter
the
v
alues
of
slot
foo.)
Ho
w
ev
er,
no
other
Hask
ell
feature
uses
name
mangling
so
w
e
hesitate
to
add
this.


.
Record
T
yp
es
An
en
tirely
dieren
t
system
can
b
e
constructed
using
lab
eled
records
and
subt
yp
e
infer-
ence
[
,

].
The
adv
an
tage
of
suc
h
as
system
w
ould
b
e
that
structure
declarations
w
ould
b
e
unnecessary
.
While
t
yp
e
systems
ha
v
e
b
een
prop
osed
featuring
subt
yping
based
on
ex-
tensible
records,
these
ha
v
e
t
w
o
disadv
an
tages:
these
require
a
fundamen
tal
c
hange
to
the
Hask
ell
t
yp
e
system
and
it
ma
y
b
e
dicult
to
generate
ecien
t
record
op
erations
using
these
systems.
.
Generalizing
to
Arbitrary
Datat
yp
es
The
structures
considered
in
this
prop
osal
are
just
syn
tactic
sugar
for
tuples;
but,
Hask
ell's
datat
yp
es
allo
w
one
to
dene
a
\sum
of
tuples".
It
w
ould
b
e
straigh
tforw
ard
to
adapt
the
inheritance-free
translation
in
section

to
allo
w
one
to
dene
eld
names
for
arbitrary
datat
yp
es.
F
or
example,
giv
en
the
datat
yp
e:
data
Expr
=
Lambda
(arg
::
Var)
(body
::
Expr)
|
App
(fun
::
Expr)
(arg
::
Expr)
|
Var
(v
::
Var)
one
could
use
pattern
matc
hing
suc
h
as:
eval
env
(Lambda
(arg
=
v,
body
=
e))
=
\x.
eval
((v,x):env)
e
eval
env
(App
(fun
=
f,
arg
=
a))
=
(eval
env
f)
(eval
env
a)
eval
env
(Var
(v
=
x))
=
lookup
env
x
.	
Ob
ject-Orien
ted
Programming
The
abilit
y
to
inherit
structure
slots
is
a
step
to
w
ard
a
more
ob
ject-orien
ted
programming
paradigm.
Ho
w
ev
er,
when
w
e
used
our
structure
system
in
a
GUI
system
in
an
ob
ject-
orien
ted
st
yle,
a
n
um
b
er
of
deciencies
b
ecame
ob
vious.
First,
the
classes
dened
for
structures
con
tain
only
slot
accessing
functions.
T
o
add
other
class
metho
ds
(as
with
C++
virtual
functions),
w
e
w
ere
forced
to
add
an
extra
class
for
eac
h
structure
t
yp
e.
That
is,
for
a
structure
S
(whic
h
denes
a
class
S),
w
e
added
the
class
S
=>
S'
to
hold
metho
ds
asso
ciated
with
structures
inheriting
from
S.
This
w
as
v
ery
unsatisfactory
|
it
w
ould
b
e
m
uc
h
nicer
to
b
e
extend
structure
denitions
to
directly
include
these
metho
ds.
Dynamic
binding,
whic
h
w
ould
allo
w
metho
ds
(dictionaries)
to
b
e
attac
hed
directly
to
data
v
alues,
is
not
a
v
ailable
in
Hask
ell
without
some
sort
of
existen
tial
t
yping.
This
mak
es
non-homogeneous
lists
imp
ossible
in
standard
Hask
ell.
The
co
ercion
functions
w
ere
v
ery
useful
|
these
allo
w
ob
jects
to
b
e
mo
v
ed
up
or
do
wn
the
class
hierarc
h
y
so
as
to
dispatc
h
metho
ds
asso
ciated
with
other
t
yp
es.
A
more
general
ob
ject-orien
ted
extension
to
Hask
ell
w
ould
eliminate
the
need
for
slot
in-
heritance
at
the
structure
lev
el.
Pro
vided
an
y
extra
o
v
erhead
could
b
e
eliminated
b
y
the
compiler,
suc
h
an
extension
ma
y
b
e
preferable
to
using
the
inheritance
mec
hanism
describ
ed
here.


.0
Co
de
Generation
W
e
ha
v
e
found
that
three
factors
signican
tly
aect
the
qualit
y
of
the
generated
co
de:
.
Inlining
selection
and
up
date
functions
eliminates
a
function
call
and
allo
ws
further
optimizations
to
b
e
p
erformed.
Inlining
the
initialization
function
a
v
oids
constructing
and
destructuring
man
y
partial
records.
.
Using
pattern
matc
hing
on
function
argumen
ts
pro
duces
co
de
that
is
b
oth
more
ef-
cien
t
and
less
lik
ely
to
leak
space
than
if
selector
functions
are
used.
The
reason
is
simple:
pattern
matc
hing
is
p
erformed
when
the
function
is
called
whereas
selection
functions
are
only
executed
when
the
selected
v
alue
is
ev
aluated.
Exactly
the
same
dierence
o
ccurs
if
programmers
use
pattern
matc
hing
on
lists
instead
of
head
and
tail.
.
Av
oiding
o
v
erloading
(whether
b
y
sh
unning
inheritance
or
b
y
pro
viding
explicit
t
yp
e
signatures)
eliminates
dictionary
lo
okups
and
allo
ws
selection
and
up
date
functions
to
b
e
inlined.
Restricting
ourselv
es
to
single
inheritance
w
ould
allo
w
a
more
ecien
t
implemen
tation
of
inheritance:
inherited
slots
could
b
e
placed
at
the
same
oset
from
the
start
of
a
structure
as
in
their
paren
ts
allo
wing
exactly
the
same
co
de
sequence
to
b
e
used
for
selecting
a
slot
|
no
matter
what
it's
t
yp
e.
This
optimisation
w
ould
eliminate
the
need
to
pass
dictionaries
around;
greatly
impro
ving
p
erformance.
By
c
ho
osing
the
b
est
options
(inline
structure
op
erations,
use
pattern
matc
hing
and
a
v
oid
o
v
erloading),
w
e
are
able
to
generate
exactly
the
same
co
de
as
if
no
abstraction
mec
hanisms
had
b
een
used.

Conclusions
Our
exp
erience
of
b
eing
able
to
name
elds
has
b
een
en
tirely
p
ositiv
e
|
w
e
feel
that
it
signican
tly
impro
v
es
the
readabilit
y
and
main
tainabilit
y
of
our
programs.
Ha
ving
an
elegan
t
notation
for
up
dates
is
also
v
ery
useful.
Programs
using
these
features
are
easier
to
main
tain
and
the
co
de
is
v
ery
readable.
The
b
est
w
a
y
to
deal
with
inheritance
is
not
y
et
kno
wn.
A
more
adv
anced
ob
ject-orien
ted
extension
to
Hask
ell
ma
y
pro
vide
the
same
capabilities
w
e
ha
v
e
implemen
ted.
Simplifying
to
a
single
inheritance
st
yle
w
ould
eliminate
the
p
erformance
problems
in
tro
duced
through
the
use
of
the
class
system.
Muc
h
of
the
implemen
tation
baggage
could
b
e
eliminated
b
y
remo
ving
non-constan
t
defaults
and
inheritance.
This
w
ould
mak
e
structure
creation
trivial:
an
up
date
is
applied
to
a
structure
con
taining
the
constan
t
defaults.
No
class
or
instance
declarations
w
ould
b
e
generated
b
y
structures;
only
data
declarations.
No
supp
ort
functions
w
ould
b
e
required
|
all
structure
op
erations
could
b
e
expanded
inline.
Suc
h
a
stripp
ed-do
wn
system
w
ould
address
man
y
,
but
not
all,
of
the
engineering
issues
describ
ed
earlier.
A
t
a
minim
um,
suc
h
a
system
should
b
e
considered
for
Hask
ell
..


Ac
kno
wledgmen
ts
W
e
are
grateful
to
W
arren
Burton,
Mark
Jones,
and
Randy
Hudson
for
their
commen
ts
on
an
early
design
of
this
system.
Sandra
Lo
osemore
and
others
in
the
Y
ale
Hask
ell
group
also
pro
vided
v
aluable
assistance.
References
[]
FW
Burton
and
RD
Cameron.
P
attern
matc
hing
with
abstract
data
t
yp
es.
Journal
of
Functional
Pr
o
gr
amming,
():{	0,
April
		.
[]
P
Hudak,
SL
P
eyton
Jones,
PL
W
adler,
Arvind,
B
Boutel,
J
F
airbairn,
J
F
asel,
M
Guz-
man,
K
Hammond,
J
Hughes,
T
Johnsson,
R
Kieburtz,
RS
Nikhil,
W
P
artain,
and
J
P
eterson.
Rep
ort
on
the
functional
programming
language
Hask
ell,
V
ersion
..
A
CM
SIGPLAN
Notic
es,
,
Ma
y
		.
[]
R
Milner,
M
T
ofte,
and
R
Harp
er.
The
denition
of
Standar
d
ML.
MIT
Press,
		0.
[]
A
tsushi
Ohori.
A
compilation
metho
d
for
ML-st
yle
p
olymorphic
record
calculi.
In
Principles
of
Pr
o
gr
amming
L
anguages,
pages
{.
A
CM,
Jan
uary
		.
[]
D
R

em
y.
T
yp
ec
hec
king
records
in
a
natural
extension
of
ML.
In
Principles
of
Pr
o
gr
am-
ming
L
anguages,
pages
{	.
A
CM,
Jan
uary
		.
[]
GL
Steele.
Common
Lisp
|
The
L
anguage.
Digital
Press,
nd
edition,
		.
[]
PL
W
adler.
Fixing
a
space
leak
with
a
garbage
collector.
Softwar
e
|
Pr
actic
e
and
Exp
erienc
e,
(	):	{0,
	.
[]
PL
W
adler.
Views
|
a
w
a
y
for
pattern
matc
hing
to
cohabit
with
data
abstraction.
T
ec
hnical
Rep
ort
,
Programming
Metho
dology
Group,
Chalmers
Univ
ersit
y
,
Sw
eden,
Marc
h
	.
[	]
PL
W
adler
and
S
Blott.
Ho
w
to
mak
e
ad-ho
c
p
olymorphism
less
ad
ho
c.
In
Principles
of
Pr
o
gr
amming
L
anguages.
A
CM,
Jan
uary
		.


