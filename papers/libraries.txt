Designing
the
Standard
Hask
ell
Libraries
(P
osition
P
ap
er)
Alastair
Reid
and
John
P
eterson
Departmen
t
of
Computer
Science,
Y
ale
Univ
ersit
y
,
P
.O.
Bo
x
0,
New
Ha
v
en,
CT
00,
USA.
Electronic
mail:
freid-alastair,peterson-joh
ng@cs.
yal
e.ed
u
Octob
er
,
		
Abstract
Fiv
e
y
ears
after
the
rst
Hask
ell
rep
ort
w
as
published,
the
Hask
ell
language
con
tin
ues
to
gro
w
and
mature.
After
v
e
y
ears
exp
erience
of
Hask
ell
programming,
w
e
wish
to
b
oth
expand
and
simplify
the
Hask
ell
language.
Ov
er
the
y
ears,
man
y
Hask
ell
libraries
ha
v
e
b
een
dev
elop
ed.
The
Hask
ell
Committee
is
expanding
the
language
b
y
standard-
ising
a
set
of
libraries
to
add
to
the
denition
of
Hask
ell.
Another
goal
is
to
simplify
Hask
ell
b
y
mo
ving
parts
of
the
prelude,
a
built-in
set
of
t
yp
es
and
functions
implicitly
a
part
of
ev
ery
Hask
ell
program,
in
to
libraries
where
they
can
b
e
loaded
on
demand,
This
do
cumen
t
describ
es
the
issues
in
v
olv
ed
in
the
design
of
the
Hask
ell
libraries
and
summarises
the
library
mo
dules
b
eing
considered.

Motiv
ation
In
the
v
e
y
ears
since
the
Hask
ell
programming
language
w
as
created,
Hask
ell
programmers
ha
v
e
dev
elop
ed
libraries
pro
viding
man
y
useful
functions
and
datat
yp
es.
Eac
h
implemen-
tation
of
Hask
ell
curren
tly
distributes
home
gro
wn
libraries.
Using
these
libraries
sp
eeds
dev
elopmen
t
but
decreases
p
ortabilit
y
b
ecause
these
libraries
are
not
a
v
ailable
on
all
plat-
forms.
W
e
b
eliev
e
that
man
y
of
the
functions
and
t
yp
es
in
these
libraries
should
b
ecome
a
standardised
part
of
Hask
ell
.
(with
further
libraries
b
eing
added
in
later
revisions).
Standardising
these
libraries
will:
.
Increase
the
p
o
w
er
of
the
language
b
y
pro
viding
a
m
uc
h
greater
lev
el
of
basic
func-
tionalit
y
in
the
standard.
.
Impro
v
e
the
p
ortabilit
y
of
programs
b
y
eliminating
the
need
for
non-standard
libraries.
.
Av
oid
the
splin
tering
of
Hask
ell
in
to
dieren
t
dialects
where
programmers
familiar
with
the
HBC
libraries
(sa
y)
w
ould
not
b
e
able
to
understand
a
program
written
using
the
GHC
libraries.


The
ma
jor
argumen
t
against
standardising
libraries
is
that
doing
so
increases
the
size
of
language
|
b
oth
the
amoun
t
new
programmers
m
ust
learn
and
the
size
of
implemen
tations.
W
e
feel
that
the
increased
utilit
y
of
the
language
out
w
eighs
this
concern.
The
Hask
ell
language
has
what
is
essen
tially
a
built-in
library
called
the
standard
prelude.
The
prelude
is
sp
ecial
only
in
that
it
is
implicitly
imp
orted
in
to
ev
ery
program.
Mo
ving
the
infrequen
tly-used
comp
onen
ts
of
the
prelude
in
to
libraries
has
t
w
o
adv
an
tages:
it
shrinks
the
core
language,
making
the
essen
tial
comp
onen
ts
of
Hask
ell
more
apparen
t;
and
it
frees
up
more
of
the
namespace
for
the
user.
This
do
cumen
t
describ
es
the
issues
that
arise
in
turning
the
existing
libraries
in
to
a
concrete
library
prop
osal
and
briey
summarises
eac
h
library
.
This
do
cumen
t
do
es
not
discuss
c
hanges
to
the
libraries
or
prelude
whic
h
are
related
to
the
I/O
prop
osal;
these
are
describ
ed
in
Gordon
and
Hammond's
tutorial
pap
er
[
].
Detailed
denitions
of
the
libraries
are
supplied
in
a
companion
do
cumen
t
[
].
Ac
kno
wledgemen
ts
W
e
are
grateful
to
mem
b
ers
of
the
Y
ale,
Glasgo
w
and
Chalmers
functional
programming
groups
(esp
ecially
Sandra
Lo
osemore,
Dan
Rabin,
Will
P
artain,
Jim
Mattson,
Andy
Gill,
Kevin
Hammond
and
Ken
t
Karlsson),
Mark
Jones,
Ian
P
o
ole,
Nic
k
North,
P
aul
Otto
and
the
other
mem
b
ers
of
the
Hask
ell
.
committee
for
detailed
commen
ts
on
the
design
criteria
and
the
design
of
the
libraries.
W
e
are
esp
ecially
grateful
to
the
GRASP/A
QUA
team
at
Glasgo
w
and
to
Lennart
Augusts-
son
at
Chalmers
for
pro
viding
the
basis
on
whic
h
m
uc
h
of
the
library
design
is
built.

Design
Issues
The
main
questions
to
b
e
answ
ered
when
designing
library
mo
dules
are:
What
should
b
e
included?
What
should
go
in
the
libraries
and
what
should
go
in
the
prelude?
What
should
go
in
eac
h
mo
dule?
What
classes
should
eac
h
new
t
yp
e
b
e
an
instance
of
?
What
should
the
t
yp
e
and
name
of
eac
h
function
b
e?
Ho
w
should
library
functions
b
e
dened
in
a
standard?
Ho
w
do
libraries
in
teract
with
other
asp
ects
of
Hask
ell?
W
e
address
eac
h
of
these
questions
in
turn.
.
What
should
b
e
included?
T
o
b
e
included
in
the
standard
libraries,
an
en
tit
y
(t
yp
e,
t
yp
e-class
or
function)
m
ust
satisfy
t
w
o
criteria:


.
It
m
ust
b
e
clear
what
the
in
terface
should
lo
ok
lik
e
|
it
is
m
uc
h
harder
to
remo
v
e
or
correct
a
feature
once
it
has
b
een
included
in
the
language
standard.
.
The
en
tit
y
m
ust
b
e
useful
to
a
\signican
t
n
um
b
er"
of
programmers.
Since
the
standard
libraries
dra
w
hea
vily
on
existing
libraries,
w
e
ha
v
e
some
condence
that
the
in
terfaces
ha
v
e
b
een
tested
in
real
programs.
En
tities
whic
h
cannot
b
e
implemen
ted
ecien
tly
in
standard
Hask
ell
b
ecause
they
require
sp
ecial
supp
ort
in
the
compiler
or
run
time
system
deserv
e
sp
ecial
consideration
since
users
ha
v
e
no
p
ortable
alternativ
e.
Since
the
primary
goal
of
ha
ving
standard
libraries
is
to
impro
v
e
p
ortabilit
y
,
Hask
ell
im-
plemen
tations
are
required
to
pro
vide
all
of
the
standard
libraries
and
are
not
p
ermitted
to
add,
mo
dify
,
or
omit
en
tities.
Implemen
tors
are
encouraged
to
pro
vide
optimised
v
ersions
of
library
functions
pr
ovide
d
that
the
optimise
d
version
has
the
same
external
b
ehaviour
(typ
e,
strictness,
err
or
c
onditions,
etc)
as
in
the
sp
e
cic
ation.
.
What
should
go
in
the
libraries
and
what
should
go
in
the
prelude?
The
only
op
erational
dierence
b
et
w
een
en
tities
dened
in
the
prelude
and
those
dened
in
a
library
is
that
the
prelude
is
automatically
imp
orted
in
to
ev
ery
Hask
ell
mo
dule
whereas
libraries
m
ust
b
e
explicitly
imp
orted.
This
division
in
to
prelude
and
libraries
do
es
not
imply
that
the
libraries
are
optional
(they're
not)
or
that
the
prelude
cannot
imp
ort
library
mo
dules
(it
can).
On
the
other
hand,
en
tities
in
the
prelude
can
b
e
considered
\more
essen
tial"
to
the
language.
Studen
ts
of
Hask
ell
w
ould
b
e
exp
ected
to
learn
ab
out
the
prelude
b
efore
lo
oking
in
to
the
libraries.
It
is
sligh
tly
more
con
v
enien
t
to
use
en
tities
from
the
standard
prelude
than
from
a
library
.
But,
eac
h
en
tit
y
placed
in
the
prelude
\steals"
a
p
oten
tially
useful
name
from
programmers.
T
o
a
v
oid
name
clashes,
programmers
m
ust
giv
e
their
o
wn
en
tities
dieren
t
names,
or
use
hiding
or
renaming.
In
order
to
justify
\stealing
a
name"
from
the
user,
eac
h
en
tit
y
in
the
prelude
m
ust
satisfy
one
or
more
of
the
follo
wing
criteria:
.
It
is
v
ery
hea
vily
used
b
y
all
programmers.
F
or
example,
the
existing
functions
map
and
show
are
so
hea
vily
used
that
programmers
are
unlik
ely
to
use
the
name
for
an
y
other
purp
ose.
.
It
o
ccurs
in
in
tro
ductory
functional
programming
courses/textb
o
oks.
F
or
example,
interact
is
not
hea
vily
used
in
large
programs
but
including
it
in
the
prelude
a
v
oids
or
dela
ys
the
need
to
teac
h
studen
ts
ab
out
Hask
ell's
mo
dule
system.
Exp
erience
with
Hask
ell
.
suggests
that
arra
ys,
rational
n
um
b
ers
and
complex
n
um
b
ers
are
not
used
hea
vily
enough
to
justify
their
inclusion
in
the
prelude.
Therefore
PreludeArray,
PreludeRatio
and
PreludeComplex
will
b
e
libraries
in
Hask
ell
..
Similarly
,
the
functions
ord,
chr,
isControl,
isPrint,
etc.
in
the
mo
dule
Prelude
are
rarely
used
and
will
b
e
mo
v
ed
to
mo
dule
LibCharType.


.
What
should
go
in
eac
h
mo
dule?
Eac
h
library
mo
dule
comprises
one
of:
.
A
single
(abstract)
data
t
yp
e.
(Or
a
family
of
t
yp
es
and
corresp
onding
t
yp
e
class
in
the
case
of
LibWord.)
.
A
single
t
yp
e
class.
.
A
set
of
closely
related
utilit
y
functions.
F
or
example,
op
erations
on
lists
are
divided
in
to
mo
dules
LibLength,
LibDuplicates,
LibScan,
LibSubsequences,
etc.
rather
then
b
eing
group
ed
in
to
a
single
mo
dule.
Our
goal
is
to
k
eep
libraries
small
and
self-con
tained
so
that
programmers
can
imp
ort
those
functions
they
need
without
imp
orting
man
y
functions
they
don't
need.
.
What
classes
should
eac
h
new
t
yp
e
b
e
an
instance
of
?
In
Hask
ell
.,
an
instance
of
a
class
m
ust
b
e
dened
in
either
the
mo
dule
that
denes
the
class
or
in
the
mo
dule
that
denes
the
instance.
This
rule
mak
es
it
imp
ossible
for
the
programmer
to
add
an
instance
if
it
has
b
een
omitted
from
the
prelude
or
libraries.
Therefore
care
m
ust
b
e
tak
en
to
dene
ev
ery
p
ossible
instance
of
ev
ery
p
ossible
class
to
a
v
oid
lea
ving
the
programmer
high
and
dry
.
A
t
the
time
of
writing,
it
seems
lik
ely
that
this
rule
will
b
e
relaxed
in
Hask
ell
.
to
allo
w
a
giv
en
instance
to
b
e
dened
an
ywhere
in
the
program
|
pro
vided
there
is
at
most
one
instance.
Nev
ertheless,
it
is
imp
ortan
t
to
pro
vide
ev
ery
p
ossible
instance
for
all
abstract
data
t
yp
es
|
and
most
reasonable
instances
for
all
other
t
yp
es.
The
question
of
where
to
dene
an
instance
is
also
imp
ortan
t.
If
instances
are
dened
in
the
mo
dules
that
denes
the
classes,
imp
orting
a
class
migh
t
cause
a
large
amoun
t
of
un
w
an
ted
co
de
(asso
ciated
with
t
yp
es
that
the
programmer
is
not
using)
to
come
in
to
scop
e.
If
instances
are
dened
in
the
mo
dules
that
dene
the
t
yp
es,
imp
orting
a
t
yp
e
migh
t
cause
a
large
n
um
b
er
of
un
w
an
ted
co
de
(asso
ciated
with
classes
the
programmer
is
not
using)
to
come
in
to
scop
e.
Both
seem
to
result
in
a
v
ery
cluttered
name
space
and
large
compiled
programs.
W
e
don't
ha
v
e
a
go
o
d
solution
at
the
momen
t.
.
What
should
the
t
yp
e
and
name
of
eac
h
function
b
e?
The
primary
goal
in
c
ho
osing
names
is
that
it
should
b
e
p
ossible
to
guess
the
purp
ose
of
a
function
from
its
name
and
t
yp
e
signature.
In
some
cases
it
ma
y
b
e
appropriate
to
c
hange
the
names
of
existing
prelude
functions
to
ac
hiev
e
this
goal
(e.g.
a
b
etter
name
for
null
w
ould
b
e
isEmpty).
Secondary
considerations
include:


.
Consistency
with
the
existing
Hask
ell
prelude.
F
or
example,
mo
dules
LibSet,
LibBag
and
LibFiniteMap
all
pro
vide
a
function
anal-
ogous
to
the
prelude
function
filter
to
\select"
v
alues
from
a
collection.
W
e
use
the
names
filterSet,
filterBag
and
filterFM
for
these
functions.
.
Consistency
b
et
w
een
dieren
t
libraries.
F
or
example,
mo
dules
LibSet,
LibBag
and
LibFiniteMap
all
pro
vide
a
function
to
com
bine
sets,
bags
or
datat
yp
es
(resp
ectiv
ely).
W
e
use
similar
names
(unionSet,
unionBag
and
unionFM)
for
all
three
functions.
A
t
the
time
of
writing,
it
seems
lik
ely
that
Hask
ell
.
will
pro
vide
a
form
of
\qualied
names"
allo
wing
one
to
imp
ort
sev
eral
en
tities
with
the
same
name
and
using
the
mo
dule
name
as
a
qualier
to
resolv
e
an
y
am
biguit
y
.
If
this
prop
osal
is
adopted,
b
oth
the
Lib
prexes
on
the
mo
dule
names
and
the
t
yp
e
suxes
on
the
function
names
w
ould
b
e
dropp
ed
|
the
functions
b
eing
called
Set.union,
Bag.union
and
FiniteMap.union
resp
ectiv
ely
.
.
Consistency
with
the
existing
Hask
ell
naming
con
v
en
tions.
F
or
example,
iden
tiers
formed
b
y
the
concatenation
of
sev
eral
w
ords
use
capitalisa-
tion
rather
than
underscores
to
separate
the
w
ords.
.
W
e
try
to
a
v
oid
using
a
name
if
a
programmer
migh
t
reasonably
use
the
name
for
some
other
purp
ose.
In
a
language
that
encourages
use
of
partial
application
and
allo
ws
an
y
binary
function
to
b
e
used
as
an
inx
op
erator,
it
is
imp
ortan
t
to
consider
p
ossible
uses
of
a
function
when
c
ho
osing
the
order
of
argumen
ts.
F
or
example,
a
function
whic
h
mo
dies
an
ob
ject
of
t
yp
e
T
should
tak
e
this
ob
ject
as
the
last
argumen
t.
Th
us
add
w
ould
ha
v
e
t
yp
e
a
->
Set
a
->
Set
a
instead
of
Set
a
->
a
->
Set
a.
.
Ho
w
should
library
functions
b
e
dened
in
a
standard?
With
the
exception
of
primitiv
e
arithmetic
and
I/O-related
functions,
all
functions
in
the
Hask
ell
.
prelude
are
describ
ed
in
English
in
the
b
o
dy
of
the
rep
ort
and
dened
in
Hask
ell
in
an
app
endix.
Pro
viding
a
Hask
ell
denition
a
v
oids
am
biguit
y
but
can
b
e
v
ery
v
erb
ose
and
hard
to
understand
(see,
for
example,
PreludeText).
F
or
some
functions,
w
e
migh
t
wish
to
b
e
delib
erately
am
biguous:
all
a
programmer
needs
to
kno
w
ab
out
a
sort
function
is
whether
it
is
stable
and
for
whic
h
inputs
it
b
eha
v
es
ecien
tly
|
details
ab
out
the
c
hoice
of
algorithm
are
b
est
left
to
the
implemen
tor.
F
or
these
functions,
it
is
more
appropriate
to
pro
vide
an
English
description
of
the
function
bac
k
ed
up
b
y
mathematical
iden
tities,
error
conditions
and
strictness
prop
erties
as
appropriate.
F
or
all
other
functions
(i.e.,
those
simple
enough
that
they
are
b
est
sp
ecied
in
Hask
ell),
the
required
seman
tics
is
precisely
that
of
the
denition
|
implemen
tors
are
not
free
to


c
hange
the
seman
tics
to
impro
v
e
p
erformance.

Some
t
yp
es
suc
h
bitsets
and
random
states
w
e
wish
to
lea
v
e
the
implemen
tor
free
to
c
ho
ose
an
ecien
t
represen
tation
but
wish
to
constrain
the
b
eha
viour
sucien
tly
to
guaran
tee
p
ortabilit
y
.
In
these
cases,
a
reference
implemen
tation
is
pro
vided
in
Hask
ell
but
the
repre-
sen
tation
is
not
exp
orted
from
the
dening
mo
dule.
Dealing
with
the
strictness
prop
erties
of
library
functions
is
a
particular
problem.
In
man
y
cases,
the
strictness
of
a
function
dep
ends
on
the
order
in
whic
h
tests
for
errors
or
sp
ecial
conditions
are
made.
F
or
some
functions,
laziness
is
crucial
to
the
program;
for
others,
it
mak
es
little
dierence.
The
standard
can
either
b
e
v
ery
precise
ab
out
strictness
or
it
can
allo
w
implemen
tations
to
c
ho
ose
whatev
er
strictness
prop
erties
lead
to
the
b
est
implemen
tation.
W
e
prop
ose
to
explicitly
mark
functions
for
whic
h
the
implemen
tation
is
free
to
alter
the
strictness
prop
erties.
Most
of
the
others
can
b
e
dened
in
Hask
ell,
whic
h
precisely
denes
the
strictness.
T
o
a
v
oid
in
tro
ducing
subtle
p
ortabilit
y
problems,
w
e
plan
to
k
eep
the
n
um
b
er
of
functions
with
undened
strictness
prop
erties
as
small
as
p
ossible.
As
in
the
existing
prelude,
implemen
tations
are
free
to
alter
calls
to
the
error
function
in
library
functions.
Error
messages
ma
y
b
e
c
hanged
freely
to
mak
e
them
more
useful.
Library
functions
should
detect
errors
as
early
as
p
ossible
and
rep
ort
them
clearly
.
The
libraries
in
tro
duce
a
n
um
b
er
of
new
t
yp
es
whic
h
are
similar
to
existing
t
yp
es
(e.g.
PackedStrings
are
similar
to
Strings,
FiniteMaps
to
asso
ciation
lists
and
arra
ys,
Sets
to
lists).
The
relationship
b
et
w
een
t
w
o
t
yp
es
can
often
b
e
describ
ed
b
y
a
pair
of
functions
(f
::
U
!
V
;
g
::
V
!
U
)
suc
h
that
g

f
=
id.
By
abuse,
w
e
call
suc
h
pairs
\retraction
pairs"
and
write
(f
;
g
)
:
U
$
V
.
(The
complete
denition
of
\retraction
pairs"
w
ould
require
that
f

g
v
id
for
an
appropriate
c
hoice
of
domain.)
When
a
retraction
pair
exists,
it
is
natural
to
use
the
pair
to
dene
the
seman
tics
of
functions
o
v
er
the
new
t
yp
es
in
terms
of
corresp
onding
functions
o
v
er
the
old
t
yp
es.
F
or
example,
the
retraction
pair
for
pac
k
ed
strings
(unpackPS
;
packString
)
:
PackedString
$
String
can
b
e
used
to
dene
the
functions
headPS
::
PackedString
->
Char
headPS
=
head
.
unpackPS
tailPS
::
PackedString
->
PackedString
tailPS
=
packString
.
tail
.
unpackPS
nullPS
::
PackedString
->
Bool
nullPS
=
null
.
unpackPS
When
accompanied
b
y
a
denition
of
the
comp
osition
unpackPS
.
packString,
this
com-
pletely
sp
ecies
the
required
b
eha
viour
of
these
functions
|
though
one
w
ould
hop
e
for
more
ecien
t
implemen
tations!

Man
y
Hask
ell
compilers
break
this
rule
for
prelude
functions.
Since
this
reduces
p
ortabilit
y
,
w
e
recom-
mend
that
they
pro
vide
a
compiler
option
to
force
the
use
of
a
correct
(but
p
ossibly
slo
w
er)
implemen
tation
|
as
far
as
is
p
ossible.


.
Ho
w
do
libraries
in
teract
with
other
asp
ects
of
Hask
ell?
Although
the
Hask
ell
rep
ort
is
silen
t
on
exactly
ho
w
the
comp
onen
ts
of
a
program
are
gathered
for
compilation,
w
e
exp
ect
that
the
user
should
not
ha
v
e
to
do
an
ything
sp
ecial
to
sp
ecify
the
lo
cation
of
mo
dules
in
the
standard
Hask
ell
library
.
Simply
men
tioning
a
library
name
in
an
import
declaration
ough
t
to
b
e
sucien
t
to
link
the
appropriate
library
in
to
the
Hask
ell
program.
Libraries
ma
y
dene
deriv
able
classes.
The
names
of
suc
h
classes
m
ust
b
e
explicitly
imp
orted
in
to
the
mo
dules
that
dene
t
yp
es
whic
h
deriv
e
them.
It
is
the
resp
onsibilit
y
of
the
compiler
to
correctly
expand
a
deriving
clause
in
v
olving
suc
h
a
class.
It
is
also
p
ossible
that
the
compiler-generated
co
de
for
a
deriving
clause
ma
y
reference
en
tities
dened
in
libraries.
It
it
is
not
necessary
for
the
programmer
to
imp
ort
these
implicitly-referenced
en
tities,
although
the
compiler
m
ust
arrange
for
them
to
b
e
link
ed
in
to
the
resulting
program.

An
Ov
erview
of
the
Prop
osed
Libraries
This
section
summarises
those
libraries
whic
h
will
b
e
included
in
Hask
ell
..
(A
complete
denition
ma
y
b
e
found
in
do
cumen
t
[
].)
W
e
omit
LibCharType
whic
h
pro
vides
c
haracter
op
erations
remo
v
ed
from
Prelude,
and
LibArray,
LibComplex
and
LibRatio
whic
h
are
just
old
prelude
mo
dules
turned
in
to
libraries.
.
Non-o
v
erloaded
prelude
functions
F
unctions
suc
h
as
elem
use
the
Eq
class
to
supply
the
==
op
eration.
There
are
situations
in
whic
h
the
op
eration
dened
b
y
o
v
erloading
is
not
appropriate.
F
or
example,
one
migh
t
wish
to
use
a
case-insensitiv
e
comparison
when
op
erating
on
strings.
It
is
straigh
tforw
ard
to
dene
v
ersions
of
these
functions
whic
h
are
not
o
v
erloaded
(but
are
p
olymorphic)
b
y
adding
an
extra
argumen
t
whic
h
pro
vides
an
explicit
equalit
y
or
comparison
predicate.
F
or
example,
w
e
ha
v
e
nubBy
::
(a
->
a
->
Bool)
->
[a]
->
[a].
While
it
is
trivial
to
dene
o
v
erloaded
functions
in
terms
of
non-o
v
erloaded
ones,
the
rev
erse
is
not
p
ossible.
The
prelude
pro
vides
sev
eral
functions
whic
h
are
o
v
erloaded
with
resp
ect
to
Eq
and
Ord:
nub,
elem,
notElem,
min,
max,
maximum,
minimum
and
(nn).
Rather
than
creating
a
mo
dule
con
taining
a
random
assortmen
t
of
suc
h
functions,
w
e
place
the
non-o
v
erloaded
v
ersion
in
the
same
mo
dule
as
the
original
denition.
The
o
v
erloaded
v
ersion
can
b
e
dened
using
the
new
function;
for
example,
nub
can
b
e
dened
b
y
nub
=
nubBy
(==).
.
P
ac
k
ed
Strings
Hask
ell
represen
ts
strings
b
y
lists
of
c
haracters.
While
this
in
teracts
w
ell
with
lazy
ev
alua-
tion
and
allo
ws
man
y
prelude
functions
(suc
h
as
map
and
length)
to
b
e
used
on
strings,
t
yp-
ical
Hask
ell
implemen
tations
consume
0{0
b
ytes
p
er
c
haracter
to
represen
t
suc
h
strings.


The
mo
dule
LibPackedString
pro
vides
a
new
t
yp
e
PackedString
whic
h
is
ev
aluated
more
strictly
to
allo
w
a
more
compact
represen
tation
(as
lo
w
as

b
yte
p
er
c
haracter
plus
a
small
constan
t
o
v
erhead).
The
retraction
pair
(unpackPS
;
packString
)
:
PackedString
$
String
is
not
quite
an
isomorphism
since
packString
completely
ev
aluates
its
argumen
t.
These
functions
are
used
to
dene
PackedString
v
ersions
of
the
prelude
constructors
[]
and
(:)
and
the
prelude
functions
head,
tail,
init,
last,
null,
length,
append,
map,
filter,
foldl,
foldr,
take,
drop,
splitAt,
takeWhile,
dropWhile,
span,
break,
lines,
words,
reverse,
concat,
elem
and
(!!).
This
mo
dule
is
based
on
the
PackedString
mo
dule
distributed
with
GHC.
.
List
Op
erations
As
one
of
the
most
hea
vily
used
data
structures
in
Hask
ell,
it
is
not
surprising
that
the
last
v
e
y
ears
use
has
pro
duced
a
host
of
useful
new
functions
o
v
er
lists.
LibSort
This
mo
dule
pro
vides
a
stable
sorting
function
sort
::
Ord
a
=>
[a]
->
[a].
(sortBy
is
also
pro
vided.)
LibDuplicates
This
mo
dule
pro
vides
functions
for
manipulating
lists
with
duplicate
v
alues:
group
::
Eq
a
=>
[a]
->
[[a]]
and
uniq
::
Eq
a
=>
[a]
->
[a]
whic
h
group
together
adjacen
t
equal
elemen
ts
in
a
list
and
eliminate
adjacen
t
equal
elemen
ts.
(The
function
LibSort.sort
can
b
e
used
to
bring
duplicates
together.)
(groupBy
and
uniqBy
are
also
pro
vided.)
LibLength
This
mo
dule
pro
vides
functions
suc
h
as
lengthLe,
lengthEq
::
[a]
->
Int
->
Bool
to
test
the
length
of
a
list
without
ev
aluating
the
en
tire
list.
LibScans
This
mo
dule
pro
vides
unidirectional
and
bidirectional
generalisations
of
fold
and
scan
based
on
functions
pro
vided
in
HBC's
ListUtils
mo
dule,
GHC's
Utils
mo
dule
and
O'Donnell's
pap
er
on
bidirectional
fold
and
scan
[	
].
LibSubsequences
This
mo
dule
pro
vides
functions
to
generate
the
list
of
all
subsequences,
prexes,
suf-
xes
or
p
erm
utations
of
a
list
and
to
test
whether
one
list
is
a
subsequence,
prex,
sux
or
p
erm
utation
of
another
list.
These
are
based
on
functions
dened
b
y
Bird
and
W
adler
[
].


.
Collections
Lists
are
v
ery
hea
vily
used
in
Hask
ell
programs.
Sadly
,
lists
can
b
e
quite
inecien
t
(in
time)
for
storing
large
collections
of
data
and
it
is
p
ossible
to
do
signican
tly
b
etter
using
data
structures
based
on
binary
trees
or
hash
tables.
The
mo
dules
LibBag,
LibSet,
LibFiniteMap
and
LibHashTable
dene
t
yp
es
Bag,
Set,
FiniteMap
and
HashTable,
retraction
pairs
relating
them
to
lists
or
asso
ciation
lists
and
functions
o
v
er
these
t
yp
es
(mostly
based
on
prelude
functions
o
v
er
lists
and
arra
ys).
Bag

The
t
yp
e
Bag

is
isomorphic
to
[]
but
pro
vides
constan
t
time
app
ending
and
con-
catenation
functions
and
logarithmic
time
head
and
last
functions.
The
retraction
pair
for
bags
(toList
;
fromList
)
:
Bag

$
[]
forms
an
isomorphism.
That
is
toList
.
fromList
=
id
Set

The
t
yp
e
Set
represen
ts
(ordered)
collections
with
no
duplicates.
The
retraction
pair
for
sets
(toList
;
fromList
)
:
Ord

)
Set

$
[]
satises
the
iden
tit
y
toList
.
fromList
=
uniq
.
sort
FiniteMap


and
HashTable


The
t
yp
es
FiniteMap


and
HashTable


represen
t
lo
okup
tables
with
k
eys
of
t
yp
e

and
elemen
ts
of
t
yp
e

.
FiniteMaps
b
eha
v
e
lik
e
balanced
binary
trees
(logarithmic
access
time
and
insertion
time)
and
HashTables
b
eha
v
e
lik
e
(functional)
hash
tables
(near-constan
t
access
time
and
linear
insertion
time).
The
retraction
pair
for
nite
maps
(toList
;
fromList
)
:
Ord

)
FiniteMap


$
[(;

)]
satises
the
iden
tit
y
toList
.
fromList
=
uniqBy
eq
.
sortBy
cmp
where
(x,_)
`cmp`
(y,_)
=
x
<=
y
(x,_)
`eq`
(y,_)
=
x
==
y
Hash
tables
require
a
new
t
yp
e
class
Hashable.
The
follo
wing
la
ws
are
satised
b
y
the
retraction
pair
for
hash
tables
(toList
;
fromList
)
:
Hashable

)
HashTable


$
[(;

)]
map
fst
xs
`isPermutationOf`
map
fst
(toList
(fromList
xs))
lookup
xs
=
lookup
(toList
(fromList
xs))
	

All
four
mo
dules
pro
vide
functions
corresp
onding
to
the
prelude
constructors
[]
and
(:)
and
of
the
prelude
functions
++,
nn,
length,
genericLength,
map,
partition,
filter,
foldl
and
foldr.
LibSet
and
LibBag
also
pro
vide
v
ersions
of
elem
and
notElem;
LibBag
pro
vides
v
ersions
of
head,
tail,
init,
last,
(!!)
and
reverse;
and
LibFiniteMap
and
LibHashTable
pro
vides
v
ersions
of
indices,
elems,
accum,
(//),
(!),
amap
and
ixmap.
(All
functions
are
dened
using
the
retraction
pairs.)
The
mo
dule
LibHash
is
pro
vided
to
help
supp
ort
LibHashTable.
It
pro
vides
a
new
abstract
t
yp
e
Hash,
a
new
t
yp
e
class
Hashable
dening
a
metho
d
hash
::
Hashable
a
=>
a
->
Hash
and
instances
for
Hask
ell's
primitiv
e
t
yp
es
(e.g.,
Int,
Integer).
Instances
of
Hashable
ma
y
b
e
deriv
ed.
Mo
dules
LibBag,
LibSet
and
LibFiniteMap
are
based
on
mo
dules
distributed
with
GHC;
LibHash
is
lo
osely
based
on
a
mo
dule
distributed
with
HBC
(the
t
yp
e
Hash
is
just
Int
in
the
HBC
v
ersion.)
.
Monads
Since
their
rst
use
in
pure
functional
programming
[
],
monads
ha
v
e
rev
olutionised
the
w
a
y
programmers
p
erform
input/output,
up
date-in-place,
parsing,
exception
handling
and
man
y
other
tasks.
If
constructor
classes
[
]
are
added
to
Hask
ell
.,
it
w
ould
b
e
p
ossible
to
dene
construc-
tor
classes
represen
ting
monads,
monads
with
a
zero
elemen
t
and
monads
with
a
c
hoice
op
erator.
Suc
h
classes
could
b
e
dened
in
a
library
but
are
sucien
tly
imp
ortan
t
to
jus-
tify
their
addition
to
the
prelude.
Instances
w
ould
include
lists,
Maybe,
Either,
IO
and
Parser.
There
are
a
n
um
b
er
of
useful
monadic
functions
whic
h
can
b
e
dened
using
these
op
erations.
The
curren
t
in
terface
is
based
on
monads
used
within
GHC
and
on
examples
distributed
with
Gofer.
.
Mutable
Structures
P
eyton
Jones,
W
adler
and
Launc
h
bury
[,
]
describ
e
ho
w
monads
ma
y
b
e
used
to
pro
vide
m
utable
v
ariables
and
m
utable
arra
ys
without
losing
referen
tial
transparency
.
The
mo
dule
LibMutable
pro
vides
b
oth
m
utable
v
ariables
and
m
utable
arra
ys.
The
ma
jor
unresolv
ed
question
is
whether
the
op
erations
to
create,
read
and
write
m
utable
structures
should
b
e
part
of
the
IO
monad,
part
of
a
state
thread
monad
or
whether
the
IO
monad
should
b
e
an
instance
of
state
thread
monads
as
in
P
eyton
Jones
and
Launc
h
bury's
elegan
t
lazy
state
threads
pap
er
[
].
The
problem
is
that
their
approac
h
requires
the
addition
of
a
new
language
construct
runST
with
sp
ecial
t
yp
e-c
hec
king
rules.
It
is
not
y
et
clear
whether
the
extra
p
o
w
er
justies
complicating
the
language.
This
mo
dule
is
based
on
the
PreludeGlaST
mo
dule
distributed
with
GHC.
0

.
Prin
ting
and
P
arsing
The
prelude
pro
vides
the
Text
class
for
prin
ting
and
parsing
v
alues.
Deriv
ed
metho
ds
ha
v
e
the
desirable
prop
ert
y
that
read
.
show
=
id
(for
non-functions
and
ignoring
strictness).
Ho
w
ev
er,
the
output
from
show
can
b
e
rather
ugly
and
it
is
a
wkw
ard
to
construct
go
o
d
parsers
using
read.
The
mo
dule
LibPretty
pro
vides
a
new
abstract
t
yp
e
Pretty
represen
ting
a
prett
y-prin
ted
blo
c
k
of
text
and
functions
for
com
bining
v
alues
of
t
yp
e
Pretty
in
v
arious
w
a
ys
useful
when
prin
ting
programs
and
data
structures.
The
curren
t
in
terface
is
based
on
Hughes'
prett
y-prin
ting
library
as
distributed
with
HBC
and
GHC.
The
mo
dule
LibParse
pro
vides
a
new
abstract
t
yp
e
Parser


of
bac
ktrac
king
recursiv
e-
descen
t
parsers
whic
h
consume
a
tok
en
stream
of
t
yp
e

and
pro
duces
\parse
trees"
of
t
yp
e

.
The
curren
t
in
terface
is
based
on
Hutton's
parsing
library
[
]
as
distributed
with
HBC.
.
Binary
Files
The
class
Text
pro
vides
a
limited
form
of
p
ersistence:
most
built
in
and
user-dened
t
yp
es
can
b
e
prin
ted
to
text
les
and
subsequen
tly
read
bac
k
in.
Ho
w
ev
er,
the
pro
cess
of
con-
v
erting
v
alues
to
strings
and
using
a
bac
ktrac
king
lexer
and
parser
to
read
them
bac
k
in
is
notoriously
inecien
t.
Hask
ell
.
pro
vided
the
Bin
datat
yp
e
and
the
Binary
t
yp
e
class
for
ecien
tly
writing
v
alues
to
les
in
a
more
concise
(implemen
tation-sp
ecic)
manner.
This
feature
of
Hask
ell
.
w
as
essen
tial
to
some
programs
but
rarely
used
and
so
is
b
eing
mo
v
ed
in
to
a
library
.
A
t
the
same
time,
the
adoption
of
monadic
I/O
mak
es
it
p
ossible
to
pro
vide
op
erations
to
read
and
write
v
alues
to
a
binary
le
directly
|
eliminating
the
need
to
create
an
in
termediate
Bin
v
alue.
T
o
ensure
p
ortabilit
y
of
generated
les,
the
sp
ecication
of
this
mo
dule
should
dene
the
precise
external
represen
tation
for
eac
h
datat
yp
e
in
class
Binary.
Some
care
is
required
to
a
v
oid
o
v
erly
restricting
the
p
ossible
range
of
certain
datat
yp
es
suc
h
as
Int
and
Float.
Instances
of
Binary
ma
y
b
e
deriv
ed.
The
curren
t
in
terface
is
based
on
the
Nativ
e
mo
dule
distributed
with
HBC
with
extensions
based
on
the
curren
t
Y
ale
implemen
tation.
.	
Random
Num
b
ers
and
Splittable
Supplies
While
functional
programming
languages
are
v
alued
b
ecause
their
results
are
deterministic
and
easy
to
predict,
man
y
kinds
of
programs
suc
h
as
sim
ulations
and
games
need
to
app
ear
non-deterministic
|
they
need
a
supply
of
random
n
um
b
ers.
The
mo
dule
LibRandom
pro
vides
a
new
abstract
t
yp
e:
RandomState
together
with
a
function
nextRandomState
::
RandomState
->
RandomState;
and
a
new
t
yp
e
class
Random
whic
h
pro
vides
a
metho
d
fromRandomState
::
Random
a
=>
RandomState
->
a.
There
are
also
functions
for
initialising
random
states,
and
generating
lists
of
random
v
alues
and
Text
and
Binary
instances
for
reading
and
writing
random
states
to
les.


Although
the
t
yp
e
RandomState
is
abstract,
the
denition
will
precisely
sp
ecify
the
algo-
rithm
used
to
generate
random
n
um
b
ers
to
ensure
consisten
t
results
across
all
implemen
ta-
tions.
The
curren
t
in
terface
and
seman
tics
is
lo
osely
based
on
the
random
n
um
b
er
op
erations
in
Common
Lisp.
The
mo
dule
LibSupply
pro
vides
a
new
abstract
t
yp
e
Supply

whic
h
represen
ts
a
splittable
supply
of
v
alues
of
t
yp
e
.
This
mo
dule
is
included
to
supp
ort
supplies
of
random
n
um
b
ers
but
has
also
pro
v
ed
useful
within
compilers.
The
curren
t
in
terface
is
based
on
Augustsson,
Rittri
and
Synek's
splittable
supply
library
[
]
as
distributed
with
HBC.
The
price
paid
for
an
ecien
t
splittable
supply
implemen
tation
is
that
programs
using
the
splittable
supply
mo
dule
migh
t
pro
duce
dieren
t
results
when
compiled
with
dier-
en
t
compilers,
with
dieren
t
optimisation
options
or
ev
en
after
small
seman
tics-preserving
c
hanges
to
the
program.
In
practice,
this
do
es
not
presen
t
an
y
problems.
F
or
example,
in
a
t
yp
e-c
hec
k
er,
it
is
imp
ortan
t
to
ha
v
e
an
ecien
t
supply
of
distinct
t
yp
e
v
ariables
but
it
is
irrelev
an
t
where
eac
h
t
yp
e
v
ariable
is
used.
.0
BitSets
Bit
wise
op
erations
are
useful
for
t
w
o
purp
oses:
)
they
pro
vide
fast,
compact
op
erations
on
sets
of
small
in
tegers;
and
)
they
are
useful
in
comm
unicating
with
hardw
are
devices,
net
w
ork
proto
cols,
etc.
The
mo
dule
LibBitSet
pro
vides
t
yp
es
Word,
Word,
Word,
Word,
Word
and
Word
(un
b
ounded
w
ords)
and
a
t
yp
e
class
BitSet
whic
h
pro
vides
the
usual
bit-manipulation
op
erations
(including
b
oth
arithmetic
and
logical
shifting
op
erations).
The
new
t
yp
es
are
instances
of
Integral
(and
all
sup
erclasses);
negativ
e
n
um
b
ers
are
in
terpreted
as
though
they
are
represen
ted
in
t
w
o's-complemen
t
notation.
The
curren
t
in
terface
is
lo
osely
based
on
the
Common
Lisp
logical
op
erations
[
]
and
the
Word
library
distributed
with
HBC.
.
F
uture
W
ork
There
is
a
considerable
amoun
t
of
w
ork
ahead
designing
the
exact
in
terface
to
these
mo
dules,
dening
the
precise
seman
tics
of
these
op
erations
and
do
cumen
ting
the
resulting
mo
dules.
W
e
are
also
considering
libraries
to
supp
ort
matrix
op
erations,
regular
expressions,
Hughes'
lazy
memo
functions
[
],
Johnsson's
lazy
arra
ys,
the
language
indep
enden
t
arithmetic
stan-
dard
[0
]
and
the
X
graphics
proto
col.
References
[]
L
Augustsson,
M
Rittri,
and
D
Synek.
On
generating
unique
names.
Journal
of
F
unctional
Pr
o
gr
amming,
():{,
Jan
uary
		.


[]
RS
Bird
and
PL
W
adler.
Intr
o
duction
to
F
unctional
Pr
o
gr
amming.
Pren
tice-Hall,
	.
[]
AD
Gordon
and
K
Hammond.
Monadic
I/O
in
Hask
ell.
In
Pr
o
c
e
e
dings
of
Haskel
l
Workshop,
June
		.
[]
John
Hughes.
Lazy
memo-functions.
In
F
unctional
Pr
o
gr
amming
and
Computer
A
r-
chite
ctur
e,
pages
	{,
Septem
b
er
	.
[]
G
Hutton.
Higher-order
functions
for
parsing.
Journal
of
F
unctional
Pr
o
gr
amming,
():{,
July
		.
[]
MP
Jones.
A
system
of
constructor
classes:
o
v
erloading
and
implicit
higher-order
p
olymorphism.
In
F
unctional
Pr
o
gr
amming
and
Computer
A
r
chite
ctur
e,
		.
[]
SL
P
eyton
Jones
and
PL
W
adler.
Imp
erativ
e
functional
programming.
In
Principles
of
Pr
o
gr
amming
L
anguages,
pages
{.
A
CM,
Jan
uary
		.
[]
J
Launc
h
bury
and
SL
P
eyton
Jones.
Lazy
functional
state
threads.
In
Pr
o
gr
amming
L
anguages
Design
and
Implementation,
		.
[	]
JT
O'Donnell.
Bidirectional
fold
and
scan.
In
Dr
aft
Pr
o
c
e
e
dings
of
Glasgow
F
unctional
Pr
o
gr
amming
Workshop,
pages
XX
{
XX.
Glasgo
w
F
unctional
Programming
Group,
July
		.
[0]
M
P
a
yne,
C
Sc
haert,
and
BA
Wic
hmann.
The
language
compatible
arithmetic
stan-
dard.
A
CM
SIGPLAN
Notic
es,
():	{,
Jan
uary
		0.
[]
AD
Reid
and
JC
P
eterson.
A
prop
osal
for
the
standard
Hask
ell
libraries.
		.
In
preparation
for
distribution
at
Hask
ell
W
orkshop.
[]
GL
Steele.
Common
Lisp
|
The
L
anguage.
Digital
Press,
nd
edition,
		.
[]
PL
W
adler.
Comprehending
monads.
In
Pr
o
c
A
CM
Confer
enc
e
on
Lisp
and
F
unctional
Pr
o
gr
amming,
Nic
e.
A
CM,
June
		0.


