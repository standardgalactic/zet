Protot
yping
Real-Time
Vision
Systems:
An
Exp
erimen
t
in
DSL
Design
Alastair
Reid,
John
P
eterson,
Greg
Hager,
P
aul
Hudak
Y
ale
Univ
ersit
y
P
.O
Bo
x
0
New
Ha
v
en,
CT
00
(0)
-
freid-alastair,
p
eterson-john,
hager-greg,
h
udak-paulg@cs.y
ale.edu
ABSTRA
CT
W
e
describ
e
the
transformation
of
XVision,
a
large
library
of
C
+
+
co
de
for
real-time
vision
pro
cessing,
in
to
FVision
(pronounced
\ssion"),
a
fully-featured
domain-sp
ecic
language
em
b
edded
in
Hask
ell.
The
re-
sulting
protot
yp
e
system
substan
tiates
the
claims
of
in-
creased
mo
dularit
y
,
eectiv
e
co
de
reuse,
and
rapid
pro-
tot
yping
that
c
haracterize
the
DSL
approac
h
to
system
design.
It
also
illustrates
the
need
for
judicious
in
ter-
face
design:
relegating
computationally
exp
ensiv
e
tasks
to
XVision
(pre-existing
C
+
+
comp
onen
ts),
and
lea
v-
ing
mo
dular
comp
ositional
tasks
to
FVision
(Hask
ell).
A
t
the
same
time,
our
exp
erience
demonstrates
ho
w
Hask
ell's
adv
anced
language
features
(sp
ecically
para-
metric
p
olymorphism,
lazy
ev
aluation,
higher
order
functions
and
automatic
storage
reclamation)
p
ermit
a
rapid
DSL
design
that
is
itself
highly
mo
dular
and
easily
mo
died.
Ov
erall,
the
resulting
h
ybrid
system
exceeded
our
exp
ectations:
visual
trac
king
programs
con
tin
ue
to
sp
end
most
of
their
time
executing
lo
w
lev
el
image-
pro
cessing
co
de,
while
Hask
ell's
adv
anced
features
allo
w
us
to
quic
kly
dev
elop
and
test
small
protot
yp
e
systems
within
a
matter
of
a
few
da
ys
and
to
dev
elop
realistic
applications
within
a
few
w
eeks.
Keyw
ords
Domain-sp
ecic
languages,
F
unctional
programming,
Mo
dularit
y
,
Co
de
reuse,
Computer
vision,
Hask
ell,
In-
terop
erabilit
y
.

INTR
ODUCTION
Real-time
computer
vision
is
an
area
that
is
at
a
criti-
cal
juncture.
Inexp
ensiv
e
cameras,
digitizers,
and
high-
p
erformance
video
devices
are
no
w
plen
tiful,
and
the
pro
cessing
p
o
w
er
of
most
PC's
and
w
orkstations
has
reac
hed
the
p
oin
t
where
they
can
p
erform
man
y
image
pro
cessing
functions
whic
h
historically
required
sp
ecial-
ized
hardw
are
[].
Soft
w
are
exploiting
vision
has
not,
ho
w
ev
er,
adv
anced
at
a
comparable
rate.
W
e
assert
that
this
is
not
due
to
a
lac
k
of
algorithms
or
comput-
ing
p
o
w
er,
but
rather
that
little
is
y
et
kno
wn
ab
out
the
eectiv
e
soft
w
are
abstractions
and
to
ols
in
this
domain.
There
ha
v
e
b
een
sev
eral
attempts
to
build
general-
purp
ose
image
pro
cessing
libraries
[
,

,

].
Most
ha
v
e
tak
en
a
traditional
approac
h
to
system
design
us-
ing
a
language
suc
h
as
C
+
+
or
Ja
v
a
is
to
build
suitable
libraries,
based
on
w
ell
designed
in
terfaces,
that
cap-
ture
system
functionalit
y
in
a
mo
dular
w
a
y
.
XVision
is
suc
h
a
library
designed
for
a
sp
ecialized
subset
of
real-time
computer
vision
tasks,
in
particular
real-time
trac
king.
The
in
terfaces
w
ere
designed
with
the
usual
trade-os
of
p
erformance
and
functionalit
y
,
and
man
y
successful
vision
applications

ha
v
e
b
een
built
using
it.
Y
et
ev
en
with
XVision,
building
an
application
is
not
al-
w
a
ys
easy
.
There
is
often
a
need
for
b
etter
comp
osition
and
abstraction
facilities
than
exist
in
the
curren
t
v
er-
sion.
F
urthermore,
programmer
pro
ductivit
y
is
a
partic-
ular
problem:
the
b
est
w
a
y
of
constructing
a
particular
vision
system
is
often
found
only
b
y
extensiv
e
protot
yp-
ing,
com
bining
elemen
ts
from
a
v
ariet
y
of
tec
hniques.
Th
us,
the
traditional
programming/debugging/testing
cycle
is
quite
long.
It
is
further
hamp
ered
b
y
the
fact
that
it
is
often
dicult
to
determine
whether
a
giv
en
system
malfunction
is
due
to
a
programming
error,
or
a
conceptual
problem
with
the
underlying
vision
metho
d-
ology
.
This
has
led
us
to
in
v
estigate
Domain-sp
e
cic
lan-
guages
(DSLs)
as
a
w
a
y
of
augmen
ting
our
existing
li-
braries
with
the
comp
osition
and
abstraction
mec
ha-
nisms
needed
in
this
eld,
and
to
giv
e
us
stronger
guar-
an
tees
ab
out
program
correctness.
With
the
DSL
ap-
proac
h,
a
sp
ecial
purp
ose
language
is
dev
elop
ed
to
pro-
vide
just
the
righ
t
glue
and
abstraction
mec
hanisms
to
mak
e
comp
osition
and
parameterization
easy
and
nat-
ural
for
the
domain
of
in
terest.
In
this
pap
er
w
e
describ
e
our
exp
eriences
designing
and
implemen
ting
a
DSL
called
FVision,
using
XVision
as

Information
on
XVision
can
b
e
found
at
http://www.cs.yale.edu
/use
rs/
hage
r.
T
o
date,
it
has
b
een
do
wnloaded
b
y
o
v
er
00
sites.

the
source
of
primitiv
e
op
erations.
Although
designing
and
implemen
ting
a
DSL
can
itself
b
e
a
dicult
task
(language
design
is
dicult!),
w
e
a
v
oided
this
problem
b
y
building
FVision
as
an
emb
e
dde
d
DSL
in
the
func-
tional
language
Haskel
l.
FVision
programs
are
p
erfectly
v
alid
Hask
ell
programs,
but
certain
syn
tactic,
static,
and
dynamic
language
features
in
Hask
ell
giv
e
FVision
the
lo
ok
and
feel
of
an
en
tirely
new
language.
Just
the
pro
cess
alone
of
designing
FVision
claried
what
the
primitiv
e
op
erations
should
b
e,
and
resulted
in
a
stream-lining
of
the
XVision
libraries
to
yield
only
its
essence.
Ho
w
ev
er,
in
addition
system
oers
sev
eral
practical
adv
an
tages
including:

Flexibilit
y
.
The
abilit
y
to
quic
kly
exp
erimen
t
with
and
ev
aluate
a
large
v
ariet
y
of
solutions
is
a
nec-
essary
pro
cess
when
building
complex
vision-based
systems.

Mo
dularit
y
and
abstraction.
Programming
ab-
stractions
are
designed
whic
h
are
natural
to
the
domain,
but
whic
h
are
not
feasible
in
the
curren
t
tec
hnology
of
Ja
v
a
or
C
+
+
programming.
The
re-
sulting
clarit
y
and
compactness
mak
es
explicit
v
ar-
ious
ideas
that
are
left
implicit
in
most
vision
sys-
tems,
and
facilitates
the
description
of
the
underly-
ing
algorithms
in
a
concise
and
seman
tically
clear
fashion.

Eciency
.
The
lo
w-lev
el
op
erations
whic
h
domi-
nate
execution
time
remain
in
the
C
+
+
domain.
The
FVision
glue
is
often
not
a
signican
t
part
of
the
execution
time.

Safet
y
.
The
FVision
t
yp
e
system
ensures
that
mo
d-
ules
are
comp
osed
reliably;
w
e
a
v
oid
using
dynamic
t
yping
or
other
tec
hniques
that
ma
y
fail
at
execu-
tion
time.
This
pap
er
pro
vides
an
o
v
erview
of
the
FVision
ap-
proac
h
to
computer
vision
and
compares
it
with
XVi-
sion.
W
e
address
tec
hniques
used
to
em
b
ed
a
DSL
in
Hask
ell,
including
transforming
monolithic
C
+
+
com-
p
onen
ts
in
to
highly
parameterized,
purely
functional
Hask
ell
ob
jects.
T
o
ac
hiev
e
this
w
e
rely
critically
on
Hask
ell's
parametric
p
olymorphism,
lazy
ev
aluation,
higher
order
functions,
t
yp
e
classes,
and
garbage
col-
lection.
Finally
,
w
e
ev
aluate
our
approac
h,
comparing
program
dev
elopmen
t
using
FVision
to
that
using
XVi-
sion.
Our
w
ork
sho
ws
that
constructing
an
eectiv
e
DSL
from
an
existing
library
is
not
a
matter
of
simply
\turning
the
crank,"
but
rather
requires
a
signican
t
re-engineering
eort
to
ac
hiev
e
an
eectiv
e
domain-sp
ecic
language.
The
pro
v
en
b
enets
of
the
DSL,
though,
mak
e
this
eort
w
orth
while.

THE
DOMAIN:
REAL-TIME
VISION
XVision
is
an
application
and
hardw
are-indep
enden
t
set
of
to
ols
for
visual
feature
trac
king.
Conceptually
,
XVi-
sion
can
b
e
view
ed
as
the
in
v
erse
of
an
animation
sys-
tem.
Whereas
in
animation
the
goal
is
to
quic
kly
com-
bine
a
set
of
graphics
primitiv
es
in
to
an
\animator"
that
pro
duces
a
desired
video
output
stream,
in
XVision
the
goal
is
to
com
bine
visual
trac
king
primitiv
es
and
mo-
tion
constrain
ts
in
to
an
an
\observ
er"
for
a
video
input
stream.
The
existing
XVision
system
libraries
consist
of
appro
x-
imately
,000
lines
of
C
+
+
co
de
organized
as
sho
wn
in
Figure
.
In
particular,
XVision
denes
generic
in
ter-
faces
to
hardw
are
comp
onen
ts
(video
sources
and
dis-
pla
ys),
con
tains
a
large
set
of
image
pro
cessing
to
ols,
and
denes
a
generic
notion
of
a
\trac
k
able
feature."
Using
this
as
a
basis,
XVision
then
denes
sev
eral
tr
ack-
ers:
sp
ecialized
mo
dules
that
recognize
and
follo
w
sp
e-
cic
features
in
the
video
image.
XVision
includes
trac
k-
ers
that
follo
w
the
p
osition
of
a
line,
corner,
an
area
of
color,
and
a
v
ariet
y
of
other
similar
image
artifacts.
The
existing
XVision
system
is
organized
around
t
w
o
programming
abstractions.
The
rst
abstraction
is
to
view
eac
h
feature
as
a
state-b
ase
d
ob
ject
and
to
dene
trac
king
as
a
feedbac
k
pro
cess
on
the
state
of
the
fea-
ture.
The
state,
whic
h
usually
consists
of
the
lo
cation
of
the
feature
plus
some
additional
status
information,
consolidates
and
denes
the
information
con
ten
t
of
eac
h
feature
as
a
single
consisten
t
en
tit
y
.
The
notion
of
the
feedbac
k
lo
op
is
imp
ortan
t
as
it
captures
the
idea
that
the
state
of
the
feature
at
the
curren
t
time
is
in
fact
a
small
p
erturbation
on
what
it
w
as
in
the
previous
frame.
Figure

illustrates
this
idea
conceptually
for
the
sp
ecic
case
of
an
SSD
(Sum
of
Squared
Dierence)
trac
king
al-
gorithm
[].
This
algorithm
trac
ks
a
region
b
y
attempt-
ing
to
compute
an
image
motion
and/or
deformation
to
matc
h
the
curren
t
app
earance
of
a
target
to
a
xed
ref-
erence.
The
steps
in
the
algorithm
are:
()
Acquire
and
deform
an
image
based
on
the
previous
state,
()
com-
pute
the
dierence
b
et
w
een
this
image
and
the
reference
image
(the
target),
and
()
p
erform
some
arithmetic
to
determine
what
p
erturbation
to
the
curren
t
state
pa-
rameters
w
ould
cause
the
(deformed)
curren
t
image
to
b
est
matc
h
the
reference.
The
second
ma
jor
abstraction
in
XVision
is
that
of
com
bining
simple
features
to
form
more
complex
trac
k-
ing
systems,
whic
h
result
in
hier
ar
chic
al
c
onstr
aint
net-
works.
Figure

sho
ws
the
feature
net
w
ork
for
a
clo
wn
face
animation
using
SSD
trac
k
ers
as
its
input.
A
t
the
image
lev
el,
SSD
trac
king
primitiv
es
op
erating
on
im-
ages
lo
calize
the
ey
es
and
mouth.
F
or
eac
h
ey
e
and
mouth,
there
are
in
fact
t
w
o
trac
k
ers,
one
for
an
op
en
ey
e
(or
mouth)
and
one
for
a
closed
one.
Status
informa-


FeatureGroup
Point-Type
Line-Type
Blob
SSD
Target
Realizations
Tools
Typing
Line
Tee
Cross
Corner
GILine
Matrix
RVector
CVector
Image
Galileo
IndyCam 
Video
CWindow
XWindow ITFG_101
Interfaces
BaseType
Scalable
BasicFeature
CompFeature
Tracking
Figure
:
Soft
w
are
La
y
out.
model
inverse
acquire
∆position
position
-
reference
image
∫
image
initial
position
Figure
:
Figure
of
XVision
feedbac
k
lo
op.
tion
(essen
tially
ho
w
w
ell
the
reference
image
matc
hes
the
curren
t
image)
determine
the
status
(op
en
or
closed)
of
their
resp
ectiv
e
targets.
Subsequen
t
lev
els
of
the
sys-
tem
com
bine
this
information
in
to
a
consisten
t
represen-
tation
of
the
p
ose
and
status
of
the
face.
The
animation
(frames
of
whic
h
are
sho
wn
at
the
righ
t
of
Figure
)
re-
sults
b
y
\sla
ving"
graphics
dra
wing
primitiv
es
to
the
state
of
eac
h
trac
king
primitiv
e.

FR
OM
XVISION
TO
FVISION
Despite
the
success
of
XVision
as
a
substrate
for
appli-
cation
dev
elopmen
t,
it
w
as
clear
that
the
existing
design
w
as
often
to
o
inexible
for
the
t
yp
e
of
exp
erimen
tal
pro-
gramming
in
v
olv
ed
in
dev
eloping
vision-based
systems.
Th
us,
our
initial
plan
w
as
to
simply
imp
ort
XVision
trac
king
primitiv
es
as
DSL
comp
onen
ts
and
to
capture
only
one
of
the
XVision
abstractions,
hierarc
hical
com-
p
osition,
with
the
DSL.
A
t
this
stage,
w
e
started
to
replicate
the
XVision
C
+
+
ob
ject
hierarc
h
y
in
Hask
ell.
This
fell
short
in
a
n
um
b
er
of
w
a
ys:

The
use
of
sub
classing
to
extend
existing
classes
is
dicult
to
replicate
outside
of
the
C
+
+
t
yp
e
sys-
tem.

The
original
C
+
+
co
de
made
extensiv
e
use
of
im-
plicit
ob
ject
state.
This
led
to
co
de
whic
h
could
not
tak
e
adv
an
tage
of
Hask
ell's
purely
functional
nature.

The
C
+
+
classes
w
ere
v
ery
course-grained:
the
structure
of
the
underlying
algorithms
w
as
hidden
inside
the
classes.
This
prev
en
ted
exp
erimen
tation
with
the
structure
of
the
algorithms.


Region
Region
MultiRegion
Region
Region
MultiRegion
EYE
Region
Region
MultiRegion
EYE
EYES
MOUTH
FACE
Figure
:
(Left)
The
trac
king
net
w
ork
used
for
face
trac
king
as
it
is
dened
in
XVision.
(Righ
t)
The
output
of
the
\clo
wn
face"
trac
k
er.
The
upp
er
ro
w
of
images
sho
ws
the
ra
w
video,
and
the
lo
w
er
ro
w
of
images
sho
ws
the
graphics
pro
duced
b
y
the
trac
k
er
o
v
erlaid
on
to
the
liv
e
video.

The
C
+
+
ob
jects
did
not
tak
e
adv
an
tage
of
Hask
ell's
p
olymorphic
t
yp
e
system.
It
quic
kly
b
ecame
clear
to
us
that
w
e
should
instead
recreate
the
basic
structure
of
the
XVision
trac
k
ers
di-
rectly
in
Hask
ell
instead
of
imp
orting
the
en
tire
trac
k
er
as
a
highly
complex
but
indivisible
blac
k
b
o
x.
In
our
second
attempt,
w
e
imp
orted
the
non-trac
king-sp
ecic
core
comp
onen
ts
of
XVision|namely
the
in
terfaces
to
the
outside
w
orld
and
the
image
pro
cessing
to
ols|and
recreated
in
Hask
ell
m
uc
h
of
what
had
b
een
completely
encapsulated,
monolithic
ob
ject
denitions
in
C
+
+
.
In
particular,
w
e
could
no
w
easily
capture
the
core
abstrac-
tion
of
a
trac
king
cycle
within
the
DSL,
and
thereb
y
exp
erimen
t
with
new
trac
king
algorithms
b
y
using
pro-
gramming
abstractions
ev
en
at
that
lev
el.
Another
impro
v
emen
t
in
this
second
eort
w
as
to
re-
place
the
feedbac
k
lo
ops
previously
hidden
within
the
trac
k
ers
b
y
an
abstraction
dening
a
sequen
tial
set
of
v
alues;
i.e.
a
pip
eline.
This
pip
eline
abstraction
serv
ed
as
a
basis
for
the
translation
in
to
a
m
uc
h
more
idiomatic
and
useful
DSL
v
ersion
of
the
trac
k
ers.
T
o
illustrate
the
a
v
or
of
our
approac
h,
w
e
describ
e
b
elo
w
four
k
ey
parts
of
the
FVision
system
in
detail:
pip
elines,
the
SSD
stepp
er,
the
SSD
tr
acker
and
the
clown
fac
e
demo
describ
ed
in
the
previous
section.
Al-
though
space
limitations
preclude
the
explanation
of
ev-
ery
syn
tactic
detail,
w
e
feel
that
the
examples
in
most
cases
are
self-explanatory
,
whic
h
is
some
indication
of
the
naturalness
of
the
DSL
design.
Pip
elines
Pip
elines
pro
vide
a
de
clar
ative
view
of
the
iterativ
e
lo
ops
used
in
XVision.
Sp
ecically
,
they
allo
w
the
denition
of
iterativ
e
net
w
orks
of
computation
based
on
pure
func-
tions
that
op
erate
on
pip
elines.
These
are
functions
in
the
mathematical
sense
of
the
w
ord:
they
ha
v
e
no
state;
the
result
of
function
application
do
es
not
dep
end
on
ho
w
the
function
has
b
een
used
in
the
past.
Pure
func-
tions
are
an
essen
tial
feature
of
FVision
and
oer
man
y
adv
an
tages
in
a
DSL
framew
ork:

System
sp
ecications,
including
those
for
computer
vision,
are
often
describ
ed
in
mathematical
terms.
T
ranslating
those
sp
ecications
in
to
a
DSL
that
resem
bles
the
domain-sp
ecic
mathematics
is
th
us
relativ
ely
easy
.

An
equally
imp
ortan
t
sp
ecication
metho
d
is
ow
diagr
ams,
suc
h
as
used
in
signal
pro
cessing,
but
these
to
o
are
stateless.
An
y
giv
en
o
w
diagram
(ev
en
ones
with
lo
ops)
can
b
e
con
v
erted
easily
in
to
a
set
of
m
utually
recursiv
e
FVision
equations
(in-
deed,
they
are
isomorphic).

Reasoning
ab
out,
analyzing,
and
transforming
pro-
grams
is
generally
easier
for
programs
that
do
not
rely
on
global
state.

Understanding
comp
onen
ts
based
on
pure
func-
tions
is
easier
since
their
in
terface
to
the
rest
of
the
program
is
explicit
rather
than
implicit.
F
urthermore,
it
is
often
the
case
that
pip
elines
are
con-
ceptually
innite
in
length:
the
Hask
ell
substrate
on
whic
h
FVision
is
built
easily
supp
orts
this
through
lazy
evaluation.
Innite
pip
elines
are
quite
common
in
FVi-
sion
programming,
but
the
user
need
not
w
orry
ab
out
problems
with
termination.


In
FVision,
the
t
yp
e
of
a
\pip
eline"
con
taining
v
alues
of
t
yp
e
T
is
written
Pipe
T.
F
or
example,
the
t
yp
e
Pipe
Float
denotes
a
pip
eline
of
oating
p
oin
t
n
um-
b
ers
and
Pipe
Image
denotes
a
pip
eline
of
images.
Note
that
the
t
yp
e
constructor
Pipe
is
p
olymorphic:
that
is,
eac
h
pip
eline
can
con
tain
a
dieren
t
t
yp
e
of
v
alue.
A
simple
pip
eline
is
written
pipe
[x,y,z]
where
x,
y,
and
z
are
the
elemen
ts
in
the
pip
eline.
The
elemen
ts
m
ust
all
ha
v
e
the
same
t
yp
e,
but
otherwise
ma
y
b
e
im-
ages,
oating-p
oin
t
n
um
b
ers,
or
whatev
er.
FVision
also
supplies
a
ric
h
set
of
functions
for
the
con-
struction,
com
bination,
and
De-structuring
of
pip
elines.
Indeed,
it
is
often
the
case
that
w
e
ha
v
e
a
function
that
op
erates
on
images
or
oating-p
oin
t
n
um
b
ers,
sa
y
,
and
w
e
wish
to
\lift"
it
to
op
erate
on
pip
elines
of
images
or
oating-p
oin
t
n
um
b
ers.
This
is
one
place
where
p
oly-
morphic
higher-order
functions
really
shine:
instead
of
redening
these
functions
to
op
erate
on
the
pip
elines,
w
e
simply
pro
vide
a
family
of
p
olymorphic
\lifting
op-
erators"
to
do
this
for
us:
pipe0
::
a
->
Pipe
a
pipe
::
(a
->
b)
->
(Pipe
a
->
Pipe
b)
pipe
::
(a
->
b
->
c)
->
(Pipe
a
->
Pipe
b
->
Pipe
c)
...
pipe0
tak
es
a
function
of
0
argumen
ts
(ak
a
a
constan
t)
and
turns
it
in
to
a
\constan
t
pip
eline"
whic
h
alw
a
ys
con
tains
the
same
v
alue;
pipe
tak
es
a
function
of

argumen
t
and
turns
it
in
to
a
function
whic
h
tak
es
a
pip
eline
of
argumen
ts
and
returns
a
pip
eline
of
results;
pipe
tak
es
a
function
of

argumen
ts
and
turns
it
in
to
a
function
whic
h
tak
es

pip
elines
of
argumen
ts
and
re-
turns
a
pip
eline
of
results;
etc.
F
or
example,
pipe
(*)
creates
a
v
ersion
of
the
m
ultiplication
function
(written
as
(*)
in
FVision)
whic
h
op
erates
on
t
w
o
pip
elines
of
n
um
b
ers,
yielding
a
pip
eline
of
pro
ducts:
(*)


==>

pipe
(*)
(pipe
[,,])
(pipe
[,,])
==>
pipe
[,,0]
pipe
(*)
(pipe0
)
(pipe
[,,])
==>
pipe
[,,0]
Pip
elines
ma
y
b
e
split
or
joined
using
these
functions:
joinPipe
::
Pipe
a
->
Pipe
b
->
Pipe
(a,
b)
splitPipe
::
Pipe
(a,
b)
->
(Pipe
a,
Pipe
b)
F
or
example:
joinPipe
(pipe
[,,])
(pipe
[,,])
==>
pipe
[(,),(,),(,
)]
splitPipe
(pipe
[(,),(,),(,
)])
==>
(pipe
[,,],
pipe
[,,])
Another
w
a
y
to
com
bine
pip
elines
is
to
\m
ultiplex"
them:
the
multiplex
function
merges
t
w
o
pip
es,
using
a
third
pip
e
as
a
switc
h;
in
essence
this
is
just
the
con-
ditional
if
function
\lifted"
in
to
the
pip
eline
domain:
multiplex
::
Pipe
Bool
->
Pipe
a
->
Pipe
a
->
Pipe
a
multiplex
=
pipe
cond
where
cond
x
y
z
=
if
x
then
y
else
z
Pip
elines
ma
y
also
include
in
teractions
with
the
outside
w
orld.
IO
actions
in
FVision
ha
v
e
t
yp
e
IO
a
for
some
t
yp
e
a.
The
family
of
functions:
pipeIO0
::
IO
a
->
Pipe
a
pipeIO
::
(a
->
IO
b)
->
(Pipe
a
->
Pipe
b)
...
yield
pip
elines
whic
h
execute
an
IO
action
at
eac
h
iter-
ation
of
the
pip
eline.
F
or
example,
acquire
v
sz
pos
is
an
IO
action
whic
h
acquires
an
image
of
size
sz
at
p
osition
pos
from
a
video
device
v;
therefore
pipeIO
(acquire
v
sz)
is
a
function
whic
h
acquires
a
sequence
of
images
(of
xed
size)
at
a
sequence
of
dieren
t
p
osi-
tions
in
the
video
frame.
F
eedbac
k
lo
ops
often
require
a
dela
y
to
hold
a
v
alue
from
one
time
step
to
the
next.
The
delay
function
dela
ys
the
v
alues
in
the
pip
eline
b
y
one
step,
using
a
giv
en
initial
v
alue
for
the
rst
elemen
t
in
the
pip
e:
delay
::
a
->
Pipe
a
->
Pipe
a
F
eedbac
k
is
ho
w
state
is
expressed
in
con
trol
lo
ops,
and
th
us
this
dela
y
function
is
ho
w
w
e
express
stateful
trac
k-
ers.
F
or
example,
if
the
trac
k
er
applies
a
function
step
to
generate
a
new
state
from
the
old
on
eac
h
iteration,
then
the
follo
wing
function
yields
an
iterated
trac
k
er:
iterate
::
(a
->
a
->
a)
->
a
->
Pipe
a
->
Pipe
a
iterate
combine
x0
xs
=
let
p
=
delay
x0
(pipe
combine
p
xs)
in
p
Note
that
the
pip
eline
p
is
dened
recursiv
ely;
indeed,
it
is
an
example
of
an
innite
pip
e.
A
particularly
useful
function
built
using
iterate
is
integral
whic
h
computes
the
running
total
of
the
v
al-
ues
in
its
input
pip
e:


integral
::
(Num
a)
=>
a
->
Pipe
a
->
Pipe
a
integral
x0
xs
=
iterate
(+)
x0
xs
In
summary
,
the
pip
eline
abstraction
tak
es
adv
an
tage
of
man
y
Hask
ell
features:
p
olymorphic
t
yping
(in
the
Pipe
t
yp
e
and
the
pipe<n>
functions),
higher-order
func-
tions
(in
the
pipe<n>
functions
and
iterate
function)
and
lazy
ev
aluation
(in
the
multiplex,
iterate
and
integral
functions).
The
SSD
Stepp
er
The
SSD
trac
k
er
follo
ws
a
reference
image
as
it
mo
v
es
in
the
video
stream.
In
XVision,
this
trac
k
er
is
dened
using
a
complex
ob
ject
structure
con
taining
man
y
dif-
feren
t
metho
ds
and
in
ternal
state.
The
inner
structure
of
SSD
con
tains
a
lo
op
that
acquires
a
region
within
the
image,
compares
it
with
the
reference
image,
and
then
adjusts
the
apparen
t
lo
cation
of
the
image
to
accoun
t
for
mo
v
emen
t
that
has
tak
en
place
since
the
previous
frame.
In
FVision,
the
SSD
trac
k
er
is
brok
en
in
to
t
w
o
parts:
the
stepp
er
and
the
tr
acker.
The
stepp
er
is
a
pure
func-
tion
whose
FVision
co
de
is
giv
en
in
gure
.
This
co
de
is
a
direct
transcription
of
the
SSD
algorithm
in
to
FVi-
sion,
and
is
readable
to
an
y
one
familiar
with
the
un-
derlying
algorithm,
but
is
otherwise
unimp
ortan
t
here.
More
imp
ortan
t
is
the
t
yp
e
signature,
whic
h
declares
that
ssdStep
tak
es
t
w
o
inputs,
b
oth
images
(the
refer-
ence
image
is
the
rst
parameter),
and
returns
a
delta
(direction
to
mo
v
e
the
\camera"
to
adjust
the
curren
t
image
to
matc
h
the
reference
image)
and
the
residual
(an
estimate
of
the
closeness
of
the
matc
h
b
et
w
een
the
area
under
the
camera
and
the
reference).
The
other
comp
onen
t
of
SSD
is
the
trac
k
er.
Once
w
e
implemen
ted
the
pip
eline
abstraction,
it
pro
v
ed
to
b
e
trivial
to
implemen
t
an
SSD
trac
k
er,
as
sho
wn
in
g-
ure
.
All
w
e
had
to
do
w
as
translate
the
o
w
diagram
in
gure

from
the
graphical
syn
tax
in
to
a
textual
syn
tax
using
the
pip
eline
abstraction
to
represen
t
the
lines
in
the
diagram.
Once
again,
the
t
yp
e
signature
rev
eals
the
basic
op
eration
of
ssdTrack:
giv
en
a
video
stream,
the
initial
p
osition
of
the
trac
k
ed
feature,
and
an
image
of
the
trac
k
ed
feature,
this
function
returns
t
w
o
pip
elines:
a
sequence
of
p
oin
ts
and
a
sequence
of
residuals.
The
cyclic
dep
endencies
in
the
trac
king
algorithm
(as
expressed
in
the
o
w
diagram)
are
directly
reected
in
the
dep
endencies
b
et
w
een
the
v
ariables
in
the
let
expression
(in
FVision,
the
denitions
in
tro
duced
in
a
let
expression
are
m
utually
recursiv
e).
Lazy
ev
alua-
tion
ensures
that
at
eac
h
step
ev
aluation
will
o
ccur
in
the
prop
er
order;
i.e.
b
y
demand:
rst
the
image
is
ac-
quired
from
the
video
device
at
the
curren
t
p
osition,
then
the
SSD
stepp
er
computes
a
delta
from
the
curren
t
p
osition,
and
then
this
delta
is
added
to
the
curren
t
p
o-
sition.
The
integral
function
serv
es
the
essen
tial
role
of
dela
ying
eac
h
computation
b
y
one
step.
That
is,
it
uses
the
delta
computed
in
the
previous
iteration
to
compute
the
presen
t
v
alue
of
the
in
tegral.
More
Complex
T
rac
k
ers
T
o
sho
w
the
comp
ositional
nature
of
FVision,
and
th
us
its
abilit
y
to
scale,
a
more
complex
trac
k
er
based
on
SSD
is
sho
wn
in
gure
.
This
trac
k
er
is
used
as
part
of
the
clo
wn
face
program
men
tioned
earlier.
It
trac
ks
ey
e
p
osition
using
t
w
o
dieren
t
reference
images:
an
op
en
ey
e
and
a
closed
ey
e.
The
trac
k
er
compares
the
curren
t
image
with
reference
images
for
b
oth
an
op
en
and
a
closed
ey
e,
c
ho
osing
to
mo
v
e
the
trac
k
er
using
the
delta
asso
ciated
with
the
image
with
the
smallest
residual
(error
v
alue)
asso
ciated
with
it.
This
trac
k
er
fuses
the
results
of
t
w
o
SSD
sub-trac
k
ers,
one
for
eac
h
image.
Both
trac
k
ers
share
a
common
state
(the
curren
t
p
osition)
and
the
image
is
con
tin
uously
compared
against
b
oth
reference
images,
using
the
im-
age
most
closely
matc
hing
the
curren
t
image
to
guide
the
trac
k
er.
The
result
includes
a
pip
eline
of
b
o
oleans,
indicating
whic
h
of
the
t
w
o
images
is
curren
tly
b
eing
trac
k
ed.
W
e
can
further
abstract
this
fusion
b
y
replacing
the
image
parameters
with
arbitrary
trac
k
ers.
Th
us
an
y
trac
k
er
returning
a
delta
and
residual
can
b
e
com-
bined
with
a
similar
trac
k
er
to
yield
the
comp
osite
trac
k
er.
Higher-order
functions
are
a
natural
w
a
y
to
express
this
sort
of
abstraction
in
FVision.
In
C
+
+
this
sort
of
abstraction
is
m
uc
h
more
cum
b
ersome:
clo-
sures
(used
to
hold
partially
applied
functions,
suc
h
as
ssdStep
openIm)
m
ust
b
e
dened
and
built
man
ually
.

IMPLEMENT
A
TION
ISSUES
W
e
hop
e
that
the
previous
section
pro
vides
con
vincing
evidence
that
FVision
is
a
v
aluable
DSL
for
computer
vision.
In
this
section
w
e
address
some
of
the
practical
issues
in
v
olv
ed
in
designing
and
implemen
ting
FVision
as
an
em
b
edded
DSL
in
Hask
ell,
and
connecting
it
to
a
large
C
+
+
library
,
XVision.
The
Domain
V
o
cabulary
A
k
ey
part
of
building
a
domain-sp
ecic
language
for
vi-
sion
pro
cessing
is
pro
viding
the
basic
v
o
cabulary
neces-
sary
to
express
op
erations
in
the
domain
ecien
tly
and
recognizably
.
This
consists
of
the
primitiv
e
data
t
yp
es
that
domain
exp
erts
w
an
t
to
use
(principally
,
in
our
case,
images
and
matrices)
and
a
useful
set
of
op
erations
to
create,
manipulate,
and
output
v
alues
of
those
t
yp
es.
An
essen
tial
to
ol
in
this
task
w
as
our
foreign
function
in
terface
generator
Gr
e
enCar
d
[
]
whic
h
made
it
easy
to
mak
e
C
+
+
v
alues
and
op
erations
lo
ok
lik
e
Hask
ell
v
alues
and
op
erations
to
the
FVision
programmer.
P
artly
from
habit
and
partly
b
ecause
w
e
w
ere
an
tici-


ssdStep
::
Image
->
Image
->
(Delta,Double)
ssdStep
refIm
r
=
let
m
=
vectorsToMatrix
[smoothDx
refIm,
smoothDy
refIm]
m_t
=
transpose
m
m'
=
inverse
(m_t
*
m)
*
m_t
error
=
imageToVector
(compressXY
(refIm
-
r))
delta
=
m'
`multVector`
error
residual
=
norm
(error
-
m
`multVector`
delta)
in
(matrixToDelta
delta,
residual)
Figure
:
The
SSD
stepp
er
ssdTrack
::
Video
->
Pos
->
Image
->
(Pipe
Pos,
Pipe
Double)
ssdTrack
video
initialPosition
refIm
=
let
image
=
pipeIO
(acquire
video
(sizeOf
refIm))
posn
(delta,
residual)
=
splitPipe
(pipe
(ssdStep
refIm)
image)
position
=
integral
initialPosition
delta
in
(position,
residual)
Figure
:
The
SSD
trac
k
er
eye
::
Video
->
Pos
->
Image
->
Image
->
(Pipe
Pos,
Pipe
Bool)
eye
video
initialPosition
openIm
closedIm
=
let
image
=
pipeIO
(acquire
video
(sizeOf
openIm))
posn
(openDelta,
openResidual)
=
splitPipe
(pipe
(ssdStep
openIm)
image)
(closedDelta,
closedResidual)
=
splitPipe
(pipe
(ssdStep
closedIm)
image)
isOpen
=
pipe
(<)
openDelta
closedDelta
delta
=
multiplex
isOpen
openDelta
closedDelta
posn
=
integral
initialPosition
delta
in
(posn,
isOpen)
Figure
:
The
ey
e
trac
k
er
pating
the
pip
eline
abstraction,
w
e
w
an
ted
the
domain-
sp
ecic
op
erations
to
b
e
\pure"
(free
from,
and
unaf-
fected
b
y
,
side
eects)
and
\lazy"
(p
erformed
only
if
and
when
required).
Making
the
XVision
library
lo
ok
this
w
a
y
required
a
little
w
ork:

Although
man
y
op
erations
w
ere
already
pure,
C
+
+
programmers
rarely
do
cumen
t
suc
h
facts.
Th
us,
it
b
ecame
necessary
to
b
ecome
familiar
with
the
implemen
tation
of
as
w
ell
as
the
in
terfaces
to
the
underlying
image
pro
cessing
library
.

Although
it
is
easy
to
mak
e
pure
op
erations
lazy
,
it
b
ecomes
almost
imp
ossible
to
reason
ab
out
the
lifetime
of
ob
jects
created
b
y
lazy
op
erations,
and
th
us
man
ual
storage
managemen
t
(using
C
+
+
's
new
and
delete)
is
infeasible.
F
ortunately
,
GreenCard
pro
vides
mec
hanisms
that
let
Hask
ell's
garbage
col-
lector
tak
e
o
v
er
the
task
of
managing
C
+
+
ob
jects
from
the
programmer:
when
a
C
+
+
ob
ject
is
re-
turned
to
Hask
ell
from
a
C
+
+
function,
it
is
added
to
a
list
of
ob
jects
managed
b
y
Hask
ell;
and
when
Hask
ell
no
longer
requires
an
ob
ject
it
is
managing,
it
calls
delete
to
release
the
ob
ject.
Ho
w
ev
er,
w
e
did
not
try
to
mak
e
all
op
erations
pure,
since
some
op
erations
suc
h
as
acquiring
an
image
or
dra
wing
an
image
on
the
screen
are
necessarily
\im-
pure":
purit
y
and
laziness
are
merely
design
guidelines,
and
it
is
not
helpful
to
b
e
to
o
dogmatic
ab
out
them.
W
e
also
disco
v
ered
the
need
for
man
y
standard
im-


age/matrix
op
erations
whic
h
C
+
+
programmers
w
ould
just
co
de
\inline."
F
or
example,
one
of
our
trac
k
ers
needs
to
compute
an
image
mask
b
y
applying
a
thresh-
old
to
an
image.
Though
this
is
a
common
enough,
general
purp
ose
op
eration
often
used
in
XVision
appli-
cations,
XVision
do
es
not
pro
vide
a
function
to
do
this
directly
.
One
w
a
y
to
add
this
function
w
ould
b
e
to
add
op
erations
for
manipulating
individual
pixels
in
an
im-
age
and
then
co
de
the
function
in
Hask
ell;
another
w
a
y
to
add
this
function
w
ould
b
e
to
co
de
it
in
C
+
+
and
add
it
to
XVision.
W
e
c
hose
the
second
w
a
y
for
t
w
o
reasons:
.
Crossing
the
b
oundary
from
Hask
ell
in
to
C
+
+
is
relativ
ely
exp
ensiv
e
(p
erhaps
the
cost
of
0
or
0
function
calls
in
C
+
+
)
so,
for
eciency
reasons,
w
e
w
an
ted
to
a
v
oid
this
b
oundary
crossing
o
v
erhead
on
tigh
t
lo
ops.
.
Most
of
the
new
image
pro
cessing
functions
w
e
w
an
ted
to
add
w
ere
general
purp
ose
functions
that
w
e
though
t
XVision
ought
to
pro
vide.
It
seemed
that
the
b
est
w
a
y
to
a
v
oid
rein
v
en
ting
the
wheel
w
as
to
mak
e
sure
that
ev
ery
one
knew
where
the
wheels
w
ere
stored:
in
the
XVision
library
.
In
this
w
a
y
the
rigid
separation
b
et
w
een
the
domain-
sp
ecic
language
and
the
domain-sp
ecic
op
erations
help
ed
clarify
what
op
erations
w
e
needed.
The
nal
factor
that
inuenced
the
design
pro
cess
grew
from
the
dynamics
of
the
pro
ject,
a
collab
oration
b
e-
t
w
een
vision
researc
hers
and
functional
programming
researc
hers.
As
na

v
e
users,
the
functional
program-
mers
w
ould
try
to
do
things
that
didn't
mak
e
an
y
sense
in
the
computer
vision
w
orld,
and
then
complained
to
the
vision
researc
hers
when
they
obtained
strange
re-
sults.
F
or
example,
adding
t
w
o
color
images
do
esn't
mak
e
an
y
sense
since
the
pixels
are
represen
ted
b
y

bit
n
um
b
ers:
an
y
o
v
ero
w
in
one
color
eld
\spills
o
v
er"
in
to
another
color
eld
resulting
in
strangely
colored
im-
ages.
These
problems
prompted
the
dev
elopmen
t
of
a
more
precise
t
yp
e
system
for
images
that
k
eeps
color
im-
ages
separate
from
gra
y-scale
images.
This
t
yp
e
system
w
as
quic
kly
protot
yp
ed
in
Hask
ell
b
y
giving
functions
t
yp
es
whic
h
w
ere
more
restrictiv
e
than
in
C
+
+
.
Ha
ving
found
that
this
t
yp
e
system
catc
hes
man
y
trivial
errors
but
do
esn't
in
terfere
with
the
programmer
to
o
m
uc
h,
w
e
plan
to
express
the
t
yp
e
system
directly
in
the
C
+
+
class
hierarc
h
y
.
After
our
failed
rst
attempt
at
imp
orting
XVision
in
to
Hask
ell,
one
thing
w
e
did
not
try
to
do
w
as
to
imp
ort
XVision's
high
lev
el
abstractions
in
to
Hask
ell.
Reasons
for
this
include:

Since
our
goal
w
as
to
r
e
design
XVision's
high
lev
el
abstractions,
w
e
did
not
w
an
t
to
buy
in
to
the
ex-
isting
abstractions
for
fear
that
they
w
ould
mak
e
it
hard
to
in
v
en
t
more
appropriate
abstractions
or
w
ould
mak
e
it
harder
to
protot
yp
e
new
ideas.

The
lo
w
lev
el
ob
jects
and
op
erations
ha
v
e
simple,
w
ell
understo
o
d,
obvious
in
terfaces;
whereas
the
high
lev
el
ob
jects
and
op
erations
ha
v
e
m
uc
h
more
complex
in
terfaces.
It
just
w
asn't
ob
vious
what
the
essence
of
the
high
lev
el
ob
jects
should
b
e.

The
high
lev
el
ob
jects
mak
e
more
use
of
the
C
+
+
class
hierarc
h
y
.
This
could
probably
b
e
mimic
k
ed
in
Hask
ell,
but
it
w
asn't
ob
vious
ho
w.
Nor
w
as
it
ob
vious
that
the
existing
class
hierarc
h
y
w
as
the
R
ight
Design
rather
than
just
what
w
as
con
v
enien
t
to
co
de
in
C
+
+
.
Th
us
far,
w
e
ha
v
e
not
missed
XVision's
high
lev
el
ab-
stractions.
Virtual
Cameras
and
Displa
ys
The
only
reason
w
e
pro
vide
the
pipeIO<n>
functions
in
the
pip
eline
library
is
to
let
us
acquire
images
from
the
video
devices.
These
functions
w
ere
a
relativ
ely
late
addition
to
the
library:
in
earlier
v
ersions
of
FVision,
op
ening
a
video
device
returned
a
pip
e
of
images
and
ssdTrack
used
a
subImage
op
eration
to
acquire
a
small
part
of
that
image.
W
e
found
this
v
ersion
m
uc
h
simpler
to
reason
ab
out
but
w
ere
forced
to
abandon
it
b
ecause
of
sev
ere
p
erformance
problems.
Our
video
device
driv
ers
run
in
the
op
erating
system
k
ernel
and
capture
images
in
to
one
of
a
small
n
um
b
er
of
memory
buers
shared
with
the
(user
mo
de)
program.
Since
there
are
only
a
few
shared
memory
buers,
w
e
ha
v
e
to
cop
y
the
image
in
to
unshared
memory
b
efore
putting
it
in
to
the
pip
e.
Since
the
video
device
gener-
ates
0
frames
p
er
second
of
.Mb
ytes
eac
h,
our
early
applications
sp
en
t
most
of
their
time
cop
ying
memory
around.
This
w
as
particularly
galling
since
a
t
ypical
im-
age
pro
cessing
application
only
examines
a
few
regions
of
p
erhaps
kb
yte
eac
h.
Our
solution
w
as
to
add
the
pipeIO<n>
functions
and
the
acquire
functions
so
that
w
e
could
view
a
single
physic
al
camera
(represen
ted
b
y
a
p
oin
ter
to
a
C
+
+
ob-
ject)
as
a
n
um
b
er
of
separate
virtual
cameras
eac
h
pro-
viding
a
pip
e
of
subimages
of
the
full
camera
image.
Similarly
,
w
e
plan
to
add
supp
ort
to
let
us
view
eac
h
physic
al
windo
w
on
our
desktop
as
a
collection
of
virtual
windo
ws
eac
h
displa
ying
relev
an
t
images
and
data
from
inside
an
FVision
pip
eline.
This
should
b
e
easy
to
do
using
standard
functional
programming
tec
hnology
[]
and
will
solv
e
a
problem
observ
ed
in
b
oth
FVision
and
XVision:
when
a
complex
application
starts,
it
t
ypically
op
ens
a
dozen
small
windo
ws
on
the
screen,
eac
h
win-
do
w
b
eing
randomly
p
ositioned
on
the
screen
according


to
the
windo
w
manager's
whim.

ASSESSMENT
In
man
y
w
a
ys,
the
dev
elopmen
t
of
FVision
has
b
een
an
exp
erimen
t
in
soft
w
are
engineering
and
DSL
design
whic
h
has
exceeded
our
exp
ectations
in
terms
of
scop
e,
p
erformance,
simplicit
y
and
usabilit
y
.
In
the
remainder
of
this
section
w
e
discuss
eac
h
of
these
issues
in
turn.
P
erformance
One
of
the
reasons
w
e
had
initially
c
hosen
to
in
terface
to
XVision
at
a
high
lev
el
w
as
our
b
elief
that
Hask
ell
w
ould
force
us
to
pa
y
to
o
high
a
p
erformance
cost.
It
turns
out
that
this
supp
osition
w
as
unfounded.
In
fact,
w
e
ha
v
e
found
that
programs
written
in
FVision
run
at
least
	0%
as
fast
as
the
nativ
e
C
+
+
co
de,
ev
en
though
they
are
(curren
tly)
b
eing
run
in
terpreted!
This
(sur-
prising!)
disco
v
ery
can
b
e
attributed
to
the
fact
that
the
b
ottlenec
k
in
vision
pro
cessing
programs
is
not
in
the
high-lev
el
algorithms
(whic
h
w
e
protot
yp
ed
in
Hask
ell)
but
in
the
lo
w-lev
el
image
pro
cessing
algorithms
(whic
h
w
e
imp
orted
from
C
+
+
).
As
a
result,
w
e
ha
v
e
found
that
FVision
is
in
fact
a
realistic
alternativ
e
to
C
+
+
for
protot
yping
or
ev
en
deliv
ering
applications.
While
there
are,
no
doubt,
situations
in
whic
h
the
p
erformance
of
Hask
ell
co
de
ma
y
require
migration
to
C
+
+
for
e-
ciency
,
it
is
often
the
case
that
the
use
of
Hask
ell
to
express
high-lev
el
organization
of
a
vision
system
has
no
appreciable
impact
on
p
erformance.
F
urthermore,
the
Hask
ell
in
terpreter
used
in
our
exp
erimen
t,
Hugs,
has
a
v
ery
small
fo
otprin
t
and
can
b
e
included
in
ap-
plication
without
seriously
increasing
the
o
v
erall
size
of
vision
library
.
Choice
of
Scop
e
As
noted
ab
o
v
e,
our
original
goals
w
ere
to
incorp
orate
m
uc
h
of
the
\high-lev
el"
XVision
co
de
and
to
use
it
as
a
\blac
k
b
o
x."
In
retrosp
ect,
the
initial
attempts
at
doing
this
required
as
m
uc
h
or
more
eort
than
mo
v-
ing
do
wn
a
lev
el
and
dev
eloping
the
complete
XVision
system
itself
within
the
DSL.
This
can
largely
b
e
at-
tributed
to
the
fact
that
the
lo
w
er-lev
el
op
erations
of
XVision
not
only
t
w
ell
within
the
Hask
ell
program-
ming
paradigm,
but
they
also
ha
v
e
simpler
in
terfaces
whic
h
w
ere
straigh
tforw
ard
to
incorp
orate.
Programmer
Pro
ductivit
y
Enlarging
the
scop
e
of
the
DSL
had
an
additional
ad-
v
an
tage
of
allo
wing
us
to
us
to
quic
kly
explore
the
design
space
for
visual
trac
king
as
w
ell
as
the
implications
of
the
design
far
faster
than
a
C
+
+
protot
yp
e
w
ould
ha
v
e.
The
Pip
e
library
is
a
go
o
d
example.
A
simplistic
proto-
t
yp
e
of
pip
es
had
b
een
dev
elop
ed
for
XVision.
It
con-
sisted
of
00
lines
of
C
+
+
co
de
written
o
v
er
sev
eral
mon
ths.
The
co
de
w
as
designed
as
an
\add
on"
to
the
existing
XVision,
although
it
w
as
hop
ed
that
the
use
of
data-o
w
pro
cessing
w
ould
ev
en
tually
impact
the
dev
el-
opmen
t
of
other
asp
ects
of
the
system.
Designing
the
Pip
e
library
in
FVision
to
ok
only
t
w
o
da
ys
of
programmer
time,
and
consists
of
just
00
lines
of
FVision
co
de
(excluding
commen
ts
and
blank
lines).
This
can
b
e
attributed
largely
to
the
abilit
y
to
describ
e
pip
es
as
lazy
lists,
and
the
use
of
p
olymorphism
to
im-
p
ort
basic
image
op
erations
in
to
pip
es.
F
urthermore,
w
e
could
no
w
explore
the
implications
of
pip
es
for
the
remainder
of
the
system
(in
particular
SSD)
completely
within
the
DSL.
As
a
result,
w
e
no
w
ha
v
e
a
m
uc
h
more
concrete
notion
of
ho
w
a
redesigned
XVision
(based
on
the
pip
e
abstraction)
w
ould
lo
ok.
Flexibilit
y
and
Useabilit
y
One
of
the
problems
w
e
ha
v
e
found
with
XVision
o
v
er
the
past
few
y
ears
is
that,
although
the
soft
w
are
ab-
stractions
w
ork
reasonably
w
ell,
the
domain
of
real-time
vision
resists
simple
encapsulation.
Most
of
the
trac
king
metho
ds
can
in
fact
b
e
\tuned"
or
mo
died
in
a
large
v
ariet
y
of
w
a
ys.
Making
all
of
the
p
ossibilities
a
v
ailable
via
a
generic
in
terface
across
the
v
arious
mo
dalities
has
pro
v
en
cum
b
ersome
(and
w
as
one
reason
wh
y
our
initial
protot
yp
e
w
as
more
dicult
to
construct).
The
DSL,
in
particular
the
dev
elopmen
t
of
pip
es,
has
not
only
claried
m
uc
h
of
the
design
of
the
system,
but
it
has
also
made
it
easier
to
exp
ose
the
inner
w
orkings
of
individual
algorithms.
As
a
result,
the
comp
osition
of
new
trac
king
systems
is
m
uc
h
simpler.
Finally
,
the
pip
eline
mo
del
is
a
go
o
d
basis
for
parallel
execution
on
shared
memory
m
ultipro
cessors
or
ev
en
on
a
lo
osely
coupled
collection
of
pro
cessors.

RELA
TED
W
ORK
W
e
are
not
a
w
are
of
an
y
other
eorts
to
create
a
sp
ecial-
purp
ose
language
for
computer
vision,
although
there
do
es
exist
a
DSL
for
writing
video
device
driv
ers
[
].
That
w
ork
is
at
a
lev
el
quite
a
bit
lo
w
er
than
that
at
whic
h
are
w
orking,
but
it
is
conceiv
able
to
use
it
as
a
substrate
for
our
o
wn
w
ork.
There
are
pap
ers
to
o
n
umerous
to
men
tion
on
to
ols
for
building
DSL's
from
scratc
h,
but
most
relev
an
t
is
previ-
ous
eorts
of
our
o
wn
on
emb
e
dde
d
DSL's
[
,
0
].
Pre-
vious
examples
of
DSL's
em
b
edded
in
Hask
ell
include
F
ran
[,
],
a
language
for
functional
reactiv
e
anima-
tions,
and
Activ
eHask
ell
[],
a
DSL
for
scripting
COM
comp
onen
ts.
These
share
m
uc
h
with
FVision
in
their
use
of
Hask
ell
as
a
v
ehicle
for
expressing
abstraction
and
mo
dularit
y
.
General
discussions
of
the
adv
an
tages
of
programming
with
pure
functions
are
also
quite
n
u-
merous;
t
w
o
of
particular
relev
ance
to
our
w
ork
are
one
that
describ
es
the
use
of
functional
languages
for
rapid
protot
yping
[	
],
and
one
that
describ
es
the
p
o
w
er
of
higher-order
functions
and
lazy
ev
aluation
as
the
\glue"
needed
for
mo
dular
programming.
	

Pip
elines
are
v
ery
similar
to
the
notion
of
str
e
ams
in
the
functional
programming
comm
unit
y
,
ab
out
whic
h
an
y
go
o
d
textb
o
ok
on
Hask
ell
will
address
(e.g.
[]).
The
use
of
streams
in
signal
pro
cessing
and
op
erating
systems
con
texts
dates
bac
k
man
y
y
ears
[].
Streams
ha
v
e
also
b
een
prop
osed
as
a
basis
for
functional
animation
[].

CONCLUSIONS
A
domain-sp
ecic
language
is
a
p
o
w
erful
soft
w
are
engi-
neering
to
ol
that
increases
pro
ductivit
y
and
exibilit
y
in
complex
applications
where
ordinary
program
libraries
are
less
eectiv
e.
Creating
a
full-edged
DSL
from
a
library
w
as
more
dicult
than
exp
ected
but
the
results
w
ere
w
ell
w
orth
the
in
v
estmen
t.
Lessons
learned
ab
out
DSL
design
from
this
pro
ject
include:
.
The
lev
el
of
in
terface
b
et
w
een
nativ
e
co
de
and
the
DSL
is
a
crucial
c
hoice
in
dev
eloping
an
eectiv
e
system.
Sometimes,
this
in
v
olv
es
going
deep
er
in
to
the
domain
than
one
migh
t
exp
ect.
.
The
pro
cess
of
DSL
design
can
unco
v
er
in
teresting
insigh
ts
whic
h
ma
y
not
b
e
apparen
t
ev
en
to
domain
sp
ecialists.
W
orking
from
the
\b
ottom
up"
to
de-
v
elop
a
language
forces
b
oth
the
domain
sp
ecialists
and
the
DSL
sp
ecialists
to
examine
(or
re-examine)
the
underlying
domain
for
the
righ
t
abstractions
and
in
terfaces.
.
P
erformance,
ev
en
for
soft
real-time
applications,
can
b
e
acceptable
pro
vided
care
is
tak
en
in
the
in-
terfaces.
.
Hask
ell
serv
ed
w
ell
as
a
basis
for
the
em
b
edded
DSL.
The
principal
features
of
Hask
ell,
a
ric
h
p
oly-
morphic
t
yp
e
system
and
higher-order
functions,
w
ere
a
signican
t
adv
an
tage
in
the
DSL.
Adding
a
small
Hask
ell
in
terpreter
to
the
system
did
not
sig-
nican
tly
increase
its
size
or
degrade
p
erformance.
Ac
kno
wledgemen
ts
This
w
ork
w
as
supp
orted
b
y
NSF
gran
t
CCR-	0
in
exp
erimen
tal
soft
w
are
systems.
REFERENCES
[]
Ka
vi
Ary
a.
A
functional
animation
starter-kit.
Journal
of
F
unctional
Pr
o
gr
amming,
():{,
Jan
uary
		.
[]
R.
Bird
and
P
.
W
adler.
Intr
o
duction
to
F
unctional
Pr
o
gr
amming.
Pren
tice
Hall,
New
Y
ork,
	.
[]
Conal
Elliott.
Mo
deling
in
teractiv
e
D
and
m
ul-
timedia
animation
with
an
em
b
edded
language.
In
Pr
o
c
e
e
dings
of
the
rst
c
onfer
enc
e
on
Domain-
Sp
e
cic
L
anguages.
USENIX,
Octob
er
		.
[]
Conal
Elliott
and
P
aul
Hudak.
F
unctional
reactiv
e
animation.
In
International
Confer
enc
e
on
F
unc-
tional
Pr
o
gr
amming,
pages
{,
June
		.
[]
Sigb
jorn
Finne
and
Simon
P
eyton
Jones.
Pictures:
A
simple
structured
graphics
mo
del.
In
Glasgow
F
unctional
Pr
o
gr
amming
Workshop,
Ullap
o
ol,
July
		.
[]
G.
D.
Hager
and
P
.
N.
Belh
umeur.
Ecien
t
region
trac
king
of
with
parametric
mo
dels
of
illumination
and
geometry
.
T
o
app
ear
in
IEEE
P
AMI.,
Octob
er
		.
[]
G.
D.
Hager
and
K.
T
o
y
ama.
The
\XVision"
sys-
tem:
A
general
purp
ose
substrate
for
real-time
vi-
sion
applications.
Comp.
Vision,
Image
Under-
standing.,
	():{,
Jan
uary
		.
[]
P
.
Henderson.
Purely
functional
op
erating
systems.
In
F
unctional
Pr
o
gr
amming
and
Its
Applic
ations:
A
n
A
dvanc
e
d
Course,
pages
{	.
Cam
bridge
Univ
ersit
y
Press,
	.
[	]
P
.
Henderson.
F
unctional
programming,
formal
sp
ep
cication,
and
rapid
protot
yping.
IEEE
T
r
ans-
actions
on
SW
Engine
ering,
SE-():{0,
	.
[0]
P
.
Hudak.
Building
domain
sp
ecic
em-
b
edded
languages.
A
CM
Computing
Surveys,
A:(electronic),
Decem
b
er
		.
[]
P
aul
Hudak.
Mo
dular
domain
sp
ecic
languages
and
to
ols.
In
Pr
o
c
e
e
dings
of
Fifth
International
Confer
enc
e
on
Softwar
e
R
euse,
pages
{.
IEEE
Computer
So
ciet
y
,
June
		.
[]
R.E.
Kahn,
M.J.
Sw
ain,
P
.N.
Prok
op
o
wicz,
and
R.J.
Firb
y
.
Gesture
recognition
using
P
erseus
ar-
c
hitecture.
In
Pr
o
c.
IEEE
Conf.
Comp.
Vision
and
Patt.
R
e
c
o
g.,
pages
{,
		.
[]
J.L.
Mundy
.
The
image
understanding
en
viron-
men
t
program.
IEEE
EXPER
T,
0():{,
De-
cem
b
er
		.
[]
Simon
P
eyton-Jones,
Erik
Meijer,
and
Dan
Leijen.
Scripting
COM
comp
onen
ts
in
hask
ell.
In
Pr
o
c
e
e
d-
ings
of
th
International
Confer
enc
e
on
Softwar
e
R
euse,
pages
{.
IEEE/A
CM,
		.
[]
SL.
P
eyton
Jones,
T.
Nordin,
and
A.
Reid.
Green-
card:
a
foreign-language
in
terface
for
hask
ell.
In
Pr
o
c
Haskel
l
Workshop,
Amsterdam,
June
		.
[]
C.
Consel
S.
Thibault,
R.
Marlet.
A
domain-
sp
ecic
language
for
video
device
driv
ers:
F
rom
de-
sign
to
implemen
tation.
In
Pr
o
c
e
e
dings
of
the
rst
c
onfer
enc
e
on
Domain-Sp
e
cic
L
anguages,
pages
{.
USENIX,
Octob
er
		.
0

[]
The
Khoros
Group.
The
Khor
os
Users
Manual.
The
Univ
ersit
y
of
New
Mexico,
Albuquerque,
NM,
		.


