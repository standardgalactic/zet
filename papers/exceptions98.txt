Handling
Exceptions
in
Hask
ell
Alastair
Reid
Y
ale
Univ
ersit
y
Departmen
t
of
Computer
Science
New
Ha
v
en,
CT
00
reid-alastair@
cs
.y
al
e.
ed
u
Jan
uary
	,
			
Abstract
Using
a
language
without
exception
handling
is
lik
e
driving
a
car
with
no
brak
es
and
no
seatb
elt
|
things
w
ork
ne
un
til
something
go
es
wrong.
Y
ou
also
learn
to
driv
e
rather
carefully
.
This
pap
er
describ
es
an
exception
handling
extension
to
the
Hask
ell
lazy
functional
language.
The
implemen
tation
turned
out
to
b
e
v
ery
easy
but
w
e
had
problems
nding
a
viable
seman
tics
for
our
system.
The
resulting
seman
tics
is
a
compromise
b
et
w
een
theoretical
b
eaut
y
and
practical
utilit
y
.

In
tro
duction
Hask
ell
is
an
iv
ory
to
w
er
language:
full
of
loft
y
ideas,
built
on
solid
seman
tic
foundations,
praised
b
y
grey-b
earded
professors
and
ab
out
as
m
uc
h
use
in
the
real
w
orld
as
a
c
ho
colate
teap
ot.
F
or
Hask
ell
to
emerge
from
the
iv
ory
to
w
er,
it
m
ust
b
e
p
ossible
to
write
the
kinds
of
programs
that
less
idealistic
programmers
can
write
in
C,
Ja
v
a,
Ada
and
other
useful
languages:
programs
that
in
teract
with
the
real
w
orld
in
in
teresting
w
a
ys
(using
graphics,
GUIs,
databases,
etc)
and
whic
h
are
robust
enough
to
k
eep
running
ev
en
when
things
go
wrong.
Recen
t
w
ork
on
Hask
ell
has
dealt
with
the
problem
of
in
teracting
with
the
real
w
orld:
Hask
ell's
IO
monad
[
,
]
pro
vided
an
extensible
framew
ork
for
in
teracting
with
the
real
w
orld;
GHC's
ccall
extension
[]
made
it
p
ossible
to
use
libraries
written
in
C;
GHC's
for-
eign
p
oin
ters
[
]
made
it
p
ossible
to
deallo
cate
C
ob
jects
without
compromising
laziness;
Hugs-GHC's
GreenCard
[	]
made
it
easy
to
use
standard
C
libraries;
the
Hugs-GHC
stan-
dard
libraries
[]
added
supp
ort
for
xed
size
in
tegers
facilitating
access
to
C
libraries
that
use
them.


This
increased
abilit
y
to
in
teract
with
the
real
w
orld
is
a
double-edged
sw
ord:
our
programs
ma
y
ac
hiev
e
w
ondrous
things
when
they
w
ork
correctly;
but
they
can
wreak
un
told
ha
v
o
c
when
they
fail.
F
or
example:
if
a
program
fails
halfw
a
y
through
mo
difying
a
database,
it
migh
t
corrupt
the
database;
if
a
program
fails
while
in
teracting
with
the
user,
it
migh
t
lea
v
e
a
confused
mess
of
windo
ws
on
the
screen;
if
a
program
fails
while
con
trolling
a
rob
ot,
the
rob
ot
migh
t
crash
in
to
w
alls
or
run
o
v
er
the
programmer's
fo
ot;
if
a
Hask
ell
in
terpreter
fails
while
executing
a
user's
program,
it
migh
t
ab
ort
the
in
terpreter
instead
of
prin
ting
an
error
message
and
prompting
for
the
next
command.
Giv
en
that
an
y
in
teresting
program
can
go
wrong,
the
only
solution
is
to
pro
vide
mec
hanisms
for
dealing
with
failure
when
it
happ
ens
and
to
educate
programmers
to
use
them.
Hask
ell's
IO
monad
[]
recognises
the
imp
ortance
of
exception
handling
|
pro
viding
a
simple
mec
hanism
for
raising
and
catc
hing
exceptions
within
the
IO
monad.
Careful
use
mak
es
Hask
ell
programs
m
uc
h
more
robust
but
exceptions
can
only
b
e
raised
within
the
IO
monad
|
so
there
is
no
w
a
y
to
catc
h
exceptions
lik
e
calls
to
the
error
function,
division
b
y
zero
or
pattern
matc
h
failure
whic
h
o
ccur
within
\pure"
co
de.
This
pap
er
describ
es
an
extension
whic
h
lets
programs
catc
h
\in
ternal
exceptions"
(e.g.
calls
to
the
error
function,
pattern
matc
h
failure
and
division
b
y
zero);
the
essen
tial
but
dieren
t
task
of
catc
hing
\external
exceptions"
(e.g.
in
terrupts
and
timeouts)
is
discussed
in
a
companion
pap
er
[]
and
outlined
in
Section
.
The
main
dicult
y
in
extending
Hask
ell's
exception
handling
capabilities
is
to
a
v
oid
com-
promising
Hask
ell's
main
strengths:
lazy
ev
aluation,
t
yp
e
safet
y
,
supp
ort
for
equational
rea-
soning
and
its
amenabilit
y
to
b
oth
man
ual
and
automatic
transformation.
Section

recalls
a
standard
exception
handling
mec
hanism
(the
exception
monad
and
the
call-b
y-name
monad
translation)
and
Section

describ
es
an
ecien
t
implemen
tation
of
this
mec
hanism.
This
is
the
easy
part
of
adding
exception
handling
and
is
essen
tially
a
reprise
and
up
date
of
Dornan
and
Hammond's
w
ork
[].
Section

p
oin
ts
out
a
signican
t
a
w
in
this
approac
h:
ev
en
though
this
mec
hanism
preserv
es
laziness,
t
yp
e
safet
y
and
referen
tial
transparency
,
it
ren-
ders
man
y
common
transformations
in
v
alid
and
apparen
tly
mak
es
reasoning
ab
out
Hask
ell
programs
dicult.
Section

sho
ws
that
this
problem
can
b
e
resolv
ed
with
a
small
c
hange
in
the
design
and
a
big
c
hange
in
the
w
a
y
w
e
reason
ab
out
exception
pro
ducing
programs.
The
dev
elopmen
t
in
the
previous
sections
ignores
the
in
teraction
b
et
w
een
exception
handling
and
t
w
o
other
exception-lik
e
features
of
Hask
ell:
Section

describ
es
these
features
and
suggests
a
unied
design.

The
Exception
Monad
W
adler
[]
describ
es
ho
w
ordinary
programmers
can
add
exception
handling
to
a
lazy
pro-
gram
using
the
exc
eption
monad
and
the
c
al
l
by
name
monad
tr
anslation.
The
exception
monad
and
the
call
b
y
name
monad
translation
are
sho
wn
in
gures

and
.
W
e
ha
v
e
extended
W
adler's
v
ersions
in
t
w
o
small
w
a
ys:
w
e
use
a
String
to
hold
error
messages;
and
w
e
co
v
er
the
full
Core
Hask
ell
language.
In
the
rules
for
translating
terms,
w
e
use
x,
x
i
,
.
.
.
for
v
ariables,
e,
e
i
,
.
.
.
for
expressions,
C
for
a
constructor
of
arit
y
m,
k
for
a
constan
t,
op


for
a
strict
primitiv
e
op
eration
of
arit
y
m
and
op
y
is
the
same
as
op
except
that
it
raises
an
exception
whenev
er
op
returns
?.
The
Hask
ell
rep
ort
[]
giv
es
the
necessary
rules
for
transforming
Hask
ell
programs
in
to
Core
Hask
ell.
Figure

sho
ws
the
monad
translation
in
action
on
a
user-dened
function
average
and
a
primitiv
e
op
eration
divide.
As
w
ell
as
b
eing
able
to
raise
exceptions
(via
error,
pattern
matc
h
failure
or
primitiv
e
op
erations),
w
e
need
a
w
a
y
to
catc
h
exceptions.
W
adler
pro
vides
the
biase
d-choic
e
op
er
ator
?
::
E
a
->
E
a
->
E
a
whic
h
c
ho
oses
the
rst
of
t
w
o
p
ossible
v
alues
that
is
w
ell
dened.
Since
w
e
distinguish
b
et
w
een
dieren
t
exceptions,
w
e
c
hange
the
t
yp
e
sligh
tly
to
allo
w
the
second
argumen
t
to
access
the
exception
raised
b
y
the
rst
argumen
t;
and
w
e
c
hange
the
name
to
reect
a
similarit
y
to
Hask
ell
.'s
catch
function.
catchException
::
E
a
->
(String
->
E
a)
->
E
a
(In
fact,
Section

explains
that
w
e
need
to
c
hange
this
t
yp
e
ev
en
more.)
This
translation
has
the
follo
wing
desirable
prop
erties:
it
preserv
es
laziness;
it
preserv
es
t
yp
e
safet
y;
it
preserv
es
conuence
and
termination;
and
it
preserv
es
referen
tial
transparency
.
W
adler's
approac
h
has
some
problems,
most
of
whic
h
stem
from
the
fact
that
w
e
are
enc
o
ding
exception
handling
in
Hask
ell
rather
than
making
it
p
art
of
the
language.
.
While
the
transformation
is
simple
to
apply
,
it
is
extremely
tedious
and
error
prone
|
whic
h
mak
es
it
hard
to
ha
v
e
an
y
condence
in
the
(allegedly
increased)
reliabilit
y
of
the
transformed
system.
The
situation
is
made
w
orse
b
y
the
fact
that
one
m
ust
man
ually
desugar
all
of
Hask
ell's
syn
tactic
extensions
(nested
patterns,
list
comprehensions,
etc)
|
th
us
losing
one
of
Hask
ell's
primary
features.
.
This
transformation
has
to
b
e
applied
to
the
en
tire
program
including
the
libraries
and
the
standard
Prelude.
This
requires
access
to
the
source
co
de
of
the
en
tire
system
and,
since
the
Prelude
is
not
just
ordinary
Hask
ell
co
de,
requires
a
lot
of
co
op
eration
from
the
compiler
writer.
.
Adding
preconditions
to
the
primitiv
e
op
erations
is
hard
b
ecause,
for
example,
it
is
hard
to
c
hec
k
for
arithmetic
o
v
ero
w
without
causing
o
v
ero
w
y
ourself
and
b
ecause
the
preconditions
v
ary
from
one
piece
of
hardw
are
to
the
next.
.
W
rapping
ev
ery
data
constructor
in
a
Value
constructor
is
exp
ensiv
e:
almost
ev
ery-
thing
b
ecomes
t
wice
as
big
and
t
wice
as
slo
w
(w
e
expand
on
this
in
the
next
section).
.
Standard
program
transformations
c
hange
the
meaning
of
program
whic
h
raise
excep-
tions.
F
or
example,
replacing
a
+
b
b
y
b
+
a
c
hanges
the
result
of
this
expression
let
{
a
=
error
"a";
b
=
error
"b"
}
in
a
+
b


data
E
a
=
Error
(E
String)
|
Value
a
instance
Monad
E
where
Error
s
>>=
k
=
Error
s
Value
a
>>=
k
=
k
a
return
a
=
Value
a
Figure
:
The
Exception
Monad
x
y
=
x
(x
!
e)
y
=
return
(x
!
e
y
)
(e

e

)
y
=
e

y
`apply`
e

y
wher
e
apply
t
u
=
t
>>=
f
!
f
u
(C
e

:
:
:
e
m
)
y
=
return
(C
e

y
:
:
:
e
m
y
)
(case
e
off
C
x

:
:
:
x
m
!
e

;
!
e

g)
y
=
e
y
>>=
x
!
case
x
off
C
x

:
:
:
x
m
!
e

y
;
!
e

y
g
k
y
=
return
k
(op
e

:
:
:
e
m
)
y
=
e

y
>>=
x

!
:
:
:
e
m
y
>>=
x
m
!
op
y
x

:
:
:
x
m
(error
s)
y
=
Error
s
y
Figure
:
The
Call
By
Name
T
ranslation
for
Core
Hask
ell
average
::
[Float]
->
Float
average
=
\
xs
->
(/)
(sum
xs)
(length
xs)
==>
average
::
E
(E
[Float]
->
E
Float)
average
=
return
(\xs
->
divide
(sum
`apply`
xs)
(length
`apply`
xs))
divide
::
E
Float
->
E
Float
->
E
Float
divide
x
y
=
x
>>=
\
x'
->
y
>>=
\
y'
->
divide'
x
y
where
divide'
x
0
=
Error
(Value
"division
by
0")
divide'
x
y
=
return
(x
/
y)
Figure
:
The
Call
b
y
Name
T
ranslation
in
Action


.
This
transformation
pro
vides
no
help
with
innite
lo
ops.
Problems
,

and

alone
are
enough
to
render
this
approac
h
infeasible
but
can
b
e
solv
ed
b
y
making
exception
handling
part
of
the
language
and
applying
the
transformation
au-
tomatically
.
Problem

can
b
e
largely
solv
ed
b
y
careful
implemen
tation
and
is
discussed
in
Section
.
Problem

is
a
ma
jor
problem
requiring
a
certain
amoun
t
of
compromise
of
theoretical
b
eaut
y
for
practical
utilit
y
and
is
discussed
in
Section
.
Problem

is
a
ma
jor
thorn
in
our
side:
w
e're
forced
to
tak
e
a
pragmatic
approac
h
and
treat
these
as
resource
limits
(the
limited
resource
b
eing
the
patience
or
lifetime
of
the
user!).

An
Ecien
t
Implemen
tation
W
e
could
implemen
t
exception
handling
as
a
direct
source-to-source
transformation
(plus
some
sp
ecial
treatmen
t
of
primitiv
e
op
erations)
using
the
monad
and
translation
giv
en
in
Section
.
W
e
c
hose
not
to
do
so
b
ecause
the
transformation
is
v
ery
exp
ensiv
e:
ev
erything
b
ecomes
t
wice
as
big
and
t
wice
as
slo
w.
F
or
example,
using
the
STG
mac
hine
on
a
-bit
arc
hitecture,
a
Cons
cell
increases
in
size
from

b
ytes
(
tag
w
ord
plus

p
oin
ters)
to
0
b
ytes
(a
Cons
cell
plus
a
Value
cell
whic
h
con
tains

tag
w
ord
and

p
oin
ter)
and
an
Int
cell
increases
from

b
ytes
to

b
ytes.
W
orse,
all
access
to
the
elds
of
a
data
constructor
requires
t
w
o
case
analyses
instead
of
one;
all
function
applications
require
a
case
analysis
and
all
primops
need
an
error
c
hec
k.
This
o
v
erhead
can
b
e
reduced
somewhat
b
y
adding
a
new
constructor
to
ev
ery
data
t
yp
e.
F
or
example,
Bool
and
List
could
b
e
dened
as
follo
ws:
data
Bool
=
Error_Bool
Error_String
|
False
|
True
data
List
a
=
Error_List
Error_String
|
Nil
|
Cons
a
(List
a)
This
eliminates
the
space
o
v
erhead
on
constructors
and
eliminates
the
time
o
v
erhead
on
case
analyses,
but
the
follo
wing
problems
remain:

It's
not
p
ossible
to
ha
v
e
a
p
olymorphic
error
function:
w
e
m
ust
use
a
distinct
error
function
for
eac
h
t
yp
e
or
w
e
m
ust
o
v
erload
error
and
mo
dify
the
t
yp
e
of
ev
ery
p
oly-
morphic
function
whic
h
raises
a
p
olymorphic
error.

This
will
not
w
ork
for
Ints
or
functions
since
these
are
not
ordinary
datat
yp
es.

Raising
an
exception
is
relativ
ely
slo
w:
for
ev
ery
case
expression
b
eing
executed
w
e
ha
v
e
to
execute
something
lik
e
this:
case
e
of
{
Error_Bool
err
->
Error_List
err
;
False
->
...
;
True
->
...
}


These
extra
case
alternativ
es
are
particularily
galling
b
ecause
they
are
so
trivial:
on
detecting
an
error
v
alue,
they
just
reraise
the
same
error
v
alue.
Our
solution
is
to
extend
the
abstract
mac
hine
with
direct
supp
ort
for
exception
handling.
Sp
ecically
,
the
catchException
function
pushes
a
sp
ecial
\exception
handler
frame"
on
to
the
stac
k
and
the
error
function
un
winds
the
stac
k
do
wn
to
the
topmost
\exception
handler
frame"
and
in
v
ok
es
the
asso
ciated
exception
handler.
On
a
na

v
e
graph
reduction
mac
hine,
our
job
w
ould
no
w
b
e
done
but
the
STG
mac
hine
(on
whic
h
w
e
implemen
ted
our
prop
osal)
dela
ys
up
dating
a
th
unk
un
til
after
the
th
unk
has
b
een
reduced
to
w
eak
head
normal
form.
Therefore,
w
e
m
ust
p
erform
all
those
p
ending
up
dates
as
w
e
un
wind
the
stac
k.
The
STG
mac
hine
main
tains
a
list
of
p
ending
up
dates
whic
h
it
threads
through
the
stac
k.
As
the
STG
mac
hine
en
ters
an
up
datable
th
unk,
it
adds
the
th
unk
to
the
list
and
as
it
returns
the
v
alue
of
a
th
unk,
it
up
dates
the
th
unk
with
its
v
alue
and
remo
v
es
the
th
unk
from
the
head
of
the
list.
T
o
add
exceptions
to
the
STG
mac
hine,
w
e
add
exception
handler
frames
to
the
up
date
list.
This
requires
the
follo
wing
c
hanges:

When
catchException
e
h
is
executed,
w
e
add
an
exception
handler
to
the
\up
date
list."

When
error
err
is
executed,
w
e
searc
h
do
wn
the
up
date
list
for
the
topmost
exception
handler
up
dating
eac
h
p
ending
up
date
with
an
error
th
unk
whic
h
will
reraise
err
if
the
th
unk
is
reen
tered.
W
e
then
apply
the
topmost
exception
handler
to
err.

When
returning
a
constructor
or
a
partially
applied
function
(i.e.
a
v
alue
that
is
in
w
eak
head
normal
form),
the
STG
mac
hine
already
tests
whether
the
top
of
the
stac
k
is
a
return
address
or
an
up
date
frame.
T
o
this,
w
e
add
a
second
test
to
c
hec
k
for
an
exception
handler
frame.
If
the
top
of
the
stac
k
is
a
return
address,
the
STG
mac
hine
jumps
to
that
address;
if
the
top
of
the
stac
k
is
an
up
date
frame,
the
STG
mac
hine
p
erforms
the
up
date,
p
ops
the
up
date
frame
and
tries
again;
and
if
the
top
of
the
stac
k
is
an
exception
handler,
the
STG
mac
hine
p
ops
the
exception
handler
and
tries
again.
The
second
test
lo
oks
lik
e
it
migh
t
b
e
exp
ensiv
e
but,
fortunately
,
w
e
are
able
to
exploit
an
optimisation
already
presen
t
in
the
STG
mac
hine
whic
h
is
designed
to
mak
e
the
rst
test
c
heap.
The
k
ey
idea
is
to
mak
e
up
date
frames
lo
ok
just
lik
e
return
addresses.
That
is,
the
topmost
w
ord
of
ev
ery
up
date
frame
is
the
address
of
co
de
whic
h
will
p
erform
an
up
date
when
executed.
With
this
small
c
hange,
there
is
no
need
to
test
whether
the
top
of
the
stac
k
is
a
return
address
or
not:
w
e
can
just
jump
to
the
address
without
a
test.
This
same
optimisation
w
orks
for
exception
handlers
to
o:
so
w
e
incur
no
extra
cost
when
w
e
add
exception
handling.
Note
that
w
e
do
not
ha
v
e
to
deal
with
return
addresses
(whic
h
are
pushed
b
y
case
ex-
pressions);
w
e
only
ha
v
e
to
deal
with
p
ending
up
dates.
This
a
v
oids
most
of
the
o
v
erhead
asso
ciated
with
the
simple
source-to-source
transformation.


The
b
eha
viour
of
the
mo
died
system
is
illustrated
in
gure

whic
h
sho
ws
the
steps
in
v
olv
ed
in
ev
aluating
the
expression
catchException
(error
"a"
+
)
(const
0)
Figures
i{v
sho
w
ho
w
the
STG
mac
hine
un
winds
the
spine
of
the
graph
on
to
the
stac
k
and
constructs
the
up
date
list.
Figure
i
sho
ws
the
initial
state
of
the
mac
hine:
the
stac
k
con
tains
a
p
oin
ter
to
the
represen
tation
of
the
expression
to
b
e
ev
aluated
(whic
h
is
stored
on
the
heap)
and
a
STOP
frame
(whic
h
is
the
head
of
the
up
date
list).
(The
STG
pap
er
do
es
not
men
tion
STOP
frames
but
they
w
ere
presen
t
in
the
implemen
tation
|
after
all,
the
last
\real"
up
date
frame
on
the
up
date
list
had
to
p
oin
t
to
something!)
Figure
ii
sho
ws
ho
w
an
up
date
frame
is
added
to
the
up
date
list
when
the
rst
th
unk
is
en
tered.
Figure
iii
sho
ws
ho
w
an
exception
handler
frame
is
added
to
the
up
date
list
when
catchException
is
executed.
Note
that
the
exception
handler
frame
con
tains
a
p
oin
ter
to
the
exception
handler
whereas
an
up
date
frame
con
tains
a
p
oin
ter
to
the
up
datee.
Figure
iv
sho
ws
another
up
date
frame
b
eing
added
to
the
up
date
list.
Figure
v
sho
ws
the
+
primitiv
e
op
eration
pushing
a
return
address
ret_+
on
the
stac
k
and
ev
aluating
its
rst
argumen
t.
Since
its
rst
argumen
t
is
an
error,
this
triggers
the
exception
handling
mec
hanism.
Figures
vi{x
sho
w
ho
w
the
STG
mac
hine
propagates
and
reco
v
ers
from
errors.
Figure
vi
sho
ws
the
topmost
p
ending
up
date
b
eing
up
dated
with
an
indirection
to
an
error
th
unk.
Figure
vii
sho
ws
the
exception
handler
frame
b
eing
p
opp
ed
o
the
stac
k
in
preparation
for
applying
the
handler
to
the
error
message
"a".
Figures
viii
and
ix
sho
w
the
exception
handler
const
0
b
eing
applied
to
the
error
message
"a".
Finally
,
gure
x
sho
ws
the
nal
up
datee
b
eing
up
dated
with
the
result
of
the
exception
handler
lea
ving
just
the
result
0
and
the
STOP
frame
on
the
stac
k.

A
Problem
and
Tw
o
Solutions
In
the
previous
section,
w
e
observ
ed
that
the
translation
brok
e
simple
transformations.
This
section
expands
on
the
problem
and
describ
es
t
w
o
solutions:
the
rst
one
is
ob
vious
but
do
esn't
quite
w
ork,
the
second
is
less
ob
vious
but
w
orks.
The
problem
is
that
standard
iden
tities
lik
e
the
follo
wing
hold
in
an
un
transformed
program
but
do
not
hold
in
a
transformed
program.
(This
problem
is
easily
v
eried
using
a
=
error
"a"
and
b
=
error
"b".)
Arithmetic
iden
tities:
a
+
b
=
b
+
a
a

b
=
b

a
a


=
a


IND
AP2
catch..
const
AP2
1
+
error
"a"
STOP
0
b
c
d
e
a
AP2
catch..
const
AP2
1
+
error
"a"
STOP
0
catch..
U
a
b
c
d
e
AP2
catch..
const
AP2
1
+
error
"a"
STOP
0
U
a
b
c
d
e
C
AP2
catch..
const
AP2
1
+
error
"a"
STOP
0
U
a
b
c
d
e
C
+
1
U
AP2
catch..
const
AP2
1
+
error
"a"
STOP
0
U
a
b
c
d
e
C
1
U
ret_+
AP2
catch..
const
STOP
0
error
"a"
U
a
b
c
d
C
IND
e
AP2
catch..
const
STOP
0
AP2
catch..
const
STOP
0
error
"a"
U
a
b
c
d
IND
e
AP2
catch..
const
STOP
0
error
"a"
const
STOP
0
IND
c
error
"a"
e
iv)
v)
iii)
ii)
i)
vii)
viii)
vi)
U
a
b
c
d
IND
e
error
"a"
"a"
x)
ix)
U
a
b
c
d
IND
e
const
"a"
a
b
d
Figure
:
Catc
hing
Exceptions
in
the
STG
mac
hine


Rearrangemen
t
of
non-failing
case:
case
a
of
(a;
a)
->
case
b
of
(b;
b)
->
(a
+
b;
a
+
b)
=
case
b
of
(b;
b)
->
case
a
of
(a;
a)
->
(a
+
b;
a
+
b)
The
problem
with
these
\reordering
transformations"
is
that
they
c
hange
the
dep
endencies
within
the
program
and
so
c
hange
whic
h
exception
a
program
will
raise.
Since
reliabilit
y
(and,
hence,
exception
handling)
is
essen
tial
for
real
w
orld
use,
the
ob
vious
solution
is
to
outla
w
suc
h
transformations.
This
is
unpalatable
for
sev
eral
reasons:
.
One
of
the
principal
argumen
ts
for
using
lazy
ev
aluation
is
that
it
supp
orts
trans-
formations
suc
h
as
those
ab
o
v
e.
This
allo
ws
programs
to
b
e
dev
elop
ed,
explained
or
ev
en
pro
v
ed
correct
b
y
transforming
an
inecien
t
sp
ecication
in
to
an
ecien
t
imple-
men
tation.
Losing
this
abilit
y
to
freely
transform
programs
w
ould
thro
w
a
w
a
y
one
of
Hask
ell's
main
strengths.
.
Simply
outla
wing
reordering
transformations
is
not
enough
to
mak
e
exception
han-
dling
predictable.
W
e
also
ha
v
e
to
c
ho
ose
and
clearly
do
cumen
t
the
presen
t
order
of
ev
aluation
in
primitiv
e
op
erations
suc
h
as
(+)
::
Int
->
Int
->
Int,
the
Hask
ell
Prelude
and
standard
libraries,
and
an
y
non-standard
libraries
w
e
ma
y
obtain
from
a
third
part
y
.
It
seems
unreasonable
to
insist
on
this
lev
el
of
do
cumen
tation
or
to
exp
ect
normal
programmers
to
mak
e
use
of
it.
Indeed,
while
w
e
kno
w
of
man
y
libraries
(for
other
languages)
whic
h
list
whic
h
exceptions
a
function
ma
y
raise,
none
pro
vide
detailed
do
cumen
tation
of
exactly
what
circumstances
cause
eac
h
exception
to
b
e
raised
and
ho
w
these
exceptions
are
prioritised.
.
Optimising
Hask
ell
compilers
use
transformations
lik
e
the
ab
o
v
e
to
automatically
im-
pro
v
e
the
p
erformance
of
Hask
ell
programs.
If
w
e
forbid
these
transformations,
or
attac
h
side
conditions
to
their
use,
optimising
compilers
b
ecome
m
uc
h
more
limited
in
scop
e.
In
particular,
they
w
ould
ha
v
e
great
trouble
exploiting
the
eects
of
strictness
analysis
|
the
w
ork
er-wrapp
er
transformation
is
no
longer
v
alid.
A
second
solution
is
to
accept
that
programmers
will
not
b
e
able
to
reason
ab
out
precisely
whic
h
exception
a
program
will
raise
and
pro
vide
a
new
seman
tics
(or
new
reasoning
to
ols
|
there
is
little
practical
dierence)
whic
h
accepts
a
certain
degree
of
non-determinism.
W
e
b
eliev
e
this
is
acceptable
to
programmers
b
ecause
programmers
using
languages
whic
h
sup-
p
ort
exception
handling
seem
willing
to
accept
imprecise
statemen
ts
as
to
whic
h
exceptions
a
function
migh
t
raise
in
return
for
more
concise
do
cumen
tation
and
more
implemen
tation
freedom.
The
problem
in
making
exception
handling
non-deterministic
is
in
con
trolling
the
amoun
t
of
non-determinism:
if
w
e
allo
w
to
o
m
uc
h
non-determinism,
the
seman
tics
will
confuse
pro-
grams
that
the
programmer
wishes
to
k
eep
distinct;
if
w
e
allo
w
to
o
little
non-determinism,
	

then
w
e
m
ust
sev
erely
restrict
exception
handling
and/or
limit
the
set
of
transformations
whic
h
w
e
consider
v
alid.
T
o
resolv
e
this
problem,
w
e
b
orro
w
an
idea
from
Hughes
and
O'Donnell's
seminal
pap
er
[]
on
reasoning
ab
out
non-deterministic
functional
programs.
Their
main
idea
w
as
to
separate
deterministic
parts
of
their
programs
from
non-deterministic
parts
of
their
programs
and
to
restrict
non-determinism
to
the
top-lev
el
of
their
programs.
Applying
this
idea
to
exception
handling,
w
e
tak
e
care
to
k
eep
(non-deterministic)
exception
handling
co
de
separate
from
normal
(deterministic)
co
de.
This
requires
just
one
c
hange
to
the
implemen
tation
describ
ed
in
Section
:
w
e
restrict
catchException
to
the
IO
monad
b
y
giving
it
the
more
restrictiv
e
t
yp
e
catchException
::
IO
a
->
(String
->
IO
a)
->
IO
a
By
limiting
exception
catc
hing
to
the
IO
monad,
w
e
are
able
to
use
non-determinism
in
describing
exception
handling
without
the
non-determinism
con
taminating
the
seman
tics
of
\pure"
parts
of
the
program.
The
next
t
w
o
sections
describ
e
ho
w
w
e
use
non-determinism
when
reasoning
ab
out
exception
handling.
.
Non-deterministic
exceptions:
a
rst
attempt
F
or
a
long
time,
w
e
though
t
the
w
a
y
to
mak
e
exception
handling
non-deterministic
w
as
to
tak
e
a
second
idea
from
Hughes
and
O'Donnell
[]:
.
They
in
tro
duce
a
new
abstract
data
t
yp
e
f
g
whose
elemen
ts
are
sets
of
v
alues
of
t
yp
e

but
whose
in
tended
implemen
tation
is
a
single
represen
tativ
e
elemen
t
c
hosen
non-deterministically
from
the
set
it
represen
ts.
.
Non-deterministic
expressions
are
clearly
distinguished
b
y
their
t
yp
e:
a
non-deterministic
Int
expression
is
giv
en
t
yp
e
fInt
g.
.
The
op
erations
on
sets
are
carefully
designed
so
that
non-determinism
cannot
le
ak
out
in
to
deterministic
parts
of
the
program.
All
op
erations
on
non-deterministic
sets
generate
non-deterministic
sets
as
results.
In
particular,
they
explicitly
do
not
pro
vide
a
function
lik
e
choose
::
{a}
->
a
Rather,
non-deterministic
programs
(i.e.
expressions
of
t
yp
e
fag)
can
only
b
e
run
at
the
\top-lev
el"
of
the
program.
Applying
this
idea
to
our
seman
tics,
w
e
replace
the
error
string
with
a
set
of
error
strings.
That
is,
w
e
c
hange
the
exception
t
yp
e
E
describ
ed
in
Section

to
data
E
a
=
Errors
{E
String}
|
Value
a
0

and
c
hanged
the
exception
monad
accordingly
.
In
particular,
w
e
c
hange
primitiv
e
op
erations
to
return
the
union
of
all
exceptional
argumen
ts
instead
of
just
returning
the
rst
exceptional
argumen
t.
This
c
hange
restores
the
comm
utativit
y
of
in
teger
addition
but
it
do
es
not
restore
the
v
alidit
y
of
all
the
other
transformations.
In
particular,
the
c
ase
of
unfailing
c
ase
transformation
giv
en
ab
o
v
e
still
do
es
not
hold.
With
a
little
ingen
uit
y
and
a
lot
of
c
hanges
w
e
w
ere
able
to
restore
the
v
alidit
y
of
the
c
ase
of
unfailing
c
ase
transformation
as
w
ell,
but
the
resulting
system
suered
from
t
w
o
fatal
a
ws:
.
it
is
hard
to
understand
the
resulting
system;
and
.
it
is
harder
y
et
to
imagine
pro
ving
the
resulting
system
correct
w.r.t.
a
set
of
transfor-
mations.
W
e
therefore
reject
this
approac
h
as
b
eing
to
o
hard
to
understand
and
to
o
hard
to
v
alidate
whether
it
could
accoun
t
for
all
the
non-determinism
asso
ciated
with
a
set
of
transformations.
.
Non-deterministic
exceptions:
a
second
attempt
The
fundamen
tal
problem
with
the
previous
approac
h
is
that
it
do
es
not
directly
men
tion
the
transformations
that
w
e
w
an
t
to
preserv
e.
So
ho
w
are
w
e
mean
t
to
pro
v
e
that
they
are
preserv
ed;
and
ho
w
are
w
e
mean
t
to
t
w
eak
the
system
if
w
e
w
an
t
new
transformations
to
hold?
W
e
x
this
problem
b
y
making
the
transformations
used
in
the
compiler
(and
b
y
library
writers)
explicit
in
the
seman
tics.
Let
us
supp
ose
that
w
e
ha
v
e
a
relation
 !
whic
h
captures
all
the
transformations
that
the
compiler
migh
t
apply
(that
is,
e
 !
e
if
the
compiler
migh
t
transform
e
in
to
e
during
compilation).
Then
the
set
of
v
alues
that
an
expression
ma
y
return
is
N
D
[
[e]
].
N
D
[
[e]
]
=
fD
[
[e
0
y
]
]
j
e
 !

e
0
g
where
D
[
[e]
]
is
the
normal
(deterministic!)
v
alue
of
e
and
 !

is
the
reexiv
e,
transitiv
e
closure
of
 !.
(The
application
of
the
monad
translation
y
to
the
transformed
expression
e
0
reects
the
fact
that
w
e
implemen
t
the
monad
translation
in
our
abstract
mac
hine
and
so
it
is
applied
after
the
compiler
has
done
its
job.)
If
D
[
[e]
]
=
?,
then
N
D
[
[e]
]
will,
of
course,
con
tain
a
single
v
alue
(assuming
that
 !
resp
ects
the
Hask
ell
seman
tics).
But
if
D
[
[e]
]
=
?,
then
N
D
[
[e]
]
ma
y
con
tain
m
ultiple
v
alues
dep
ending
on
e
and
 !.
T
o
see
ho
w
the
c
hoice
of
 !
aects
the
seman
tics,
w
e
consider
three
p
ossible
c
hoices
of
transformation.
.
If
the
compiler
do
es
no
optimisation,
then
 !
is
the
iden
tit
y
relation
and
N
D
[
[e]
]
reduces
to
N
D
[
[e]
]
=
fD
[
[e
y
]
]g
W
e
can
reason
exactly
ab
out
what
exceptions
will
b
e
raised
but
w
e
ha
v
e
to
b
e
careful
when
transforming
programs.


.
A
t
the
other
extreme,
if
w
e
ha
v
e
no
idea
what
transformations
the
compiler
(or
library
writers)
p
erform,
w
e
ha
v
e
to
assume
they
p
erform
an
y
v
alid
transformation.
That
is,
e
 !
e
i
D
[
[e]
]
=
D
[
[e]
].
This
is
alw
a
ys
a
safe
c
hoice,
but
it
includes
suc
h
dubious
transformations
as:
error
"a"
 !
error
"b"
error
"a"
 !
let
x
=
x
in
x
whic
h
real
compilers
are
unlik
ely
to
use.
.
Finally
,
if
w
e
kno
w
that
the
compiler
p
erforms
(only)
the
unfailing
case
of
case
trans-
formation
giv
en
earlier,
w
e
c
ho
ose
 !
accordingly
and
w
e
ha
v
e
N
D
[
[case
a
of
(a;
a)
->
case
b
of
(b;
b)
->
(a
+
b;
a
+
b)]
]
=
N
D
[
[case
b
of
(b;
b)
->
case
a
of
(a;
a)
->
(a
+
b;
a
+
b)]
]
The
idea
then
is
to
c
ho
ose
a
relation
 !
whic
h
includes
the
transformations
that
the
compiler
and
library
writers
t
ypically
use
but
excludes
those
that
are
v
alid
but
unlik
ely
,
suc
h
as
c
hanging
error
messages
or
replacing
error
messages
with
innite
lo
ops.
There
is
just
one
y
in
the
oin
tmen
t:
man
y
standard
transformations
allo
w
a
program
whic
h
raises
an
error
to
b
e
transformed
in
to
a
program
whic
h
do
es
not
terminate
and
so
w
e
are
forced
to
confuse
non-termination
with
raising
an
exception
in
our
seman
tics.
This
is
not
particularily
satisfactory
but
it
seems
to
b
e
the
b
est
w
e
can
do
|
and
it
can
b
e
dealt
with
b
y
adding
facilities
to
catc
h
in
terrupts
or
timeouts
as
discussed
in
the
next
section.

Unication
The
dev
elopmen
t
in
the
previous
sections
ignored
the
in
teraction
b
et
w
een
exception
handling
and
t
w
o
other
exception-lik
e
features
of
Hask
ell.
This
section
describ
es
these
features
and
suggests
a
unied
design
whic
h
com
bines
all
three.
Only
the
rst
has
b
een
implemen
ted
so
far.
Hask
ell
.
[]
in
tro
duced
a
restricted
form
of
exception
handling
whic
h
w
as
lab
elled
\error
catc
hing".
This
w
as
a
v
ery
conserv
ativ
e
design
whic
h
restricted
b
oth
r
aising
and
c
atching
of
exceptions
to
the
IO
monad.
One
can
view
our
exception
handling
features
as
an
extension
of
\error
catc
hing"
in
whic
h
exceptions
can
b
e
raised
outside
of
the
IO
monad.
The
\error
catc
hing"
op
erations
pro
vided
in
Hask
ell
.
are
as
follo
ws:
catch
::
IO
a
->
(IOError
->
IO
a)
->
IO
a
fail
::
IOError
->
IO
a


In
addition,
man
y
input/output
op
erations
in
the
IO
monad
call
fail
in
resp
onse
to
error
situations
in
the
execution
en
vironmen
t.
F
or
example,
writeFile
\fails"
if
the
named
le
do
es
not
exist
or
is
not
writable.
T
o
write
robust
programs,
one
m
ust
catc
h
b
oth
Hask
ell
.
errors
and
our
exceptions
b
y
writing
something
lik
e:
catchException
(catch
e
h)
h
If
w
e
assume
that
most
programmers
will
w
an
t
to
catc
h
b
oth
kinds
of
exceptions,
it
mak
es
sense
to
com
bine
catch
and
catchException
in
to
a
single
op
eration
whic
h
catc
hes
either
kind
of
error.
The
resulting
system
lo
oks
lik
e
this:
catch
::
IO
a
->
(IOError
->
IO
a)
->
IO
a
fail
::
IOError
->
IO
a
raise
::
IOError
->
a
(W
e
also
need
to
extend
the
IOError
data
t
yp
e;
this
is
discussed
later
in
this
section.)
Merging
these
op
erations
do
esn't
just
simplify
life
for
the
programmer,
it
also
simplies
the
implemen
tation
since
our
exception
handling
mec
hanism
can
b
e
used
to
ecien
tly
implemen
t
Hask
ell
.'s
error
catc
hing
op
erations.
W
e
recen
tly
extended
the
STG
mac
hine
with
an
in
terrupt
catc
hing
mec
hanism
[
].
In
a
sequen
tial
Hask
ell
system,
w
e
add
this
function
catchInterrupt
::
IO
a
->
IO
a
->
IO
a
The
seman
tics
is
as
follo
ws:
catchInterrupt
e
h
executes
e;
if
e
returns
a
v
alue
without
b
eing
in
terrupted,
catchInterrupt
e
h
returns
the
v
alue
returned
b
y
e;
if
an
in
terrupt
o
ccurs
while
executing
e,
then
h
is
executed.
Again,
programmers
are
lik
ely
to
w
an
t
to
catc
h
b
oth
exceptions
and
in
terrupts
and
so
w
e
extend
catch
and
IOError
accordingly
.
There
is
just
one
subtlet
y:
when
propagating
ex-
ceptions,
w
e
o
v
erwrite
p
ending
up
datees
with
error
v
alues;
when
in
terrupting
programs,
w
e
o
v
erwrite
p
ending
up
dates
with
rev
erted
blac
kholes
(this
is
the
main
sub
ject
of
our
other
pap
er
[]).
The
reason
for
this
dierence
is
that
if
an
internal
exception
is
raised
when
executing
an
expression
e,
that
expression
will
alw
a
ys
raise
an
exception
but
if
an
external
exception
(suc
h
as
an
in
terrupt)
is
raised
when
executing
e,
it
is
en
tirely
p
ossible
that
no
external
exception
w
ould
b
e
raised
the
next
time
e
is
ev
aluated.
Finally
,
Hask
ell
.'s
IOError
t
yp
e
needs
to
mo
died
to
let
us
enco
de
errors,
in
ternal
excep-
tions
and
external
exceptions
to
the
programmer.
W
e
ha
v
e
not
explored
this
c
hange
as
y
et
b
ecause
it
is
not
y
et
clear
what
programmers
will
w
an
t
to
do
with
IOErrors.
If
all
they
w
an
t
to
do
is
prin
t
them
on
the
screen,
it
is
sucien
t
to
pro
vide
a
function
to
con
v
ert
IOErrors
to
Strings;
if
they
w
an
t
to
detect
distinct
exceptions
and
resp
ond
to
them
in
dieren
t
w
a
ys,
will
they
w
an
t
to
mak
e
a
clear
distinction
b
et
w
een
errors,
in
ternal
exceptions
and
external
exceptions
or
w
ould
suc
h
a
distinction
merely
get
in
the
programmer's
w
a
y?



Related
W
ork
There
ha
v
e
b
een
three
previous
attempts
to
add
exception
handling
to
lazy
functional
lan-
guages.
Gerald
[0]
w
as
an
early
attempt
to
add
exception
handling
to
a
lazy
language
|
but
it
has
no
clear
seman
tics
and
seems
to
b
e
limited
to
un
t
yp
ed
languages.
W
adler's
excep-
tion
monad
and
call
b
y
name
translation
[
]
is
seman
tically
sound
(indeed,
it
is
the
basis
for
our
seman
tics!)
and
requires
no
language
extensions
but,
as
w
e
discussed
in
Section
,
it
is
tedious
to
apply
and
renders
programs
almost
unreadable.
Dornan
and
Hammond
[,
]
prop
osed
the
same
seman
tics
that
w
e
describ
e
in
Section
,
implemen
ted
their
prop
osal
and
pro
v
ed
that
the
seman
tics
is
sound
(conuen
t
and
consisten
t).
The
primary
dierence
b
et
w
een
their
w
ork
and
ours
is
our
observ
ation
that
soundness
is
not
sucien
t:
adding
ex-
ception
handling
breaks
a
large
n
um
b
er
of
transformations.
Our
solution
is
to
limit
exception
catc
hing
to
the
IO
monad
(where
less
transformations
are
v
alid)
and
to
use
non-determinism
to
describ
e
the
seman
tics
of
programs
that
use
exception
handling.
Finally
,
Henderson
[
]
indep
enden
tly
prop
osed
using
Hughes
and
O'Donnell's
non-deterministic
sets
when
catc
hing
exceptions.
A
k
ey
dierence
is
that
instead
of
pro
viding
catchException
in
the
IO
monad,
he
pro
vides
the
follo
wing
function.
ndset_catch
::
a
->
Either
{String}
a
The
problem
with
this
(more
exible)
prop
osal
is
that
it
allo
ws
non-determinism
to
con
tam-
inate
the
pure
parts
of
the
system
with
non-determinism
as
w
ell:
w
e
cannot
predict
whether
this
pure
expression
will
terminate
or
not.
let
{
a
=
a;
b
=
error
"b"
}
in
(seq
(ndset_catch
(a+b))
"Mystery")

Discussion
It
is
relativ
ely
straigh
tforw
ard
to
add
exception
handling
to
a
Hask
ell
implemen
tation;
it
is
m
uc
h
harder
to
design
a
language
extension
whic
h
preserv
es
the
essen
tial
prop
erties
of
a
lazy
language.
This
pap
er
describ
es
ho
w
to
do
b
oth.
The
implemen
tation
is
simple,
ecien
t
and
ob
vious;
the
design
is
rather
subtle
and
requires
some
care
to
pro
duce
a
design
whic
h
balances
pragmatic
concerns
(w
e
ha
v
e
to
b
e
able
to
catc
h
exceptions)
with
more
theoretical
concerns
(w
e
ha
v
e
to
b
e
able
to
reason
ab
out
our
programs).
Ac
kno
wledgmen
ts:
This
w
ork
w
as
carried
out
while
w
orking
with
Simon
P
eyton
Jones,
Simon
Marlo
w
and
Sigb
jorn
Finne
(all
at
Glasgo
w
Univ
ersit
y)
to
reimplemen
t
the
STG
mac
hine.
W
e
b
eneted
from
man
y
con
v
ersations
with
them
and
from
b
eing
able
to
implemen
t
our
ideas
in
a
state
of
the
art
Hask
ell
implemen
tation.
Thanks
to
o,
to
P
aul
Hudak
and
John
P
eterson
(b
oth
at
Y
ale)
for
commen
ts
on
this
pap
er
and
to
P
aul
esp
ecially
for
the
Dark
Shado
ws
con
v
ersation
whic
h
inspired
section
..


References
[]
C.
Dornan
and
K.
Hammond.
Exception
handling
in
lazy
functional
languages.
Researc
h
Rep
ort
CSC
	0/R,
Glasgo
w
Univ
ersit
y
,
Departmen
t
of
Computing
Science,
Jan
uary
		0.
[]
K.
Hammond.
Exception
handling
in
a
parallel
functional
language.
Researc
h
Rep
ort
CSC
	/R,
Glasgo
w
Univ
ersit
y
,
Departmen
t
of
Computing
Science,
August
		.
[]
K.
Hammond
and
A.
Gordon.
Monadic
I/O
in
Hask
ell
..
In
Pr
o
c
e
e
dings
of
the
		
Haskel
l
Workshop,
pages
0{,
La
Jolla,
California,
June
		.
[]
F.
Henderson.
electronic
mail
to
the
Hask
ell
mailing
list.
June
		.
[]
R.
Hughes
and
J.
O'Donnell.
Expressing
and
reasoning
ab
out
non-deterministic
func-
tional
programs.
In
K.
Da
vis
and
R.
Hughes,
editors,
Glasgow
F
unctional
Pr
o
gr
amming
Workshop,
W
orkshops
in
Computing,
pages
0{.
Springer
V
erlag,
		.
[]
S.
P
.
Jones
and
P
.
W
adler.
Imp
erativ
e
functional
programming.
In
0th
POPL,
pages
{,
Charleston,
Jan
		.
A
CM.
[]
S.
Marlo
w
and
A.
Reid.
The
Hugs-GHC
libraries.
Hugs
compiler
do
cumen
tation,
June
		.
[]
J.
P
eterson
and
K.
Hammond
(editors).
Rep
ort
on
the
Programming
Language
Hask
ell
.,
A
Non-strict
Purely
Functional
Language.
Researc
h
Rep
ort
Y
ALEU/DCS/RR-
0,
Y
ale
Univ
ersit
y
,
Departmen
t
of
Computer
Science,
April
		.
[	]
S.
P
eyton
Jones,
T.
Nordin,
and
A.
Reid.
Greencard:
a
foreign-language
in
terface
for
Hask
ell.
In
Pr
o
c
Haskel
l
Workshop,
Amsterdam,
June
		.
[0]
A.
Reev
es,
D.
Harrison,
A.
Sinclair,
and
P
.
Williamson.
Gerald:
An
exceptional
lazy
functional
programming
language.
In
K.
Da
vis
and
R.
Hughes,
editors,
Glasgow
F
unc-
tional
Pr
o
gr
amming
Workshop,
W
orkshops
in
Computing,
pages
{	0.
Springer
V
er-
lag,
		.
[]
A.
Reid.
Mallo
c
p
oin
ters
and
stable
p
oin
ters:
Impro
ving
Hask
ell's
foreign
language
in
terface.
draft
pro
ceedings
of
Glasgo
w
F
unctional
Programming
W
orkshop,
July
		.
[]
A.
Reid.
Putting
the
Spine
bac
k
in
the
Spineless
Tagless
G-mac
hine:
an
implemen
tation
of
rev
ertible
blac
kholes.
Submitted
to
IFL'	,
August
		.
[]
P
.
W
adler.
Comprehending
monads.
In
Pr
o
c
A
CM
Confer
enc
e
on
Lisp
and
F
unctional
Pr
o
gr
amming,
Nice,
June
		0.
A
CM.


